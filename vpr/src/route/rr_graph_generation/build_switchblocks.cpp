/*
 * Author(s): Oleg Petelin
 * Last revised: September, 2015
 *
 ************ NEW SWITCH BLOCK HIGH-LEVEL DESCRIPTION ************
 * The new switch block description format allows a much finer level of control over the switch blocks generated by VPR.
 * Whereas a user previously only had the choice of 'wilton', 'universal', 'subset', or 'full' switch blocks, the new
 * format allows a user to specify a small set of mathematical formulas that describe the switch block connections. This format
 * allows the specification of all the switch blocks previously available in VPR as well as a great number of new switch block patterns.
 *
 * The new switch block description format is loosely based on chapter 7 of Lemieux' and Lewis' "Design of Interconnection Networks
 * for Programmable Logic" book (2004).
 *
 *
 ************ FILES AND THEIR PURPOSE ************
 * The overall flow of parsing and building the new switch blocks involves reading switch block descriptions from the VPR
 * architecture file and then building the switch blocks according to these descriptions in build_rr_graph (rr_graph.c).
 * This functionality is split across different files which are described below:
 *
 * read_xml_arch_file.c (under libarchfpga):
 * calls ProcessSwitchblocks which fills s_arch-->switchblocks with info about each user-defined switch blocks
 * calls functions from parse_switchblocks.c to build switch block data structures (reads-in permutation functions
 * and wire segment source/dest connection info)
 * ProcessSegments has been modified to give a string name to each segment type (in t_segment_inf).
 * parse_switchblocks.c (under libarchfpga):
 * provides functions to help load switch block data structures during XML parsing of VPR architecture file
 * provides functions to evaluate switch block permutation formulas and return a numeric result
 * SetupVPR.c:
 * SetupRoutingArch copies switch block information from s_arch to s_det_routing_arch
 * physical_types.h (under libarchfpga):
 * defines classes, structs and typedefs for parsing switch blocks from XML architecture file
 * vpr_types.h
 * s_det_routing_arch carries info about custom switch blocks
 * build_switchblocks.c (this file):
 * builds t_sb_connection_map sparse array containing target connections for each wire in each horizontal/vertical channel segment.
 * 'compute_wire_connections' is the most important function here -- it computes the set of wire segments that a given wire at
 * (x, y, from_side, to_side, from_wire) should connect to.
 * rr_graph.c:
 * calls alloc_and_load_switchblock_permutations (from build_switchblocks.c) which creates the t_sb_connection_map
 * rr_graph2.c:
 * get_wire_to_chan_seg is called within get_wire_to_wires which looks at t_sb_connection_map to create the edges that
 * connect a source wire segment into a destination channel segment
 *
 *
 ************ DESCRIPTION OF SWITCH BLOCK SPECIFICATION ************
 * Some terminology:
 *
 * Wire segment type: a named group of wires defined in the architecture file.
 * Wire subsegment number: a number assigned to a wire subsegment relative to the wire's start coordinate (see diagram below).
 * Used to define a collection of wire segments that have a start point in the same column (or row) of the FPGA.
 * Wire switch point: a number assigned to a specific switch block along a wire segment
 *
 * Ex: for a length-4 unidirectional wire segment going in the decreasing direction:
 * wire switch point    0<-------3<-------2<-------1<-------0
 * wire subsegment #         3        2        1        0
 *
 * The new switch block format allows a user to specify mathematical permutation functions that describe how different types of wires will connect at different switchpoinnts. One or more wire types *and* one or more switch points define a set of wires, and each switch block connection is specified in terms of a source and destination set. Specifically, the permutation functions prescribe how a set of from_type/from_switchpoint wires (the source set) in one channel segment should connect to a set of to_type/to_switchpoint wires (the destination set) in an adjacent channel segment. This provides for an abstract but very flexible way of specifying different switch block patterns.
 *
 * An example from an XML VPR architecture file is given below.
 *
 * The 'wireconn' entries define ordered source/destination sets of wire segments that should be connected with the specified permutation functions. The wireconn entries essentially "re-index" the channel so that a permutation function of 't/2' means that the t'th wire segment in the source wireconn set should connect to the [(t/2)%W]'th wire segment in the destination set where W is the size, or effective channel width, of the destination set (note that permutation functions are implicitly modulo W so that all functions evaluate to a number that indexes into the destination set).
 *
 * <!-- Specify that custom switch blocks will be used. This is backwards compatible with VPR's previous wilton/subset/univeral specification,
 * but "custom" is specified instead. -->
 * <switch_block type="custom"/>			<-- backwards-compatible with VPR's previous wilton/subset/universal/full specification
 * ...
 * ...
 * <!-- Segment specification is as before, except that a "name" is also specified for each segment. Each segment defines a type of wire. -->
 * <segmentlist>
 * <segment freq="0.85" name="l4" length="4" type="unidir" Rmetal="232" Cmetal="0.0">
 * <mux name="l4_mux"/>
 * <sb type="pattern">1 1 1 1 1</sb>
 * <cb type="pattern">1 1 1 1</cb>
 * </segment>
 * <segment freq="0.15" name="l8_global" length="8" type="unidir" Rmetal="33.8" Cmetal="0.0">
 * <mux name="l8_mux"/>
 * <sb type="pattern">1 1 1 1 1 1 1 1 1</sb>
 * <cb type="pattern">1 1 1 1 1 1 1 1</cb>
 * </segment>
 * </segmentlist>
 * ...
 * ...
 * <!-- Custom switch blocks are declared here -->
 * <switchblocklist>
 * <!-- Each "switchblock" entry is given a name. Type specifies either a unidirectional or bidirectional switch block -->
 * <switchblock name="my_switchblock" type="unidir">
 * <!-- Location to implement this switch block (EVERYWHERE/CORE/PERIMETER/CORNER/FRINGE) -->
 * <switchblock_location type="EVERYWHERE"/>
 * <!-- A list of permutation functions. Any number can be specified (for instance two "lt" entries can be specified to increase
 * Fs of connections from the left to the top switch block sides -->
 * <switchfuncs>
 * <!-- "lr" means left-to-right, "lt" means left to top, etc. Formulas support different operators which are discussed later -->
 * <func type="lr" formula="t"/>
 * <func type="lt" formula="W-t"/>
 * <func type="lb" formula="W+t-1"/>
 * <func type="rt" formula="W+t-1"/>
 * <func type="br" formula="W-t-2"/>
 * <func type="bt" formula="t"/>
 * <func type="rl" formula="t"/>
 * <func type="tl" formula="W-t"/>
 * <func type="bl" formula="W+t-1"/>
 * <func type="tr" formula="W+t-1"/>
 * <func type="rb" formula="W-t-2"/>
 * <func type="tb" formula="t"/>
 * </switchfuncs>
 * <!-- Wireconn entries define the sets of wires that should be connected with the above permutation functions -->
 * <wireconn from_type="l4" to_type="l4" from_switchpoint="0,1,2,3" to_switchpoint="0"/>
 * <wireconn from_type="l8_global" to_type="l8_global" from_switchpoint="0,4" to_switchpoint="0"/>
 * <wireconn from_type="l8_global" to_type="l4" from_switchpoint="0,4" to_switchpoint="0"/>
 * </switchblock>
 *
 * <switchblock name="another_switch_block" type="unidir">
 * ... switch block description ...
 * </switchblock>
 * </switchblocklist>
 *
 * Allowed symmbols and operators for the switch block permutation functions are described below (recall
 * that formulas are evaluated in 'parse_switchblocks.c'):
 * "+" -- addition
 * "-" -- subtraction
 * "/" -- division
 * "*" -- multiplication
 * "t" -- index of the wire segment in the source set
 * "W" -- size of the destination set
 *
 */

#include <algorithm>
#include <string_view>

#include "vtr_assert.h"
#include "vtr_memory.h"
#include "vtr_log.h"

#include "vpr_error.h"
#include "vpr_types.h"

#include "build_switchblocks.h"

#include "globals.h"
#include "physical_types.h"
#include "parse_switchblocks.h"
#include "vtr_expr_eval.h"
#include "rr_types.h"
#include "switchblock_scatter_gather_common_utils.h"

struct t_wireconn_scratchpad {
    vtr::FormulaParser formula_parser;
    vtr::t_formula_data formula_data;
    std::vector<t_wire_switchpoint> potential_src_wires;
    std::vector<t_wire_switchpoint> potential_dest_wires;
    std::vector<t_wire_switchpoint> scratch_wires;
};

/************ Function Declarations ************/

/* Compute the wire(s) that the wire at (x, y, from_side, to_side, from_wire) should connect to.
 * sb_conns is updated with the result */
static void compute_wire_connections(const t_physical_tile_loc& sb_loc,
                                     e_side from_side,
                                     e_side to_side,
                                     const t_chan_details& chan_details_x,
                                     const t_chan_details& chan_details_y,
                                     const t_switchblock_inf& sb,
                                     const t_wire_type_sizes& wire_type_sizes_x,
                                     const t_wire_type_sizes& wire_type_sizes_y,
                                     e_directionality directionality,
                                     t_sb_connection_map* sb_conns,
                                     vtr::RngContainer& rng,
                                     t_wireconn_scratchpad* scratchpad);

/* ... sb_conn represents the 'coordinates' of the desired switch block connections */
static void compute_wireconn_connections(e_directionality directionality,
                                         const t_chan_details& from_chan_details,
                                         const t_chan_details& to_chan_details,
                                         SwitchblockLookupKey sb_conn,
                                         const t_physical_tile_loc& from_loc,
                                         const t_physical_tile_loc& to_loc,
                                         e_rr_type from_chan_type,
                                         e_rr_type to_chan_type,
                                         const t_wire_type_sizes& wire_type_sizes_from,
                                         const t_wire_type_sizes& wire_type_sizes_to,
                                         const t_switchblock_inf& sb,
                                         const t_wireconn_inf& wireconn,
                                         t_sb_connection_map* sb_conns,
                                         vtr::RngContainer& rng,
                                         t_wireconn_scratchpad* scratchpad);

/**
 *
 * @brief calculates the wire indices belonging to the types in types in 'wire_type_sizes' and switchpoints in 'points' at the given channel segment
 *  @param chan_details channel segment details (length, start and end points, ...)
 *  @param chan_type channel type (CHANX/CHANY)
 *  @param x the wire x-coordinate
 *  @param y the wire y-coordinate
 *  @param side switch block side (top/right/bottom/left/above/under)
 *  @param wire_switchpoints_vec valid switch points at the given channel segment
 *  @param wire_type_sizes valid wire types
 *  @param is_dest whether wires are source or destination within a switch block connection
 *  @param switchpoint_order switchpoint order (fixed, shuffled) specified in the architecture file
 *  @param rng used to randomly shuffle switchpoint if required (shuffled order)
 *  @param output_wires collected wire indices that matches the specified types and switchpoints
 */
static void get_switchpoint_wires(const t_chan_seg_details* chan_details,
                                  e_rr_type chan_type,
                                  int x,
                                  int y,
                                  e_side side,
                                  const std::vector<t_wire_switchpoints>& wire_switchpoints_vec,
                                  const t_wire_type_sizes& wire_type_sizes,
                                  bool is_dest,
                                  e_switch_point_order switchpoint_order,
                                  vtr::RngContainer& rng,
                                  std::vector<t_wire_switchpoint>* output_wires,
                                  std::vector<t_wire_switchpoint>* scratch_wires);

/* adjusts a negative destination wire index calculated from a permutation formula */
static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind);

/************ Function Definitions ************/

t_sb_connection_map* alloc_and_load_switchblock_permutations(const t_chan_details& chan_details_x,
                                                             const t_chan_details& chan_details_y,
                                                             const DeviceGrid& grid,
                                                             const std::vector<bool>& inter_cluster_rr,
                                                             const std::vector<t_switchblock_inf>& switchblocks,
                                                             const t_chan_width& nodes_per_chan,
                                                             e_directionality directionality,
                                                             vtr::RngContainer& rng) {
    // Holds temporary memory for parsing.
    t_wireconn_scratchpad scratchpad;

    t_sb_connection_map* sb_conns = new t_sb_connection_map;

    const auto [wire_type_sizes_x, wire_type_sizes_y] = count_wire_type_sizes(chan_details_x, chan_details_y, nodes_per_chan);

    /******** slow switch block computation method; computes switchblocks at each coordinate ********/
    // Iterate over all the switchblocks specified in the architecture
    for (const t_switchblock_inf& sb : switchblocks) {

        // Verify that switchblock type matches specified directionality -- currently we have to stay consistent
        if (directionality != sb.directionality) {
            VPR_FATAL_ERROR(VPR_ERROR_ARCH, "alloc_and_load_switchblock_connections: Switchblock %s does not match directionality of architecture\n", sb.name.c_str());
        }

        // Iterate over all locations in the grid, filling in all the switch blocks that exist
        for (const t_physical_tile_loc sb_loc : grid.all_locations()) {
            if (sb_not_here(grid, inter_cluster_rr, sb_loc, sb.location, sb.specified_loc)) {
                continue;
            }

            // now we iterate over all the potential side1->side2 connections
            for (e_side from_side : TOTAL_2D_SIDES) {
                for (e_side to_side : TOTAL_2D_SIDES) {
                    // Fill appropriate entry of the sb_conns map with vector specifying the wires the current wire will connect to
                    compute_wire_connections(sb_loc, from_side, to_side,
                                             chan_details_x, chan_details_y, sb,
                                             wire_type_sizes_x, wire_type_sizes_y, directionality, sb_conns,
                                             rng, &scratchpad);
                }
            }
        }
    }

    return sb_conns;
}

/* deallocates switch block connections sparse array */
void free_switchblock_permutations(t_sb_connection_map* sb_conns) {
    sb_conns->clear();
    delete sb_conns;
    sb_conns = nullptr;
    /* the switch block unordered_map can get quite large and it doesn't seem like the program
     * is interested in releasing the memory back to the OS after the map is cleared.
     * calling malloc_trim forces the program to give unused heap space back to the OS.
     * this significantly reduces memory usage during the routing stage when running multiple
     * large benchmark circuits in parallel. */
    vtr::malloc_trim(0);
}

static void get_switchpoint_wires(const t_chan_seg_details* chan_details,
                                  e_rr_type chan_type,
                                  int x,
                                  int y,
                                  e_side side,
                                  const std::vector<t_wire_switchpoints>& wire_switchpoints_vec,
                                  const t_wire_type_sizes& wire_type_sizes,
                                  bool is_dest,
                                  e_switch_point_order switchpoint_order,
                                  vtr::RngContainer& rng,
                                  std::vector<t_wire_switchpoint>* output_wires,
                                  std::vector<t_wire_switchpoint>* scratch_wires) {
    std::vector<t_wire_switchpoint>& all_collected_wire_switchpoints = *output_wires;
    all_collected_wire_switchpoints.clear();

    std::vector<t_wire_switchpoint>& collected_wire_switchpoints = *scratch_wires;

    int seg_coord = (chan_type == e_rr_type::CHANY) ? y : x;

    for (const t_wire_switchpoints& wire_switchpoints : wire_switchpoints_vec) {
        collected_wire_switchpoints.clear();

        std::string_view wire_type = wire_switchpoints.segment_name;

        if (wire_type_sizes.find(wire_type) == wire_type_sizes.end()) {
            // wire_type_sizes may not contain wire_type if its seg freq is 0
            continue;
        }

        // Get the number of wires of given type
        int num_type_wires = wire_type_sizes.at(wire_type).num_wires;
        // Get the last wire belonging to this type
        int first_type_wire = wire_type_sizes.at(wire_type).start;
        int last_type_wire = first_type_wire + num_type_wires - 1;

        // Walk through each wire segment of specified type and check whether it matches one
        // of the specified switchpoints.
        // Note that we walk through the points in order, this ensures that returned switchpoints
        // match the order specified in the architecture, which we assume is a priority order specified
        // by the architect.
        for (int valid_switchpoint : wire_switchpoints.switchpoints) {
            for (int iwire = first_type_wire; iwire <= last_type_wire; iwire++) {
                Direction seg_direction = chan_details[iwire].direction();

                // unidirectional wires going in the decreasing direction can have an outgoing edge
                // only from the top or right switch block sides, and an incoming edge only if they are
                // at the left or bottom sides (analogous for wires going in INC direction)
                if (side == TOP || side == RIGHT) {
                    if (seg_direction == Direction::DEC && is_dest) {
                        continue;
                    }
                    if (seg_direction == Direction::INC && !is_dest) {
                        continue;
                    }
                } else {
                    VTR_ASSERT(side == LEFT || side == BOTTOM);
                    if (seg_direction == Direction::DEC && !is_dest) {
                        continue;
                    }
                    if (seg_direction == Direction::INC && is_dest) {
                        continue;
                    }
                }

                int wire_switchpoint = get_switchpoint_of_wire(chan_type, chan_details[iwire], seg_coord, side);

                // Check if this wire belongs to one of the specified switchpoints; add it to our 'wires' vector if so
                if (wire_switchpoint != valid_switchpoint) continue;

                collected_wire_switchpoints.push_back({iwire, wire_switchpoint});
            }
        }

        all_collected_wire_switchpoints.insert(all_collected_wire_switchpoints.end(),
                                               collected_wire_switchpoints.begin(), collected_wire_switchpoints.end());
    }

    if (switchpoint_order == e_switch_point_order::SHUFFLED) {
        // We now re-order the switchpoints to try to make adjacent switchpoints have different values
        vtr::shuffle(all_collected_wire_switchpoints.begin(), all_collected_wire_switchpoints.end(), rng);
    } else {
        VTR_ASSERT(switchpoint_order == e_switch_point_order::FIXED);
        // Already ordered so same switchpoints are adjacent by above collection loop
    }
}

static void compute_wire_connections(const t_physical_tile_loc& sb_loc,
                                     e_side from_side,
                                     e_side to_side,
                                     const t_chan_details& chan_details_x,
                                     const t_chan_details& chan_details_y,
                                     const t_switchblock_inf& sb,
                                     const t_wire_type_sizes& wire_type_sizes_x,
                                     const t_wire_type_sizes& wire_type_sizes_y,
                                     e_directionality directionality,
                                     t_sb_connection_map* sb_conns,
                                     vtr::RngContainer& rng,
                                     t_wireconn_scratchpad* scratchpad) {
    e_rr_type from_chan_type, to_chan_type; // the type of channel - i.e. CHANX or CHANY
    t_physical_tile_loc from_loc, to_loc;

    // For indexing into this switchblock's permutation funcs
    SBSideConnection side_conn(from_side, to_side);
    // For indexing into FPGA's switchblock map
    SwitchblockLookupKey sb_conn(sb_loc, from_side, to_side);

    // Can't connect a switchblock side to itself
    if (from_side == to_side) {
        return;
    }

    // Check that the permutation map has an entry for this side combination
    if (sb.permutation_map.count(side_conn) == 0) {
        // The specified switchblock does not have any permutation funcs for `from_side` to `to_side` connection
        return;
    }

    /* find the correct channel, and the coordinates to index into it for both the source and
     * destination channels. also return the channel type (ie chanx/chany/both) into which we are
     * indexing */
    // Details for source channel
    const t_chan_details& from_chan_details = index_into_correct_chan(sb_loc, from_side, chan_details_x, chan_details_y,
                                                                      from_loc, from_chan_type);

    // Details for destination channel
    const t_chan_details& to_chan_details = index_into_correct_chan(sb_loc, to_side, chan_details_x, chan_details_y,
                                                                    to_loc, to_chan_type);

    // make sure from_loc and to_loc aren't out of bounds
    if (chan_coords_out_of_bounds(to_loc, to_chan_type) || chan_coords_out_of_bounds(from_loc, from_chan_type)) {
        return;
    }

    const t_wire_type_sizes& wire_type_sizes_from = (from_chan_type == e_rr_type::CHANY) ? wire_type_sizes_y : wire_type_sizes_x;
    const t_wire_type_sizes& wire_type_sizes_to = (to_chan_type == e_rr_type::CHANY) ? wire_type_sizes_y : wire_type_sizes_x;

    // Iterate over all the wire connections specified for this switch block
    for (int iconn = 0; iconn < (int)sb.wireconns.size(); iconn++) {
        // Pointer to a connection specification between wire types/subsegment_nums
        const t_wireconn_inf& wireconn = sb.wireconns[iconn];

        // compute the destination wire segments to which the source wire segment should connect based on the current wireconn
        compute_wireconn_connections(directionality, from_chan_details, to_chan_details,
                                     sb_conn, from_loc, to_loc, from_chan_type, to_chan_type, wire_type_sizes_from,
                                     wire_type_sizes_to, sb, wireconn, sb_conns, rng, scratchpad);
    }
}

/* computes the destination wire segments that a source wire segment at the coordinate 'sb_conn' (in
 * channel segment with coordinate from_x/from_y) should connect to based on the specified 'wireconn'.
 * wireconn defines the source and destination sets of wire segments (based on wire segment type & switchpoint
 * as defined at the top of this file), and the indices of wires to connect to are relative to these sets */
static void compute_wireconn_connections(e_directionality directionality,
                                         const t_chan_details& from_chan_details,
                                         const t_chan_details& to_chan_details,
                                         SwitchblockLookupKey sb_conn,
                                         const t_physical_tile_loc& from_loc,
                                         const t_physical_tile_loc& to_loc,
                                         e_rr_type from_chan_type,
                                         e_rr_type to_chan_type,
                                         const t_wire_type_sizes& wire_type_sizes_from,
                                         const t_wire_type_sizes& wire_type_sizes_to,
                                         const t_switchblock_inf& sb,
                                         const t_wireconn_inf& wireconn,
                                         t_sb_connection_map* sb_conns,
                                         vtr::RngContainer& rng,
                                         t_wireconn_scratchpad* scratchpad) {
    constexpr bool verbose = false;

    // vectors that will contain indices of the wires belonging to the source/dest wire types/points
    get_switchpoint_wires(from_chan_details[from_loc.x][from_loc.y].data(), from_chan_type, from_loc.x, from_loc.y, sb_conn.from_side,
                          wireconn.from_switchpoint_set, wire_type_sizes_from, /*is_dest=*/false, wireconn.from_switchpoint_order, rng,
                          &scratchpad->potential_src_wires,
                          &scratchpad->scratch_wires);

    get_switchpoint_wires(to_chan_details[to_loc.x][to_loc.y].data(), to_chan_type, to_loc.x, to_loc.y, sb_conn.to_side,
                          wireconn.to_switchpoint_set, wire_type_sizes_to, /*is_dest=*/true,
                          wireconn.to_switchpoint_order, rng, &scratchpad->potential_dest_wires,
                          &scratchpad->scratch_wires);

    const std::vector<t_wire_switchpoint>& potential_src_wires = scratchpad->potential_src_wires;
    const std::vector<t_wire_switchpoint>& potential_dest_wires = scratchpad->potential_dest_wires;

#ifdef VERBOSE_RR
    VTR_LOGV(verbose, "SB_LOC: %d,%d %s->%s\n", sb_conn.x_coord, sb_conn.y_coord, TOTAL_2D_SIDE_STRINGS[sb_conn.from_side], TOTAL_2D_SIDE_STRINGS[sb_conn.to_side]);

    //Define to print out specific wire-switchpoints used in to/from sets, if verbose is set true

    for (auto from_set : wireconn_ptr->from_switchpoint_set) {
        VTR_LOGV(verbose, "  FROM_SET: %s @", from_set.segment_name.c_str());
        for (int switchpoint : from_set.switchpoints) {
            VTR_LOGV(verbose, "%d ", switchpoint);
        }
    }
    VTR_LOGV(verbose, "\n");

    for (auto to_set : wireconn_ptr->to_switchpoint_set) {
        VTR_LOGV(verbose, "  TO_SET: %s @", to_set.segment_name.c_str());
        for (int switchpoint : to_set.switchpoints) {
            VTR_LOGV(verbose, "%d ", switchpoint);
        }
    }
    VTR_LOGV(verbose, "\n");

    vector<std::string> src_wire_str;
    for (t_wire_switchpoint wire_switchpoint : potential_src_wires) {
        src_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
    }
    vector<std::string> dst_wire_str;
    for (t_wire_switchpoint wire_switchpoint : potential_dest_wires) {
        dst_wire_str.push_back(std::to_string(wire_switchpoint.wire) + "@" + std::to_string(wire_switchpoint.switchpoint));
    }
    auto src_str = vtr::join(src_wire_str, ", ");
    auto dst_str = vtr::join(dst_wire_str, ", ");
    VTR_LOGV(verbose, "  SRC_WIRES: %s\n", src_str.c_str());
    VTR_LOGV(verbose, "  DST_WIRES: %s\n", dst_str.c_str());
#endif

    if (potential_src_wires.empty() || potential_dest_wires.empty()) {
        // Can't make any connections between empty sets
        return;
    }

    /* At this point the vectors 'potential_src_wires' and 'potential_dest_wires' contain the indices of the from_type/from_point
     * and to_type/to_point wire segments. Now we compute the connections between them, according to permutation functions */
    size_t src_W = potential_src_wires.size();
    size_t dest_W = potential_dest_wires.size();

    //TODO: We could add another user-configurable parameter to control ordering of types in the sets.
    //      Currently we just iterate through them in order, but we could:
    //      * randomly shuffle, or
    //      * interleave (to ensure good diversity)

    // Determine how many connections to make
    int num_conns = evaluate_num_conns_formula(scratchpad->formula_parser,
                                               scratchpad->formula_data,
                                               wireconn.num_conns_formula,
                                               potential_src_wires.size(),
                                               potential_dest_wires.size());
    VTR_ASSERT_MSG(num_conns >= 0, "Number of switchblock connections to create must be non-negative");

    VTR_LOGV(verbose, "  num_conns: %zu\n", num_conns);

    for (size_t iconn = 0; iconn < size_t(num_conns); ++iconn) {
        // Select the from wire
        // We modulo by the src set size to wrap around if there are more connections that src wires
        int src_wire_ind = iconn % potential_src_wires.size();  //Index in src set
        int from_wire = potential_src_wires[src_wire_ind].wire; //Index in channel

        Direction from_wire_direction = from_chan_details[from_loc.x][from_loc.y][from_wire].direction();
        if (from_wire_direction == Direction::INC) {
            // If this is a unidirectional wire headed in the increasing direction (relative to coordinate system)
            // then switch block source side should be BOTTOM or LEFT
            if (sb_conn.from_side == TOP || sb_conn.from_side == RIGHT) {
                continue;
            }
            VTR_ASSERT(sb_conn.from_side == BOTTOM || sb_conn.from_side == LEFT);
        } else if (from_wire_direction == Direction::DEC) {
            // A wire heading in the decreasing direction can only connect from the TOP or RIGHT sides of a switch block
            if (sb_conn.from_side == BOTTOM || sb_conn.from_side == LEFT) {
                continue;
            }
            VTR_ASSERT(sb_conn.from_side == TOP || sb_conn.from_side == RIGHT);
        } else {
            VTR_ASSERT(from_wire_direction == Direction::BIDIR);
        }

        // Evaluate permutation functions for the from_wire
        SBSideConnection side_conn(sb_conn.from_side, sb_conn.to_side);
        auto iter = sb.permutation_map.find(side_conn);
        if (iter == sb.permutation_map.end()) {
            continue;
        }
        const std::vector<std::string>& permutations_ref = iter->second;
        for (const std::string& perm : permutations_ref) {
            /* Convert the symbolic permutation formula to a number */
            vtr::t_formula_data& formula_data = scratchpad->formula_data;
            formula_data.clear();
            formula_data.set_var_value("W", dest_W);
            formula_data.set_var_value("t", src_wire_ind);
            int raw_dest_wire_ind = get_sb_formula_raw_result(scratchpad->formula_parser, perm.c_str(), formula_data);
            int dest_wire_ind = adjust_formula_result(raw_dest_wire_ind, src_W, dest_W, iconn);

            if (dest_wire_ind < 0) {
                VPR_FATAL_ERROR(VPR_ERROR_ARCH, "Got a negative wire from switch block formula %s", perm.c_str());
            }

            int to_wire = potential_dest_wires[dest_wire_ind].wire; //Index in channel

            // Initialize information about the target wire segment which will be added to the sb connections map
            t_switchblock_edge sb_edge;
            sb_edge.from_wire = from_wire;
            sb_edge.to_wire = to_wire;

            // if the switch override has been set, use that, Otherwise use default
            if (wireconn.switch_override_indx != DEFAULT_SWITCH) {
                sb_edge.switch_ind = wireconn.switch_override_indx;
            } else if (from_loc.layer_num == to_loc.layer_num) {
                sb_edge.switch_ind = to_chan_details[to_loc.x][to_loc.y][to_wire].arch_wire_switch();
            } else {
                VTR_ASSERT(false);
            }
            VTR_LOGV(verbose, "  make_conn: %d -> %d switch=%d\n", sb_edge.from_wire, sb_edge.to_wire, sb_edge.switch_ind);

            // and now, finally, add this switchblock connection to the switchblock connections map
            (*sb_conns)[sb_conn].push_back(sb_edge);

            // If bidir architecture, implement the reverse connection as well
            if (BI_DIRECTIONAL == directionality) {
                t_switchblock_edge sb_reverse_edge = sb_edge;
                std::swap(sb_reverse_edge.from_wire, sb_reverse_edge.to_wire);
                //Since we are implementing the reverse connection we have swapped from and to.
                //
                //Coverity flags this (false positive), so annotate coverity ignores it:
                // coverity[swapped_arguments : Intentional]
                SwitchblockLookupKey sb_conn_reverse(sb_conn.x_coord, sb_conn.y_coord, sb_conn.layer_coord, sb_conn.to_side, sb_conn.from_side);
                (*sb_conns)[sb_conn_reverse].push_back(sb_reverse_edge);
            }
        }
    }
}

/* adjusts the destination wire calculated from a permutation formula to account for negative indices,
 * source wire set offset, and modulo by destination wire set size
 * */
static int adjust_formula_result(int dest_wire, int src_W, int dest_W, int connection_ind) {
    int result = dest_wire;

    if (dest_wire < 0) {
        //Adjust for negative indices
        int mult = (-1 * dest_wire) / dest_W + 1;
        result = dest_wire + mult * dest_W;
    }

    //Offset the destination track by a multiple of src_W to ensure all destination tracks are covered
    //
    // The permutation formula produce a 1-to-1 mapping from src track to dest track (i.e. each source
    // track is mapped to precisely one destination track). This is problematic if we are processing
    // a wireconn which goes through the source set multiple times (e.g. dest set larger than src set while
    // processing a WireConnType::TO), since the permutation formula will only generate src_W track indices
    // (leaving some of the destination tracks unconnected). To ensure we get different destination tracks on
    // subsequent passes through the same source set, we offset the raw track by a multiple of src_W. Note the
    // use of integer division; src_mult will equal 0 on the first pass, 1 on the second etc.
    int src_mult = connection_ind / src_W;
    result += src_W * src_mult;

    //Final result must be modulo dest_W
    result = (result + dest_W) % dest_W;

    return result;
}
