#pragma once
/*
 * This file is generated by uxsdcxx 0.1.0.
 * https://github.com/duck2/uxsdcxx
 * Modify only if your build process doesn't involve regenerating this file.
 *
 * Cmdline: ../uxsdcxx.py rr_graph.xsd
 * md5sum of input file: f9c827f7ecf1ac2f15d57c67bbba4399
 */

#include <bitset>
#include <cassert>
#include <cstring>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#include <error.h>
#include <stddef.h>
#include <stdint.h>
#include "pugixml.hpp"
#include "rr_graph_uxsdcxx_interface.h"
/* All uxsdcxx functions and structs live in this namespace. */
namespace uxsd {
/* Declarations for internal load functions for the complex types. */
template<class T>
inline void load_channel(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_channel_required_attributes(const pugi::xml_node& root, int* chan_width_max, int* x_max, int* x_min, int* y_max, int* y_min);
template<class T>
inline void load_x_list(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_x_list_required_attributes(const pugi::xml_node& root, unsigned int* index, int* info);
template<class T>
inline void load_y_list(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_y_list_required_attributes(const pugi::xml_node& root, unsigned int* index, int* info);
template<class T>
inline void load_channels(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_timing(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_sizing(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_sizing_required_attributes(const pugi::xml_node& root, float* buf_size, float* mux_trans_size);
template<class T>
inline void load_switch(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_switch_required_attributes(const pugi::xml_node& root, int* id);
template<class T>
inline void load_switches(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_segment_timing(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_segment(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_segment_required_attributes(const pugi::xml_node& root, int* id);
template<class T>
inline void load_segments(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_pin(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_pin_required_attributes(const pugi::xml_node& root, int* ptc);
template<class T>
inline void load_pin_class(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_pin_class_required_attributes(const pugi::xml_node& root, enum_pin_type* type);
template<class T>
inline void load_block_type(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_block_type_required_attributes(const pugi::xml_node& root, int* height, int* id, int* width);
template<class T>
inline void load_block_types(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_grid_loc(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_grid_loc_required_attributes(const pugi::xml_node& root, int* block_type_id, int* height_offset, int* width_offset, int* x, int* y);
template<class T>
inline void load_grid_locs(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_node_loc(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_node_loc_required_attributes(const pugi::xml_node& root, int* ptc, int* xhigh, int* xlow, int* yhigh, int* ylow);
template<class T>
inline void load_node_timing(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_node_timing_required_attributes(const pugi::xml_node& root, float* C, float* R);
template<class T>
inline void load_node_segment(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_node_segment_required_attributes(const pugi::xml_node& root, int* segment_id);
template<class T>
inline void load_meta(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_metadata(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_node(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_node_required_attributes(const pugi::xml_node& root, unsigned int* capacity, unsigned int* id, enum_node_type* type);
template<class T>
inline void load_rr_nodes(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_edge(const pugi::xml_node& root, T& out, const void* data, void* iter);
inline void load_edge_required_attributes(const pugi::xml_node& root, unsigned int* sink_node, unsigned int* src_node, unsigned int* switch_id);
template<class T>
inline void load_rr_edges(const pugi::xml_node& root, T& out, const void* data, void* iter);
template<class T>
inline void load_rr_graph(const pugi::xml_node& root, T& out, const void* data, void* iter);

/* Declarations for internal write functions for the complex types. */
template<class T>
inline void write_channels(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_switch(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_switches(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_segment(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_segments(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_pin(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_pin_class(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_block_type(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_block_types(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_grid_locs(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_meta(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_metadata(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_node(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_rr_nodes(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_edge(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_rr_edges(T& in, std::ostream& os, const void* data, void* iter);
template<class T>
inline void write_rr_graph(T& in, std::ostream& os, const void* data, void* iter);

/* Load function for the root element. */
template<class T>
inline pugi::xml_parse_result load_rr_graph_xml(T& out, std::istream& is) {
    static_assert(std::is_base_of<RrGraphBase, T>::value, "Base class not derived from RrGraphBase");
    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load(is);
    if (!result) return result;
    for (pugi::xml_node node = doc.first_child(); node; node = node.next_sibling()) {
        if (std::strcmp(node.name(), "rr_graph") == 0) {
            /* If errno is set up to this point, it messes with strtol errno checking. */
            errno = 0;
            load_rr_graph(node, out, nullptr, nullptr);
        } else
            throw std::runtime_error("Invalid root-level element " + std::string(node.name()));
    }
    return result;
}

/* Write function for the root element. */
template<class T>
inline void write_rr_graph_xml(T& in, std::ostream& os) {
    static_assert(std::is_base_of<RrGraphBase, T>::value, "Base class not derived from RrGraphBase");
    const void* data = nullptr;
    void* iter = nullptr;
    os << "<rr_graph";
    if ((bool)in.get_rr_graph_tool_comment(data, iter))
        os << " tool_comment=\"" << in.get_rr_graph_tool_comment(data, iter) << "\"";
    if ((bool)in.get_rr_graph_tool_name(data, iter))
        os << " tool_name=\"" << in.get_rr_graph_tool_name(data, iter) << "\"";
    if ((bool)in.get_rr_graph_tool_version(data, iter))
        os << " tool_version=\"" << in.get_rr_graph_tool_version(data, iter) << "\"";
    os << ">\n";
    write_rr_graph(in, os, nullptr, nullptr);
    os << "</rr_graph>\n";
}

typedef const uint32_t __attribute__((aligned(1))) triehash_uu32;
typedef const uint64_t __attribute__((aligned(1))) triehash_uu64;
static_assert(alignof(triehash_uu32) == 1, "Unaligned 32-bit access not found.");
static_assert(alignof(triehash_uu64) == 1, "Unaligned 64-bit access not found.");
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#    define onechar(c, s, l) (((uint64_t)(c)) << (s))
#else
#    define onechar(c, s, l) (((uint64_t)(c)) << (l - 8 - s))
#endif

/* Tokens for attribute and node names. */
enum class atok_t_channel { CHAN_WIDTH_MAX,
                            X_MAX,
                            X_MIN,
                            Y_MAX,
                            Y_MIN };
constexpr const char* atok_lookup_t_channel[] = {"chan_width_max", "x_max", "x_min", "y_max", "y_min"};

enum class atok_t_x_list { INDEX,
                           INFO };
constexpr const char* atok_lookup_t_x_list[] = {"index", "info"};

enum class atok_t_y_list { INDEX,
                           INFO };
constexpr const char* atok_lookup_t_y_list[] = {"index", "info"};

enum class gtok_t_channels { CHANNEL,
                             X_LIST,
                             Y_LIST };
constexpr const char* gtok_lookup_t_channels[] = {"channel", "x_list", "y_list"};
enum class atok_t_timing { CIN,
                           CINTERNAL,
                           COUT,
                           R,
                           TDEL };
constexpr const char* atok_lookup_t_timing[] = {"Cin", "Cinternal", "Cout", "R", "Tdel"};

enum class atok_t_sizing { BUF_SIZE,
                           MUX_TRANS_SIZE };
constexpr const char* atok_lookup_t_sizing[] = {"buf_size", "mux_trans_size"};

enum class gtok_t_switch { TIMING,
                           SIZING };
constexpr const char* gtok_lookup_t_switch[] = {"timing", "sizing"};
enum class atok_t_switch { ID,
                           NAME,
                           TYPE };
constexpr const char* atok_lookup_t_switch[] = {"id", "name", "type"};

enum class gtok_t_switches { SWITCH };
constexpr const char* gtok_lookup_t_switches[] = {"switch"};
enum class atok_t_segment_timing { C_PER_METER,
                                   R_PER_METER };
constexpr const char* atok_lookup_t_segment_timing[] = {"C_per_meter", "R_per_meter"};

enum class gtok_t_segment { TIMING };
constexpr const char* gtok_lookup_t_segment[] = {"timing"};
enum class atok_t_segment { ID,
                            NAME };
constexpr const char* atok_lookup_t_segment[] = {"id", "name"};

enum class gtok_t_segments { SEGMENT };
constexpr const char* gtok_lookup_t_segments[] = {"segment"};
enum class atok_t_pin { PTC };
constexpr const char* atok_lookup_t_pin[] = {"ptc"};

enum class gtok_t_pin_class { PIN };
constexpr const char* gtok_lookup_t_pin_class[] = {"pin"};
enum class atok_t_pin_class { TYPE };
constexpr const char* atok_lookup_t_pin_class[] = {"type"};

enum class gtok_t_block_type { PIN_CLASS };
constexpr const char* gtok_lookup_t_block_type[] = {"pin_class"};
enum class atok_t_block_type { HEIGHT,
                               ID,
                               NAME,
                               WIDTH };
constexpr const char* atok_lookup_t_block_type[] = {"height", "id", "name", "width"};

enum class gtok_t_block_types { BLOCK_TYPE };
constexpr const char* gtok_lookup_t_block_types[] = {"block_type"};
enum class atok_t_grid_loc { BLOCK_TYPE_ID,
                             HEIGHT_OFFSET,
                             WIDTH_OFFSET,
                             X,
                             Y };
constexpr const char* atok_lookup_t_grid_loc[] = {"block_type_id", "height_offset", "width_offset", "x", "y"};

enum class gtok_t_grid_locs { GRID_LOC };
constexpr const char* gtok_lookup_t_grid_locs[] = {"grid_loc"};
enum class atok_t_node_loc { PTC,
                             SIDE,
                             XHIGH,
                             XLOW,
                             YHIGH,
                             YLOW };
constexpr const char* atok_lookup_t_node_loc[] = {"ptc", "side", "xhigh", "xlow", "yhigh", "ylow"};

enum class atok_t_node_timing { C,
                                R };
constexpr const char* atok_lookup_t_node_timing[] = {"C", "R"};

enum class atok_t_node_segment { SEGMENT_ID };
constexpr const char* atok_lookup_t_node_segment[] = {"segment_id"};

enum class atok_t_meta { NAME };
constexpr const char* atok_lookup_t_meta[] = {"name"};

enum class gtok_t_metadata { META };
constexpr const char* gtok_lookup_t_metadata[] = {"meta"};
enum class gtok_t_node { LOC,
                         TIMING,
                         SEGMENT,
                         METADATA };
constexpr const char* gtok_lookup_t_node[] = {"loc", "timing", "segment", "metadata"};
enum class atok_t_node { CAPACITY,
                         DIRECTION,
                         ID,
                         TYPE };
constexpr const char* atok_lookup_t_node[] = {"capacity", "direction", "id", "type"};

enum class gtok_t_rr_nodes { NODE };
constexpr const char* gtok_lookup_t_rr_nodes[] = {"node"};
enum class gtok_t_edge { METADATA };
constexpr const char* gtok_lookup_t_edge[] = {"metadata"};
enum class atok_t_edge { SINK_NODE,
                         SRC_NODE,
                         SWITCH_ID };
constexpr const char* atok_lookup_t_edge[] = {"sink_node", "src_node", "switch_id"};

enum class gtok_t_rr_edges { EDGE };
constexpr const char* gtok_lookup_t_rr_edges[] = {"edge"};
enum class gtok_t_rr_graph { CHANNELS,
                             SWITCHES,
                             SEGMENTS,
                             BLOCK_TYPES,
                             GRID,
                             RR_NODES,
                             RR_EDGES };
constexpr const char* gtok_lookup_t_rr_graph[] = {"channels", "switches", "segments", "block_types", "grid", "rr_nodes", "rr_edges"};
enum class atok_t_rr_graph { TOOL_COMMENT,
                             TOOL_NAME,
                             TOOL_VERSION };
constexpr const char* atok_lookup_t_rr_graph[] = {"tool_comment", "tool_name", "tool_version"};

/* Internal lexers. These convert the PugiXML node names to input tokens. */
inline atok_t_channel lex_attr_t_channel(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('a', 24, 32):
                    switch (in[4]) {
                        case onechar('x', 0, 8):
                            return atok_t_channel::X_MAX;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            return atok_t_channel::X_MIN;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('a', 24, 32):
                    switch (in[4]) {
                        case onechar('x', 0, 8):
                            return atok_t_channel::Y_MAX;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            return atok_t_channel::Y_MIN;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 14:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('c', 0, 64) | onechar('h', 8, 64) | onechar('a', 16, 64) | onechar('n', 24, 64) | onechar('_', 32, 64) | onechar('w', 40, 64) | onechar('i', 48, 64) | onechar('d', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('t', 0, 32) | onechar('h', 8, 32) | onechar('_', 16, 32) | onechar('m', 24, 32):
                            switch (in[12]) {
                                case onechar('a', 0, 8):
                                    switch (in[13]) {
                                        case onechar('x', 0, 8):
                                            return atok_t_channel::CHAN_WIDTH_MAX;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <channel>.");
}

inline atok_t_x_list lex_attr_t_x_list(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('f', 16, 32) | onechar('o', 24, 32):
                    return atok_t_x_list::INFO;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
                    switch (in[4]) {
                        case onechar('x', 0, 8):
                            return atok_t_x_list::INDEX;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <x_list>.");
}

inline atok_t_y_list lex_attr_t_y_list(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('f', 16, 32) | onechar('o', 24, 32):
                    return atok_t_y_list::INFO;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('i', 0, 32) | onechar('n', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
                    switch (in[4]) {
                        case onechar('x', 0, 8):
                            return atok_t_y_list::INDEX;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <y_list>.");
}

inline gtok_t_channels lex_node_t_channels(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('x', 0, 32) | onechar('_', 8, 32) | onechar('l', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('s', 0, 8):
                            switch (in[5]) {
                                case onechar('t', 0, 8):
                                    return gtok_t_channels::X_LIST;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('y', 0, 32) | onechar('_', 8, 32) | onechar('l', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('s', 0, 8):
                            switch (in[5]) {
                                case onechar('t', 0, 8):
                                    return gtok_t_channels::Y_LIST;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 7:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('c', 0, 32) | onechar('h', 8, 32) | onechar('a', 16, 32) | onechar('n', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            switch (in[5]) {
                                case onechar('e', 0, 8):
                                    switch (in[6]) {
                                        case onechar('l', 0, 8):
                                            return gtok_t_channels::CHANNEL;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <channels>.");
}

inline atok_t_timing lex_attr_t_timing(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 1:
            switch (in[0]) {
                case onechar('R', 0, 8):
                    return atok_t_timing::R;
                    break;
                default:
                    break;
            }
            break;
        case 3:
            switch (in[0]) {
                case onechar('C', 0, 8):
                    switch (in[1]) {
                        case onechar('i', 0, 8):
                            switch (in[2]) {
                                case onechar('n', 0, 8):
                                    return atok_t_timing::CIN;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('C', 0, 32) | onechar('o', 8, 32) | onechar('u', 16, 32) | onechar('t', 24, 32):
                    return atok_t_timing::COUT;
                    break;
                case onechar('T', 0, 32) | onechar('d', 8, 32) | onechar('e', 16, 32) | onechar('l', 24, 32):
                    return atok_t_timing::TDEL;
                    break;
                default:
                    break;
            }
            break;
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('C', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('t', 24, 64) | onechar('e', 32, 64) | onechar('r', 40, 64) | onechar('n', 48, 64) | onechar('a', 56, 64):
                    switch (in[8]) {
                        case onechar('l', 0, 8):
                            return atok_t_timing::CINTERNAL;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <timing>.");
}

inline atok_t_sizing lex_attr_t_sizing(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('b', 0, 64) | onechar('u', 8, 64) | onechar('f', 16, 64) | onechar('_', 24, 64) | onechar('s', 32, 64) | onechar('i', 40, 64) | onechar('z', 48, 64) | onechar('e', 56, 64):
                    return atok_t_sizing::BUF_SIZE;
                    break;
                default:
                    break;
            }
            break;
        case 14:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('m', 0, 64) | onechar('u', 8, 64) | onechar('x', 16, 64) | onechar('_', 24, 64) | onechar('t', 32, 64) | onechar('r', 40, 64) | onechar('a', 48, 64) | onechar('n', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('s', 0, 32) | onechar('_', 8, 32) | onechar('s', 16, 32) | onechar('i', 24, 32):
                            switch (in[12]) {
                                case onechar('z', 0, 8):
                                    switch (in[13]) {
                                        case onechar('e', 0, 8):
                                            return atok_t_sizing::MUX_TRANS_SIZE;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <sizing>.");
}

inline gtok_t_switch lex_node_t_switch(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('z', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            switch (in[5]) {
                                case onechar('g', 0, 8):
                                    return gtok_t_switch::SIZING;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            switch (in[5]) {
                                case onechar('g', 0, 8):
                                    return gtok_t_switch::TIMING;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <switch>.");
}
inline atok_t_switch lex_attr_t_switch(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 2:
            switch (in[0]) {
                case onechar('i', 0, 8):
                    switch (in[1]) {
                        case onechar('d', 0, 8):
                            return atok_t_switch::ID;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
                    return atok_t_switch::NAME;
                    break;
                case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
                    return atok_t_switch::TYPE;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <switch>.");
}

inline gtok_t_switches lex_node_t_switches(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('w', 8, 32) | onechar('i', 16, 32) | onechar('t', 24, 32):
                    switch (in[4]) {
                        case onechar('c', 0, 8):
                            switch (in[5]) {
                                case onechar('h', 0, 8):
                                    return gtok_t_switches::SWITCH;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <switches>.");
}

inline atok_t_segment_timing lex_attr_t_segment_timing(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 11:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('C', 0, 64) | onechar('_', 8, 64) | onechar('p', 16, 64) | onechar('e', 24, 64) | onechar('r', 32, 64) | onechar('_', 40, 64) | onechar('m', 48, 64) | onechar('e', 56, 64):
                    switch (in[8]) {
                        case onechar('t', 0, 8):
                            switch (in[9]) {
                                case onechar('e', 0, 8):
                                    switch (in[10]) {
                                        case onechar('r', 0, 8):
                                            return atok_t_segment_timing::C_PER_METER;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('R', 0, 64) | onechar('_', 8, 64) | onechar('p', 16, 64) | onechar('e', 24, 64) | onechar('r', 32, 64) | onechar('_', 40, 64) | onechar('m', 48, 64) | onechar('e', 56, 64):
                    switch (in[8]) {
                        case onechar('t', 0, 8):
                            switch (in[9]) {
                                case onechar('e', 0, 8):
                                    switch (in[10]) {
                                        case onechar('r', 0, 8):
                                            return atok_t_segment_timing::R_PER_METER;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <segment_timing>.");
}

inline gtok_t_segment lex_node_t_segment(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            switch (in[5]) {
                                case onechar('g', 0, 8):
                                    return gtok_t_segment::TIMING;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <segment>.");
}
inline atok_t_segment lex_attr_t_segment(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 2:
            switch (in[0]) {
                case onechar('i', 0, 8):
                    switch (in[1]) {
                        case onechar('d', 0, 8):
                            return atok_t_segment::ID;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
                    return atok_t_segment::NAME;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <segment>.");
}

inline gtok_t_segments lex_node_t_segments(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 7:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('e', 8, 32) | onechar('g', 16, 32) | onechar('m', 24, 32):
                    switch (in[4]) {
                        case onechar('e', 0, 8):
                            switch (in[5]) {
                                case onechar('n', 0, 8):
                                    switch (in[6]) {
                                        case onechar('t', 0, 8):
                                            return gtok_t_segments::SEGMENT;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <segments>.");
}

inline atok_t_pin lex_attr_t_pin(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('p', 0, 8):
                    switch (in[1]) {
                        case onechar('t', 0, 8):
                            switch (in[2]) {
                                case onechar('c', 0, 8):
                                    return atok_t_pin::PTC;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <pin>.");
}

inline gtok_t_pin_class lex_node_t_pin_class(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('p', 0, 8):
                    switch (in[1]) {
                        case onechar('i', 0, 8):
                            switch (in[2]) {
                                case onechar('n', 0, 8):
                                    return gtok_t_pin_class::PIN;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <pin_class>.");
}
inline atok_t_pin_class lex_attr_t_pin_class(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
                    return atok_t_pin_class::TYPE;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <pin_class>.");
}

inline gtok_t_block_type lex_node_t_block_type(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('p', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('_', 24, 64) | onechar('c', 32, 64) | onechar('l', 40, 64) | onechar('a', 48, 64) | onechar('s', 56, 64):
                    switch (in[8]) {
                        case onechar('s', 0, 8):
                            return gtok_t_block_type::PIN_CLASS;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <block_type>.");
}
inline atok_t_block_type lex_attr_t_block_type(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 2:
            switch (in[0]) {
                case onechar('i', 0, 8):
                    switch (in[1]) {
                        case onechar('d', 0, 8):
                            return atok_t_block_type::ID;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
                    return atok_t_block_type::NAME;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('w', 0, 32) | onechar('i', 8, 32) | onechar('d', 16, 32) | onechar('t', 24, 32):
                    switch (in[4]) {
                        case onechar('h', 0, 8):
                            return atok_t_block_type::WIDTH;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('h', 0, 32) | onechar('e', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
                    switch (in[4]) {
                        case onechar('h', 0, 8):
                            switch (in[5]) {
                                case onechar('t', 0, 8):
                                    return atok_t_block_type::HEIGHT;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <block_type>.");
}

inline gtok_t_block_types lex_node_t_block_types(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 10:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
                    switch (in[8]) {
                        case onechar('p', 0, 8):
                            switch (in[9]) {
                                case onechar('e', 0, 8):
                                    return gtok_t_block_types::BLOCK_TYPE;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <block_types>.");
}

inline atok_t_grid_loc lex_attr_t_grid_loc(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 1:
            switch (in[0]) {
                case onechar('x', 0, 8):
                    return atok_t_grid_loc::X;
                    break;
                case onechar('y', 0, 8):
                    return atok_t_grid_loc::Y;
                    break;
                default:
                    break;
            }
            break;
        case 12:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('w', 0, 64) | onechar('i', 8, 64) | onechar('d', 16, 64) | onechar('t', 24, 64) | onechar('h', 32, 64) | onechar('_', 40, 64) | onechar('o', 48, 64) | onechar('f', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('f', 0, 32) | onechar('s', 8, 32) | onechar('e', 16, 32) | onechar('t', 24, 32):
                            return atok_t_grid_loc::WIDTH_OFFSET;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 13:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('p', 0, 32) | onechar('e', 8, 32) | onechar('_', 16, 32) | onechar('i', 24, 32):
                            switch (in[12]) {
                                case onechar('d', 0, 8):
                                    return atok_t_grid_loc::BLOCK_TYPE_ID;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('h', 0, 64) | onechar('e', 8, 64) | onechar('i', 16, 64) | onechar('g', 24, 64) | onechar('h', 32, 64) | onechar('t', 40, 64) | onechar('_', 48, 64) | onechar('o', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('f', 0, 32) | onechar('f', 8, 32) | onechar('s', 16, 32) | onechar('e', 24, 32):
                            switch (in[12]) {
                                case onechar('t', 0, 8):
                                    return atok_t_grid_loc::HEIGHT_OFFSET;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <grid_loc>.");
}

inline gtok_t_grid_locs lex_node_t_grid_locs(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('g', 0, 64) | onechar('r', 8, 64) | onechar('i', 16, 64) | onechar('d', 24, 64) | onechar('_', 32, 64) | onechar('l', 40, 64) | onechar('o', 48, 64) | onechar('c', 56, 64):
                    return gtok_t_grid_locs::GRID_LOC;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <grid_locs>.");
}

inline atok_t_node_loc lex_attr_t_node_loc(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('p', 0, 8):
                    switch (in[1]) {
                        case onechar('t', 0, 8):
                            switch (in[2]) {
                                case onechar('c', 0, 8):
                                    return atok_t_node_loc::PTC;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
                    return atok_t_node_loc::SIDE;
                    break;
                case onechar('x', 0, 32) | onechar('l', 8, 32) | onechar('o', 16, 32) | onechar('w', 24, 32):
                    return atok_t_node_loc::XLOW;
                    break;
                case onechar('y', 0, 32) | onechar('l', 8, 32) | onechar('o', 16, 32) | onechar('w', 24, 32):
                    return atok_t_node_loc::YLOW;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('x', 0, 32) | onechar('h', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
                    switch (in[4]) {
                        case onechar('h', 0, 8):
                            return atok_t_node_loc::XHIGH;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('y', 0, 32) | onechar('h', 8, 32) | onechar('i', 16, 32) | onechar('g', 24, 32):
                    switch (in[4]) {
                        case onechar('h', 0, 8):
                            return atok_t_node_loc::YHIGH;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_loc>.");
}

inline atok_t_node_timing lex_attr_t_node_timing(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 1:
            switch (in[0]) {
                case onechar('C', 0, 8):
                    return atok_t_node_timing::C;
                    break;
                case onechar('R', 0, 8):
                    return atok_t_node_timing::R;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_timing>.");
}

inline atok_t_node_segment lex_attr_t_node_segment(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 10:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('s', 0, 64) | onechar('e', 8, 64) | onechar('g', 16, 64) | onechar('m', 24, 64) | onechar('e', 32, 64) | onechar('n', 40, 64) | onechar('t', 48, 64) | onechar('_', 56, 64):
                    switch (in[8]) {
                        case onechar('i', 0, 8):
                            switch (in[9]) {
                                case onechar('d', 0, 8):
                                    return atok_t_node_segment::SEGMENT_ID;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node_segment>.");
}

inline atok_t_meta lex_attr_t_meta(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('n', 0, 32) | onechar('a', 8, 32) | onechar('m', 16, 32) | onechar('e', 24, 32):
                    return atok_t_meta::NAME;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <meta>.");
}

inline gtok_t_metadata lex_node_t_metadata(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('m', 0, 32) | onechar('e', 8, 32) | onechar('t', 16, 32) | onechar('a', 24, 32):
                    return gtok_t_metadata::META;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <metadata>.");
}

inline gtok_t_node lex_node_t_node(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('l', 0, 8):
                    switch (in[1]) {
                        case onechar('o', 0, 8):
                            switch (in[2]) {
                                case onechar('c', 0, 8):
                                    return gtok_t_node::LOC;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('t', 0, 32) | onechar('i', 8, 32) | onechar('m', 16, 32) | onechar('i', 24, 32):
                    switch (in[4]) {
                        case onechar('n', 0, 8):
                            switch (in[5]) {
                                case onechar('g', 0, 8):
                                    return gtok_t_node::TIMING;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 7:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('e', 8, 32) | onechar('g', 16, 32) | onechar('m', 24, 32):
                    switch (in[4]) {
                        case onechar('e', 0, 8):
                            switch (in[5]) {
                                case onechar('n', 0, 8):
                                    switch (in[6]) {
                                        case onechar('t', 0, 8):
                                            return gtok_t_node::SEGMENT;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('m', 0, 64) | onechar('e', 8, 64) | onechar('t', 16, 64) | onechar('a', 24, 64) | onechar('d', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('a', 56, 64):
                    return gtok_t_node::METADATA;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <node>.");
}
inline atok_t_node lex_attr_t_node(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 2:
            switch (in[0]) {
                case onechar('i', 0, 8):
                    switch (in[1]) {
                        case onechar('d', 0, 8):
                            return atok_t_node::ID;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('t', 0, 32) | onechar('y', 8, 32) | onechar('p', 16, 32) | onechar('e', 24, 32):
                    return atok_t_node::TYPE;
                    break;
                default:
                    break;
            }
            break;
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('c', 0, 64) | onechar('a', 8, 64) | onechar('p', 16, 64) | onechar('a', 24, 64) | onechar('c', 32, 64) | onechar('i', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
                    return atok_t_node::CAPACITY;
                    break;
                default:
                    break;
            }
            break;
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('d', 0, 64) | onechar('i', 8, 64) | onechar('r', 16, 64) | onechar('e', 24, 64) | onechar('c', 32, 64) | onechar('t', 40, 64) | onechar('i', 48, 64) | onechar('o', 56, 64):
                    switch (in[8]) {
                        case onechar('n', 0, 8):
                            return atok_t_node::DIRECTION;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <node>.");
}

inline gtok_t_rr_nodes lex_node_t_rr_nodes(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('n', 0, 32) | onechar('o', 8, 32) | onechar('d', 16, 32) | onechar('e', 24, 32):
                    return gtok_t_rr_nodes::NODE;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_nodes>.");
}

inline gtok_t_edge lex_node_t_edge(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('m', 0, 64) | onechar('e', 8, 64) | onechar('t', 16, 64) | onechar('a', 24, 64) | onechar('d', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('a', 56, 64):
                    return gtok_t_edge::METADATA;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <edge>.");
}
inline atok_t_edge lex_attr_t_edge(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('s', 0, 64) | onechar('r', 8, 64) | onechar('c', 16, 64) | onechar('_', 24, 64) | onechar('n', 32, 64) | onechar('o', 40, 64) | onechar('d', 48, 64) | onechar('e', 56, 64):
                    return atok_t_edge::SRC_NODE;
                    break;
                default:
                    break;
            }
            break;
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('s', 0, 64) | onechar('i', 8, 64) | onechar('n', 16, 64) | onechar('k', 24, 64) | onechar('_', 32, 64) | onechar('n', 40, 64) | onechar('o', 48, 64) | onechar('d', 56, 64):
                    switch (in[8]) {
                        case onechar('e', 0, 8):
                            return atok_t_edge::SINK_NODE;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('s', 0, 64) | onechar('w', 8, 64) | onechar('i', 16, 64) | onechar('t', 24, 64) | onechar('c', 32, 64) | onechar('h', 40, 64) | onechar('_', 48, 64) | onechar('i', 56, 64):
                    switch (in[8]) {
                        case onechar('d', 0, 8):
                            return atok_t_edge::SWITCH_ID;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <edge>.");
}

inline gtok_t_rr_edges lex_node_t_rr_edges(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('e', 0, 32) | onechar('d', 8, 32) | onechar('g', 16, 32) | onechar('e', 24, 32):
                    return gtok_t_rr_edges::EDGE;
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_edges>.");
}

inline gtok_t_rr_graph lex_node_t_rr_graph(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('g', 0, 32) | onechar('r', 8, 32) | onechar('i', 16, 32) | onechar('d', 24, 32):
                    return gtok_t_rr_graph::GRID;
                    break;
                default:
                    break;
            }
            break;
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('c', 0, 64) | onechar('h', 8, 64) | onechar('a', 16, 64) | onechar('n', 24, 64) | onechar('n', 32, 64) | onechar('e', 40, 64) | onechar('l', 48, 64) | onechar('s', 56, 64):
                    return gtok_t_rr_graph::CHANNELS;
                    break;
                case onechar('r', 0, 64) | onechar('r', 8, 64) | onechar('_', 16, 64) | onechar('e', 24, 64) | onechar('d', 32, 64) | onechar('g', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
                    return gtok_t_rr_graph::RR_EDGES;
                    break;
                case onechar('r', 0, 64) | onechar('r', 8, 64) | onechar('_', 16, 64) | onechar('n', 24, 64) | onechar('o', 32, 64) | onechar('d', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
                    return gtok_t_rr_graph::RR_NODES;
                    break;
                case onechar('s', 0, 64) | onechar('e', 8, 64) | onechar('g', 16, 64) | onechar('m', 24, 64) | onechar('e', 32, 64) | onechar('n', 40, 64) | onechar('t', 48, 64) | onechar('s', 56, 64):
                    return gtok_t_rr_graph::SEGMENTS;
                    break;
                case onechar('s', 0, 64) | onechar('w', 8, 64) | onechar('i', 16, 64) | onechar('t', 24, 64) | onechar('c', 32, 64) | onechar('h', 40, 64) | onechar('e', 48, 64) | onechar('s', 56, 64):
                    return gtok_t_rr_graph::SWITCHES;
                    break;
                default:
                    break;
            }
            break;
        case 11:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('b', 0, 64) | onechar('l', 8, 64) | onechar('o', 16, 64) | onechar('c', 24, 64) | onechar('k', 32, 64) | onechar('_', 40, 64) | onechar('t', 48, 64) | onechar('y', 56, 64):
                    switch (in[8]) {
                        case onechar('p', 0, 8):
                            switch (in[9]) {
                                case onechar('e', 0, 8):
                                    switch (in[10]) {
                                        case onechar('s', 0, 8):
                                            return gtok_t_rr_graph::BLOCK_TYPES;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized child " + std::string(in) + " of <rr_graph>.");
}
inline atok_t_rr_graph lex_attr_t_rr_graph(const char* in) {
    unsigned int len = strlen(in);
    switch (len) {
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('n', 40, 64) | onechar('a', 48, 64) | onechar('m', 56, 64):
                    switch (in[8]) {
                        case onechar('e', 0, 8):
                            return atok_t_rr_graph::TOOL_NAME;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 12:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('c', 40, 64) | onechar('o', 48, 64) | onechar('m', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('m', 0, 32) | onechar('e', 8, 32) | onechar('n', 16, 32) | onechar('t', 24, 32):
                            return atok_t_rr_graph::TOOL_COMMENT;
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('t', 0, 64) | onechar('o', 8, 64) | onechar('o', 16, 64) | onechar('l', 24, 64) | onechar('_', 32, 64) | onechar('v', 40, 64) | onechar('e', 48, 64) | onechar('r', 56, 64):
                    switch (*((triehash_uu32*)&in[8])) {
                        case onechar('s', 0, 32) | onechar('i', 8, 32) | onechar('o', 16, 32) | onechar('n', 24, 32):
                            return atok_t_rr_graph::TOOL_VERSION;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw std::runtime_error("Found unrecognized attribute " + std::string(in) + " of <rr_graph>.");
}

/**
 * Internal error function for xs:choice and xs:sequence validators.
 */
inline void dfa_error(const char* wrong, const int* states, const char* const* lookup, int len);

/**
 * Internal error function for xs:all validators.
 */
template<std::size_t N>
inline void all_error(std::bitset<N> gstate, const char* const* lookup);

/**
 * Internal error function for attribute validators.
 */
template<std::size_t N>
inline void attr_error(std::bitset<N> astate, const char* const* lookup);

/* Lookup tables for enums. */
constexpr const char* lookup_switch_type[] = {"UXSD_INVALID", "mux", "tristate", "pass_gate", "short", "buffer"};
constexpr const char* lookup_pin_type[] = {"UXSD_INVALID", "OPEN", "OUTPUT", "INPUT"};
constexpr const char* lookup_node_type[] = {"UXSD_INVALID", "CHANX", "CHANY", "SOURCE", "SINK", "OPIN", "IPIN"};
constexpr const char* lookup_node_direction[] = {"UXSD_INVALID", "INC_DIR", "DEC_DIR", "BI_DIR"};
constexpr const char* lookup_loc_side[] = {"UXSD_INVALID", "LEFT", "RIGHT", "TOP", "BOTTOM"};

/* Lexers(string->token functions) for enums. */
inline enum_switch_type lex_enum_switch_type(const char* in, bool throw_on_invalid) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('m', 0, 8):
                    switch (in[1]) {
                        case onechar('u', 0, 8):
                            switch (in[2]) {
                                case onechar('x', 0, 8):
                                    return enum_switch_type::MUX;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('s', 0, 32) | onechar('h', 8, 32) | onechar('o', 16, 32) | onechar('r', 24, 32):
                    switch (in[4]) {
                        case onechar('t', 0, 8):
                            return enum_switch_type::SHORT;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('b', 0, 32) | onechar('u', 8, 32) | onechar('f', 16, 32) | onechar('f', 24, 32):
                    switch (in[4]) {
                        case onechar('e', 0, 8):
                            switch (in[5]) {
                                case onechar('r', 0, 8):
                                    return enum_switch_type::BUFFER;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 8:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('t', 0, 64) | onechar('r', 8, 64) | onechar('i', 16, 64) | onechar('s', 24, 64) | onechar('t', 32, 64) | onechar('a', 40, 64) | onechar('t', 48, 64) | onechar('e', 56, 64):
                    return enum_switch_type::TRISTATE;
                    break;
                default:
                    break;
            }
            break;
        case 9:
            switch (*((triehash_uu64*)&in[0])) {
                case onechar('p', 0, 64) | onechar('a', 8, 64) | onechar('s', 16, 64) | onechar('s', 24, 64) | onechar('_', 32, 64) | onechar('g', 40, 64) | onechar('a', 48, 64) | onechar('t', 56, 64):
                    switch (in[8]) {
                        case onechar('e', 0, 8):
                            return enum_switch_type::PASS_GATE;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    if (throw_on_invalid)
        throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_switch_type.");
    return enum_switch_type::UXSD_INVALID;
}

inline enum_pin_type lex_enum_pin_type(const char* in, bool throw_on_invalid) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('O', 0, 32) | onechar('P', 8, 32) | onechar('E', 16, 32) | onechar('N', 24, 32):
                    return enum_pin_type::OPEN;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('I', 0, 32) | onechar('N', 8, 32) | onechar('P', 16, 32) | onechar('U', 24, 32):
                    switch (in[4]) {
                        case onechar('T', 0, 8):
                            return enum_pin_type::INPUT;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('O', 0, 32) | onechar('U', 8, 32) | onechar('T', 16, 32) | onechar('P', 24, 32):
                    switch (in[4]) {
                        case onechar('U', 0, 8):
                            switch (in[5]) {
                                case onechar('T', 0, 8):
                                    return enum_pin_type::OUTPUT;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    if (throw_on_invalid)
        throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_pin_type.");
    return enum_pin_type::UXSD_INVALID;
}

inline enum_node_type lex_enum_node_type(const char* in, bool throw_on_invalid) {
    unsigned int len = strlen(in);
    switch (len) {
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('I', 0, 32) | onechar('P', 8, 32) | onechar('I', 16, 32) | onechar('N', 24, 32):
                    return enum_node_type::IPIN;
                    break;
                case onechar('O', 0, 32) | onechar('P', 8, 32) | onechar('I', 16, 32) | onechar('N', 24, 32):
                    return enum_node_type::OPIN;
                    break;
                case onechar('S', 0, 32) | onechar('I', 8, 32) | onechar('N', 16, 32) | onechar('K', 24, 32):
                    return enum_node_type::SINK;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('C', 0, 32) | onechar('H', 8, 32) | onechar('A', 16, 32) | onechar('N', 24, 32):
                    switch (in[4]) {
                        case onechar('X', 0, 8):
                            return enum_node_type::CHANX;
                            break;
                        case onechar('Y', 0, 8):
                            return enum_node_type::CHANY;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('S', 0, 32) | onechar('O', 8, 32) | onechar('U', 16, 32) | onechar('R', 24, 32):
                    switch (in[4]) {
                        case onechar('C', 0, 8):
                            switch (in[5]) {
                                case onechar('E', 0, 8):
                                    return enum_node_type::SOURCE;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    if (throw_on_invalid)
        throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_node_type.");
    return enum_node_type::UXSD_INVALID;
}

inline enum_node_direction lex_enum_node_direction(const char* in, bool throw_on_invalid) {
    unsigned int len = strlen(in);
    switch (len) {
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('B', 0, 32) | onechar('I', 8, 32) | onechar('_', 16, 32) | onechar('D', 24, 32):
                    switch (in[4]) {
                        case onechar('I', 0, 8):
                            switch (in[5]) {
                                case onechar('R', 0, 8):
                                    return enum_node_direction::BI_DIR;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 7:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('D', 0, 32) | onechar('E', 8, 32) | onechar('C', 16, 32) | onechar('_', 24, 32):
                    switch (in[4]) {
                        case onechar('D', 0, 8):
                            switch (in[5]) {
                                case onechar('I', 0, 8):
                                    switch (in[6]) {
                                        case onechar('R', 0, 8):
                                            return enum_node_direction::DEC_DIR;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                case onechar('I', 0, 32) | onechar('N', 8, 32) | onechar('C', 16, 32) | onechar('_', 24, 32):
                    switch (in[4]) {
                        case onechar('D', 0, 8):
                            switch (in[5]) {
                                case onechar('I', 0, 8):
                                    switch (in[6]) {
                                        case onechar('R', 0, 8):
                                            return enum_node_direction::INC_DIR;
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    if (throw_on_invalid)
        throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_node_direction.");
    return enum_node_direction::UXSD_INVALID;
}

inline enum_loc_side lex_enum_loc_side(const char* in, bool throw_on_invalid) {
    unsigned int len = strlen(in);
    switch (len) {
        case 3:
            switch (in[0]) {
                case onechar('T', 0, 8):
                    switch (in[1]) {
                        case onechar('O', 0, 8):
                            switch (in[2]) {
                                case onechar('P', 0, 8):
                                    return enum_loc_side::TOP;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 4:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('L', 0, 32) | onechar('E', 8, 32) | onechar('F', 16, 32) | onechar('T', 24, 32):
                    return enum_loc_side::LEFT;
                    break;
                default:
                    break;
            }
            break;
        case 5:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('R', 0, 32) | onechar('I', 8, 32) | onechar('G', 16, 32) | onechar('H', 24, 32):
                    switch (in[4]) {
                        case onechar('T', 0, 8):
                            return enum_loc_side::RIGHT;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        case 6:
            switch (*((triehash_uu32*)&in[0])) {
                case onechar('B', 0, 32) | onechar('O', 8, 32) | onechar('T', 16, 32) | onechar('T', 24, 32):
                    switch (in[4]) {
                        case onechar('O', 0, 8):
                            switch (in[5]) {
                                case onechar('M', 0, 8):
                                    return enum_loc_side::BOTTOM;
                                    break;
                                default:
                                    break;
                            }
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
    }
    if (throw_on_invalid)
        throw std::runtime_error("Found unrecognized enum value " + std::string(in) + " of enum_loc_side.");
    return enum_loc_side::UXSD_INVALID;
}

/* Internal loading functions, which validate and load a PugiXML DOM tree into memory. */
inline int load_int(const char* in) {
    int out;
    out = std::strtol(in, NULL, 10);
    if (errno != 0)
        throw std::runtime_error("Invalid value `" + std::string(in) + "` when loading into a int.");
    return out;
}

inline unsigned int load_unsigned_int(const char* in) {
    unsigned int out;
    out = std::strtoul(in, NULL, 10);
    if (errno != 0)
        throw std::runtime_error("Invalid value `" + std::string(in) + "` when loading into a unsigned int.");
    return out;
}

inline float load_float(const char* in) {
    float out;
    out = std::strtof(in, NULL);
    if (errno != 0)
        throw std::runtime_error("Invalid value `" + std::string(in) + "` when loading into a float.");
    return out;
}
inline void load_channel_required_attributes(const pugi::xml_node& root, int* chan_width_max, int* x_max, int* x_min, int* y_max, int* y_min) {
    std::bitset<5> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_channel in = lex_attr_t_channel(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <channel>.");
        switch (in) {
            case atok_t_channel::CHAN_WIDTH_MAX:
                *chan_width_max = load_int(attr.value());
                break;
            case atok_t_channel::X_MAX:
                *x_max = load_int(attr.value());
                break;
            case atok_t_channel::X_MIN:
                *x_min = load_int(attr.value());
                break;
            case atok_t_channel::Y_MAX:
                *y_max = load_int(attr.value());
                break;
            case atok_t_channel::Y_MIN:
                *y_min = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<5> test_astate = astate | std::bitset<5>(0b00000);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_channel);
}

inline void load_x_list_required_attributes(const pugi::xml_node& root, unsigned int* index, int* info) {
    std::bitset<2> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_x_list in = lex_attr_t_x_list(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <x_list>.");
        switch (in) {
            case atok_t_x_list::INDEX:
                *index = load_unsigned_int(attr.value());
                break;
            case atok_t_x_list::INFO:
                *info = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_x_list);
}

inline void load_y_list_required_attributes(const pugi::xml_node& root, unsigned int* index, int* info) {
    std::bitset<2> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_y_list in = lex_attr_t_y_list(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <y_list>.");
        switch (in) {
            case atok_t_y_list::INDEX:
                *index = load_unsigned_int(attr.value());
                break;
            case atok_t_y_list::INFO:
                *info = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_y_list);
}

inline void load_sizing_required_attributes(const pugi::xml_node& root, float* buf_size, float* mux_trans_size) {
    std::bitset<2> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_sizing in = lex_attr_t_sizing(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <sizing>.");
        switch (in) {
            case atok_t_sizing::BUF_SIZE:
                *buf_size = load_float(attr.value());
                break;
            case atok_t_sizing::MUX_TRANS_SIZE:
                *mux_trans_size = load_float(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_sizing);
}

inline void load_switch_required_attributes(const pugi::xml_node& root, int* id) {
    std::bitset<3> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_switch in = lex_attr_t_switch(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <switch>.");
        switch (in) {
            case atok_t_switch::ID:
                *id = load_int(attr.value());
                break;
            case atok_t_switch::NAME:
                /* Attribute name set after element init */
                break;
            case atok_t_switch::TYPE:
                /* Attribute type set after element init */
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<3> test_astate = astate | std::bitset<3>(0b100);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_switch);
}

inline void load_segment_required_attributes(const pugi::xml_node& root, int* id) {
    std::bitset<2> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_segment in = lex_attr_t_segment(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <segment>.");
        switch (in) {
            case atok_t_segment::ID:
                *id = load_int(attr.value());
                break;
            case atok_t_segment::NAME:
                /* Attribute name set after element init */
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_segment);
}

inline void load_pin_required_attributes(const pugi::xml_node& root, int* ptc) {
    std::bitset<1> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_pin in = lex_attr_t_pin(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <pin>.");
        switch (in) {
            case atok_t_pin::PTC:
                *ptc = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_pin);
}

inline void load_pin_class_required_attributes(const pugi::xml_node& root, enum_pin_type* type) {
    std::bitset<1> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_pin_class in = lex_attr_t_pin_class(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <pin_class>.");
        switch (in) {
            case atok_t_pin_class::TYPE:
                *type = lex_enum_pin_type(attr.value(), true);
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_pin_class);
}

inline void load_block_type_required_attributes(const pugi::xml_node& root, int* height, int* id, int* width) {
    std::bitset<4> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_block_type in = lex_attr_t_block_type(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <block_type>.");
        switch (in) {
            case atok_t_block_type::HEIGHT:
                *height = load_int(attr.value());
                break;
            case atok_t_block_type::ID:
                *id = load_int(attr.value());
                break;
            case atok_t_block_type::NAME:
                /* Attribute name set after element init */
                break;
            case atok_t_block_type::WIDTH:
                *width = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<4> test_astate = astate | std::bitset<4>(0b0000);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_block_type);
}

inline void load_grid_loc_required_attributes(const pugi::xml_node& root, int* block_type_id, int* height_offset, int* width_offset, int* x, int* y) {
    std::bitset<5> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_grid_loc in = lex_attr_t_grid_loc(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <grid_loc>.");
        switch (in) {
            case atok_t_grid_loc::BLOCK_TYPE_ID:
                *block_type_id = load_int(attr.value());
                break;
            case atok_t_grid_loc::HEIGHT_OFFSET:
                *height_offset = load_int(attr.value());
                break;
            case atok_t_grid_loc::WIDTH_OFFSET:
                *width_offset = load_int(attr.value());
                break;
            case atok_t_grid_loc::X:
                *x = load_int(attr.value());
                break;
            case atok_t_grid_loc::Y:
                *y = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<5> test_astate = astate | std::bitset<5>(0b00000);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_grid_loc);
}

inline void load_node_loc_required_attributes(const pugi::xml_node& root, int* ptc, int* xhigh, int* xlow, int* yhigh, int* ylow) {
    std::bitset<6> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node_loc in = lex_attr_t_node_loc(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_loc>.");
        switch (in) {
            case atok_t_node_loc::PTC:
                *ptc = load_int(attr.value());
                break;
            case atok_t_node_loc::SIDE:
                /* Attribute side set after element init */
                break;
            case atok_t_node_loc::XHIGH:
                *xhigh = load_int(attr.value());
                break;
            case atok_t_node_loc::XLOW:
                *xlow = load_int(attr.value());
                break;
            case atok_t_node_loc::YHIGH:
                *yhigh = load_int(attr.value());
                break;
            case atok_t_node_loc::YLOW:
                *ylow = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<6> test_astate = astate | std::bitset<6>(0b000010);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_loc);
}

inline void load_node_timing_required_attributes(const pugi::xml_node& root, float* C, float* R) {
    std::bitset<2> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node_timing in = lex_attr_t_node_timing(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_timing>.");
        switch (in) {
            case atok_t_node_timing::C:
                *C = load_float(attr.value());
                break;
            case atok_t_node_timing::R:
                *R = load_float(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_astate = astate | std::bitset<2>(0b00);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_timing);
}

inline void load_node_segment_required_attributes(const pugi::xml_node& root, int* segment_id) {
    std::bitset<1> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node_segment in = lex_attr_t_node_segment(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node_segment>.");
        switch (in) {
            case atok_t_node_segment::SEGMENT_ID:
                *segment_id = load_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<1> test_astate = astate | std::bitset<1>(0b0);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_node_segment);
}

inline void load_node_required_attributes(const pugi::xml_node& root, unsigned int* capacity, unsigned int* id, enum_node_type* type) {
    std::bitset<4> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node in = lex_attr_t_node(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <node>.");
        switch (in) {
            case atok_t_node::CAPACITY:
                *capacity = load_unsigned_int(attr.value());
                break;
            case atok_t_node::DIRECTION:
                /* Attribute direction set after element init */
                break;
            case atok_t_node::ID:
                *id = load_unsigned_int(attr.value());
                break;
            case atok_t_node::TYPE:
                *type = lex_enum_node_type(attr.value(), true);
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<4> test_astate = astate | std::bitset<4>(0b0010);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_node);
}

inline void load_edge_required_attributes(const pugi::xml_node& root, unsigned int* sink_node, unsigned int* src_node, unsigned int* switch_id) {
    std::bitset<3> astate = 0;
    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_edge in = lex_attr_t_edge(attr.name());
        if (astate[(int)in] == 0)
            astate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate attribute " + std::string(attr.name()) + " in <edge>.");
        switch (in) {
            case atok_t_edge::SINK_NODE:
                *sink_node = load_unsigned_int(attr.value());
                break;
            case atok_t_edge::SRC_NODE:
                *src_node = load_unsigned_int(attr.value());
                break;
            case atok_t_edge::SWITCH_ID:
                *switch_id = load_unsigned_int(attr.value());
                break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<3> test_astate = astate | std::bitset<3>(0b000);
    if (!test_astate.all()) attr_error(test_astate, atok_lookup_t_edge);
}
template<class T>
inline void load_channel(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <channel>.");
}

template<class T>
inline void load_x_list(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <x_list>.");
}

template<class T>
inline void load_y_list(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <y_list>.");
}

constexpr int NUM_T_CHANNELS_STATES = 4;
constexpr const int NUM_T_CHANNELS_INPUTS = 3;
constexpr int gstate_t_channels[NUM_T_CHANNELS_STATES][NUM_T_CHANNELS_INPUTS] = {
    {-1, -1, 0},
    {-1, 1, 0},
    {-1, 1, -1},
    {2, -1, -1},
};
template<class T>
inline void load_channels(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <channels>.");

    int next, state = 3;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_channels in = lex_node_t_channels(node.name());
        next = gstate_t_channels[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_channels[(int)in], gstate_t_channels[state], gtok_lookup_t_channels, 3);
        state = next;
        switch (in) {
            case gtok_t_channels::CHANNEL: {
                int channel_chan_width_max;
                int channel_x_max;
                int channel_x_min;
                int channel_y_max;
                int channel_y_min;
                load_channel_required_attributes(node, &channel_chan_width_max, &channel_x_max, &channel_x_min, &channel_y_max, &channel_y_min);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_channels_channel(data, iter, channel_chan_width_max, channel_x_max, channel_x_min, channel_y_max, channel_y_min);
                load_channel(node, out, child_data, child_iter);
                out.finish_channels_channel(child_data, child_iter);
            } break;
            case gtok_t_channels::X_LIST: {
                unsigned int x_list_index;
                int x_list_info;
                load_x_list_required_attributes(node, &x_list_index, &x_list_info);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_channels_x_list(data, iter, x_list_index, x_list_info);
                load_x_list(node, out, child_data, child_iter);
                out.finish_channels_x_list(child_data, child_iter);
            } break;
            case gtok_t_channels::Y_LIST: {
                unsigned int y_list_index;
                int y_list_info;
                load_y_list_required_attributes(node, &y_list_index, &y_list_info);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_channels_y_list(data, iter, y_list_index, y_list_info);
                load_y_list(node, out, child_data, child_iter);
                out.finish_channels_y_list(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_channels[state], gtok_lookup_t_channels, 3);
}

template<class T>
inline void load_timing(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_timing in = lex_attr_t_timing(attr.name());
        switch (in) {
            case atok_t_timing::CIN:
                out.set_timing_Cin(load_float(attr.value()), data, iter);
                break;
            case atok_t_timing::CINTERNAL:
                out.set_timing_Cinternal(load_float(attr.value()), data, iter);
                break;
            case atok_t_timing::COUT:
                out.set_timing_Cout(load_float(attr.value()), data, iter);
                break;
            case atok_t_timing::R:
                out.set_timing_R(load_float(attr.value()), data, iter);
                break;
            case atok_t_timing::TDEL:
                out.set_timing_Tdel(load_float(attr.value()), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <timing>.");
}

template<class T>
inline void load_sizing(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <sizing>.");
}

template<class T>
inline void load_switch(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_switch in = lex_attr_t_switch(attr.name());
        switch (in) {
            case atok_t_switch::ID:
                /* Attribute id is already set */
                break;
            case atok_t_switch::NAME:
                out.set_switch_name(attr.value(), data, iter);
                break;
            case atok_t_switch::TYPE:
                out.set_switch_type(lex_enum_switch_type(attr.value(), true), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    std::bitset<2> gstate = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_switch in = lex_node_t_switch(node.name());
        if (gstate[(int)in] == 0)
            gstate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <switch>.");
        switch (in) {
            case gtok_t_switch::TIMING: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_switch_timing(data, iter);
                load_timing(node, out, child_data, child_iter);
                out.finish_switch_timing(child_data, child_iter);
            } break;
            case gtok_t_switch::SIZING: {
                float sizing_buf_size;
                float sizing_mux_trans_size;
                load_sizing_required_attributes(node, &sizing_buf_size, &sizing_mux_trans_size);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_switch_sizing(data, iter, sizing_buf_size, sizing_mux_trans_size);
                load_sizing(node, out, child_data, child_iter);
                out.finish_switch_sizing(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<2> test_gstate = gstate | std::bitset<2>(0b01);
    if (!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_switch);
}

constexpr int NUM_T_SWITCHES_STATES = 2;
constexpr const int NUM_T_SWITCHES_INPUTS = 1;
constexpr int gstate_t_switches[NUM_T_SWITCHES_STATES][NUM_T_SWITCHES_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_switches(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <switches>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_switches in = lex_node_t_switches(node.name());
        next = gstate_t_switches[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_switches[(int)in], gstate_t_switches[state], gtok_lookup_t_switches, 1);
        state = next;
        switch (in) {
            case gtok_t_switches::SWITCH: {
                int switch_id;
                load_switch_required_attributes(node, &switch_id);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_switches_switch(data, iter, switch_id);
                load_switch(node, out, child_data, child_iter);
                out.finish_switches_switch(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_switches[state], gtok_lookup_t_switches, 1);
}

template<class T>
inline void load_segment_timing(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_segment_timing in = lex_attr_t_segment_timing(attr.name());
        switch (in) {
            case atok_t_segment_timing::C_PER_METER:
                out.set_segment_timing_C_per_meter(load_float(attr.value()), data, iter);
                break;
            case atok_t_segment_timing::R_PER_METER:
                out.set_segment_timing_R_per_meter(load_float(attr.value()), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <segment_timing>.");
}

template<class T>
inline void load_segment(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_segment in = lex_attr_t_segment(attr.name());
        switch (in) {
            case atok_t_segment::ID:
                /* Attribute id is already set */
                break;
            case atok_t_segment::NAME:
                out.set_segment_name(attr.value(), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    std::bitset<1> gstate = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_segment in = lex_node_t_segment(node.name());
        if (gstate[(int)in] == 0)
            gstate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <segment>.");
        switch (in) {
            case gtok_t_segment::TIMING: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_segment_timing(data, iter);
                load_segment_timing(node, out, child_data, child_iter);
                out.finish_segment_timing(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<1> test_gstate = gstate | std::bitset<1>(0b1);
    if (!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_segment);
}

constexpr int NUM_T_SEGMENTS_STATES = 2;
constexpr const int NUM_T_SEGMENTS_INPUTS = 1;
constexpr int gstate_t_segments[NUM_T_SEGMENTS_STATES][NUM_T_SEGMENTS_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_segments(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <segments>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_segments in = lex_node_t_segments(node.name());
        next = gstate_t_segments[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_segments[(int)in], gstate_t_segments[state], gtok_lookup_t_segments, 1);
        state = next;
        switch (in) {
            case gtok_t_segments::SEGMENT: {
                int segment_id;
                load_segment_required_attributes(node, &segment_id);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_segments_segment(data, iter, segment_id);
                load_segment(node, out, child_data, child_iter);
                out.finish_segments_segment(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_segments[state], gtok_lookup_t_segments, 1);
}

template<class T>
inline void load_pin(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    out.set_pin_value(root.child_value(), data, iter);
    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <pin>.");
}

constexpr int NUM_T_PIN_CLASS_STATES = 2;
constexpr const int NUM_T_PIN_CLASS_INPUTS = 1;
constexpr int gstate_t_pin_class[NUM_T_PIN_CLASS_STATES][NUM_T_PIN_CLASS_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_pin_class(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_pin_class in = lex_node_t_pin_class(node.name());
        next = gstate_t_pin_class[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_pin_class[(int)in], gstate_t_pin_class[state], gtok_lookup_t_pin_class, 1);
        state = next;
        switch (in) {
            case gtok_t_pin_class::PIN: {
                int pin_ptc;
                load_pin_required_attributes(node, &pin_ptc);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_pin_class_pin(data, iter, pin_ptc);
                load_pin(node, out, child_data, child_iter);
                out.finish_pin_class_pin(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_pin_class[state], gtok_lookup_t_pin_class, 1);
}

constexpr int NUM_T_BLOCK_TYPE_STATES = 1;
constexpr const int NUM_T_BLOCK_TYPE_INPUTS = 1;
constexpr int gstate_t_block_type[NUM_T_BLOCK_TYPE_STATES][NUM_T_BLOCK_TYPE_INPUTS] = {
    {0},
};
template<class T>
inline void load_block_type(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_block_type in = lex_attr_t_block_type(attr.name());
        switch (in) {
            case atok_t_block_type::HEIGHT:
                /* Attribute height is already set */
                break;
            case atok_t_block_type::ID:
                /* Attribute id is already set */
                break;
            case atok_t_block_type::NAME:
                out.set_block_type_name(attr.value(), data, iter);
                break;
            case atok_t_block_type::WIDTH:
                /* Attribute width is already set */
                break;
            default:
                break; /* Not possible. */
        }
    }

    int next, state = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_block_type in = lex_node_t_block_type(node.name());
        next = gstate_t_block_type[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_block_type[(int)in], gstate_t_block_type[state], gtok_lookup_t_block_type, 1);
        state = next;
        switch (in) {
            case gtok_t_block_type::PIN_CLASS: {
                enum_pin_type pin_class_type;
                load_pin_class_required_attributes(node, &pin_class_type);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_block_type_pin_class(data, iter, pin_class_type);
                load_pin_class(node, out, child_data, child_iter);
                out.finish_block_type_pin_class(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_block_type[state], gtok_lookup_t_block_type, 1);
}

constexpr int NUM_T_BLOCK_TYPES_STATES = 2;
constexpr const int NUM_T_BLOCK_TYPES_INPUTS = 1;
constexpr int gstate_t_block_types[NUM_T_BLOCK_TYPES_STATES][NUM_T_BLOCK_TYPES_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_block_types(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <block_types>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_block_types in = lex_node_t_block_types(node.name());
        next = gstate_t_block_types[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_block_types[(int)in], gstate_t_block_types[state], gtok_lookup_t_block_types, 1);
        state = next;
        switch (in) {
            case gtok_t_block_types::BLOCK_TYPE: {
                int block_type_height;
                int block_type_id;
                int block_type_width;
                load_block_type_required_attributes(node, &block_type_height, &block_type_id, &block_type_width);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_block_types_block_type(data, iter, block_type_height, block_type_id, block_type_width);
                load_block_type(node, out, child_data, child_iter);
                out.finish_block_types_block_type(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_block_types[state], gtok_lookup_t_block_types, 1);
}

template<class T>
inline void load_grid_loc(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <grid_loc>.");
}

constexpr int NUM_T_GRID_LOCS_STATES = 2;
constexpr const int NUM_T_GRID_LOCS_INPUTS = 1;
constexpr int gstate_t_grid_locs[NUM_T_GRID_LOCS_STATES][NUM_T_GRID_LOCS_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_grid_locs(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <grid_locs>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_grid_locs in = lex_node_t_grid_locs(node.name());
        next = gstate_t_grid_locs[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_grid_locs[(int)in], gstate_t_grid_locs[state], gtok_lookup_t_grid_locs, 1);
        state = next;
        switch (in) {
            case gtok_t_grid_locs::GRID_LOC: {
                int grid_loc_block_type_id;
                int grid_loc_height_offset;
                int grid_loc_width_offset;
                int grid_loc_x;
                int grid_loc_y;
                load_grid_loc_required_attributes(node, &grid_loc_block_type_id, &grid_loc_height_offset, &grid_loc_width_offset, &grid_loc_x, &grid_loc_y);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_grid_locs_grid_loc(data, iter, grid_loc_block_type_id, grid_loc_height_offset, grid_loc_width_offset, grid_loc_x, grid_loc_y);
                load_grid_loc(node, out, child_data, child_iter);
                out.finish_grid_locs_grid_loc(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_grid_locs[state], gtok_lookup_t_grid_locs, 1);
}

template<class T>
inline void load_node_loc(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node_loc in = lex_attr_t_node_loc(attr.name());
        switch (in) {
            case atok_t_node_loc::PTC:
                /* Attribute ptc is already set */
                break;
            case atok_t_node_loc::SIDE:
                out.set_node_loc_side(lex_enum_loc_side(attr.value(), true), data, iter);
                break;
            case atok_t_node_loc::XHIGH:
                /* Attribute xhigh is already set */
                break;
            case atok_t_node_loc::XLOW:
                /* Attribute xlow is already set */
                break;
            case atok_t_node_loc::YHIGH:
                /* Attribute yhigh is already set */
                break;
            case atok_t_node_loc::YLOW:
                /* Attribute ylow is already set */
                break;
            default:
                break; /* Not possible. */
        }
    }

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <node_loc>.");
}

template<class T>
inline void load_node_timing(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <node_timing>.");
}

template<class T>
inline void load_node_segment(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <node_segment>.");
}

template<class T>
inline void load_meta(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_meta in = lex_attr_t_meta(attr.name());
        switch (in) {
            case atok_t_meta::NAME:
                out.set_meta_name(attr.value(), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    out.set_meta_value(root.child_value(), data, iter);
    if (root.first_child().type() == pugi::node_element)
        throw std::runtime_error("Unexpected child element in <meta>.");
}

constexpr int NUM_T_METADATA_STATES = 2;
constexpr const int NUM_T_METADATA_INPUTS = 1;
constexpr int gstate_t_metadata[NUM_T_METADATA_STATES][NUM_T_METADATA_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_metadata(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <metadata>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_metadata in = lex_node_t_metadata(node.name());
        next = gstate_t_metadata[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_metadata[(int)in], gstate_t_metadata[state], gtok_lookup_t_metadata, 1);
        state = next;
        switch (in) {
            case gtok_t_metadata::META: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_metadata_meta(data, iter);
                load_meta(node, out, child_data, child_iter);
                out.finish_metadata_meta(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_metadata[state], gtok_lookup_t_metadata, 1);
}

template<class T>
inline void load_node(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_node in = lex_attr_t_node(attr.name());
        switch (in) {
            case atok_t_node::CAPACITY:
                /* Attribute capacity is already set */
                break;
            case atok_t_node::DIRECTION:
                out.set_node_direction(lex_enum_node_direction(attr.value(), true), data, iter);
                break;
            case atok_t_node::ID:
                /* Attribute id is already set */
                break;
            case atok_t_node::TYPE:
                /* Attribute type is already set */
                break;
            default:
                break; /* Not possible. */
        }
    }

    std::bitset<4> gstate = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_node in = lex_node_t_node(node.name());
        if (gstate[(int)in] == 0)
            gstate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <node>.");
        switch (in) {
            case gtok_t_node::LOC: {
                int node_loc_ptc;
                int node_loc_xhigh;
                int node_loc_xlow;
                int node_loc_yhigh;
                int node_loc_ylow;
                load_node_loc_required_attributes(node, &node_loc_ptc, &node_loc_xhigh, &node_loc_xlow, &node_loc_yhigh, &node_loc_ylow);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_node_loc(data, iter, node_loc_ptc, node_loc_xhigh, node_loc_xlow, node_loc_yhigh, node_loc_ylow);
                load_node_loc(node, out, child_data, child_iter);
                out.finish_node_loc(child_data, child_iter);
            } break;
            case gtok_t_node::TIMING: {
                float node_timing_C;
                float node_timing_R;
                load_node_timing_required_attributes(node, &node_timing_C, &node_timing_R);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_node_timing(data, iter, node_timing_C, node_timing_R);
                load_node_timing(node, out, child_data, child_iter);
                out.finish_node_timing(child_data, child_iter);
            } break;
            case gtok_t_node::SEGMENT: {
                int node_segment_segment_id;
                load_node_segment_required_attributes(node, &node_segment_segment_id);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_node_segment(data, iter, node_segment_segment_id);
                load_node_segment(node, out, child_data, child_iter);
                out.finish_node_segment(child_data, child_iter);
            } break;
            case gtok_t_node::METADATA: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_node_metadata(data, iter);
                load_metadata(node, out, child_data, child_iter);
                out.finish_node_metadata(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<4> test_gstate = gstate | std::bitset<4>(0b1110);
    if (!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_node);
}

constexpr int NUM_T_RR_NODES_STATES = 2;
constexpr const int NUM_T_RR_NODES_INPUTS = 1;
constexpr int gstate_t_rr_nodes[NUM_T_RR_NODES_STATES][NUM_T_RR_NODES_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_rr_nodes(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <rr_nodes>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_rr_nodes in = lex_node_t_rr_nodes(node.name());
        next = gstate_t_rr_nodes[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_rr_nodes[(int)in], gstate_t_rr_nodes[state], gtok_lookup_t_rr_nodes, 1);
        state = next;
        switch (in) {
            case gtok_t_rr_nodes::NODE: {
                unsigned int node_capacity;
                unsigned int node_id;
                enum_node_type node_type;
                load_node_required_attributes(node, &node_capacity, &node_id, &node_type);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_rr_nodes_node(data, iter, node_capacity, node_id, node_type);
                load_node(node, out, child_data, child_iter);
                out.finish_rr_nodes_node(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_rr_nodes[state], gtok_lookup_t_rr_nodes, 1);
}

template<class T>
inline void load_edge(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    std::bitset<1> gstate = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_edge in = lex_node_t_edge(node.name());
        if (gstate[(int)in] == 0)
            gstate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <edge>.");
        switch (in) {
            case gtok_t_edge::METADATA: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_edge_metadata(data, iter);
                load_metadata(node, out, child_data, child_iter);
                out.finish_edge_metadata(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<1> test_gstate = gstate | std::bitset<1>(0b1);
    if (!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_edge);
}

constexpr int NUM_T_RR_EDGES_STATES = 2;
constexpr const int NUM_T_RR_EDGES_INPUTS = 1;
constexpr int gstate_t_rr_edges[NUM_T_RR_EDGES_STATES][NUM_T_RR_EDGES_INPUTS] = {
    {0},
    {0},
};
template<class T>
inline void load_rr_edges(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    if (root.first_attribute())
        throw std::runtime_error("Unexpected attribute in <rr_edges>.");

    int next, state = 1;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_rr_edges in = lex_node_t_rr_edges(node.name());
        next = gstate_t_rr_edges[state][(int)in];
        if (next == -1)
            dfa_error(gtok_lookup_t_rr_edges[(int)in], gstate_t_rr_edges[state], gtok_lookup_t_rr_edges, 1);
        state = next;
        switch (in) {
            case gtok_t_rr_edges::EDGE: {
                unsigned int edge_sink_node;
                unsigned int edge_src_node;
                unsigned int edge_switch_id;
                load_edge_required_attributes(node, &edge_sink_node, &edge_src_node, &edge_switch_id);
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.add_rr_edges_edge(data, iter, edge_sink_node, edge_src_node, edge_switch_id);
                load_edge(node, out, child_data, child_iter);
                out.finish_rr_edges_edge(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    if (state != 0) dfa_error("end of input", gstate_t_rr_edges[state], gtok_lookup_t_rr_edges, 1);
}

template<class T>
inline void load_rr_graph(const pugi::xml_node& root, T& out, const void* data, void* iter) {
    (void)root;
    (void)out;
    (void)data;
    (void)iter;

    for (pugi::xml_attribute attr = root.first_attribute(); attr; attr = attr.next_attribute()) {
        atok_t_rr_graph in = lex_attr_t_rr_graph(attr.name());
        switch (in) {
            case atok_t_rr_graph::TOOL_COMMENT:
                out.set_rr_graph_tool_comment(attr.value(), data, iter);
                break;
            case atok_t_rr_graph::TOOL_NAME:
                out.set_rr_graph_tool_name(attr.value(), data, iter);
                break;
            case atok_t_rr_graph::TOOL_VERSION:
                out.set_rr_graph_tool_version(attr.value(), data, iter);
                break;
            default:
                break; /* Not possible. */
        }
    }

    std::bitset<7> gstate = 0;
    for (pugi::xml_node node = root.first_child(); node; node = node.next_sibling()) {
        gtok_t_rr_graph in = lex_node_t_rr_graph(node.name());
        if (gstate[(int)in] == 0)
            gstate[(int)in] = 1;
        else
            throw std::runtime_error("Duplicate element " + std::string(node.name()) + " in <rr_graph>.");
        switch (in) {
            case gtok_t_rr_graph::CHANNELS: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_channels(data, iter);
                load_channels(node, out, child_data, child_iter);
                out.finish_rr_graph_channels(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::SWITCHES: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_switches(data, iter);
                load_switches(node, out, child_data, child_iter);
                out.finish_rr_graph_switches(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::SEGMENTS: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_segments(data, iter);
                load_segments(node, out, child_data, child_iter);
                out.finish_rr_graph_segments(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::BLOCK_TYPES: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_block_types(data, iter);
                load_block_types(node, out, child_data, child_iter);
                out.finish_rr_graph_block_types(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::GRID: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_grid(data, iter);
                load_grid_locs(node, out, child_data, child_iter);
                out.finish_rr_graph_grid(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::RR_NODES: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_rr_nodes(data, iter);
                load_rr_nodes(node, out, child_data, child_iter);
                out.finish_rr_graph_rr_nodes(child_data, child_iter);
            } break;
            case gtok_t_rr_graph::RR_EDGES: {
                const void* child_data;
                void* child_iter;
                std::tie(child_data, child_iter) = out.init_rr_graph_rr_edges(data, iter);
                load_rr_edges(node, out, child_data, child_iter);
                out.finish_rr_graph_rr_edges(child_data, child_iter);
            } break;
            default:
                break; /* Not possible. */
        }
    }
    std::bitset<7> test_gstate = gstate | std::bitset<7>(0b0000000);
    if (!test_gstate.all()) all_error(test_gstate, gtok_lookup_t_rr_graph);
}

/* Internal writing functions, which uxsdcxx uses to write out a class. */
template<class T>
inline void write_channels(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    std::tie(child_data, child_iter) = in.get_channels_channel(data, iter);
    os << "<channel";
    os << " chan_width_max=\"" << in.get_channel_chan_width_max(child_data, child_iter) << "\"";
    os << " x_max=\"" << in.get_channel_x_max(child_data, child_iter) << "\"";
    os << " x_min=\"" << in.get_channel_x_min(child_data, child_iter) << "\"";
    os << " y_max=\"" << in.get_channel_y_max(child_data, child_iter) << "\"";
    os << " y_min=\"" << in.get_channel_y_min(child_data, child_iter) << "\"";
    os << "/>\n";
    for (size_t i = 0, n = in.num_channels_x_list(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_channels_x_list(i, data, iter);
        os << "<x_list";
        os << " index=\"" << in.get_x_list_index(child_data, child_iter) << "\"";
        os << " info=\"" << in.get_x_list_info(child_data, child_iter) << "\"";
        os << "/>\n";
    }
    for (size_t i = 0, n = in.num_channels_y_list(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_channels_y_list(i, data, iter);
        os << "<y_list";
        os << " index=\"" << in.get_y_list_index(child_data, child_iter) << "\"";
        os << " info=\"" << in.get_y_list_info(child_data, child_iter) << "\"";
        os << "/>\n";
    }
}

template<class T>
inline void write_switch(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    if (in.has_switch_timing(data, iter)) {
        std::tie(child_data, child_iter) = in.get_switch_timing(data, iter);
        os << "<timing";
        if ((bool)in.get_timing_Cin(child_data, child_iter))
            os << " Cin=\"" << in.get_timing_Cin(child_data, child_iter) << "\"";
        if ((bool)in.get_timing_Cinternal(child_data, child_iter))
            os << " Cinternal=\"" << in.get_timing_Cinternal(child_data, child_iter) << "\"";
        if ((bool)in.get_timing_Cout(child_data, child_iter))
            os << " Cout=\"" << in.get_timing_Cout(child_data, child_iter) << "\"";
        if ((bool)in.get_timing_R(child_data, child_iter))
            os << " R=\"" << in.get_timing_R(child_data, child_iter) << "\"";
        if ((bool)in.get_timing_Tdel(child_data, child_iter))
            os << " Tdel=\"" << in.get_timing_Tdel(child_data, child_iter) << "\"";
        os << "/>\n";
    }
    std::tie(child_data, child_iter) = in.get_switch_sizing(data, iter);
    os << "<sizing";
    os << " buf_size=\"" << in.get_sizing_buf_size(child_data, child_iter) << "\"";
    os << " mux_trans_size=\"" << in.get_sizing_mux_trans_size(child_data, child_iter) << "\"";
    os << "/>\n";
}

template<class T>
inline void write_switches(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_switches_switch(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_switches_switch(i, data, iter);
        os << "<switch";
        os << " id=\"" << in.get_switch_id(child_data, child_iter) << "\"";
        os << " name=\"" << in.get_switch_name(child_data, child_iter) << "\"";
        if ((bool)in.get_switch_type(child_data, child_iter))
            os << " type=\"" << lookup_switch_type[(int)in.get_switch_type(child_data, child_iter)] << "\"";
        os << ">";
        write_switch(in, os, child_data, child_iter);
        os << "</switch>\n";
    }
}

template<class T>
inline void write_segment(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    if (in.has_segment_timing(data, iter)) {
        std::tie(child_data, child_iter) = in.get_segment_timing(data, iter);
        os << "<timing";
        if ((bool)in.get_segment_timing_C_per_meter(child_data, child_iter))
            os << " C_per_meter=\"" << in.get_segment_timing_C_per_meter(child_data, child_iter) << "\"";
        if ((bool)in.get_segment_timing_R_per_meter(child_data, child_iter))
            os << " R_per_meter=\"" << in.get_segment_timing_R_per_meter(child_data, child_iter) << "\"";
        os << "/>\n";
    }
}

template<class T>
inline void write_segments(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_segments_segment(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_segments_segment(i, data, iter);
        os << "<segment";
        os << " id=\"" << in.get_segment_id(child_data, child_iter) << "\"";
        os << " name=\"" << in.get_segment_name(child_data, child_iter) << "\"";
        os << ">";
        write_segment(in, os, child_data, child_iter);
        os << "</segment>\n";
    }
}

template<class T>
inline void write_pin(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    os << in.get_pin_value(data, iter);
}

template<class T>
inline void write_pin_class(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_pin_class_pin(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_pin_class_pin(i, data, iter);
        os << "<pin";
        os << " ptc=\"" << in.get_pin_ptc(child_data, child_iter) << "\"";
        os << ">";
        write_pin(in, os, child_data, child_iter);
        os << "</pin>\n";
    }
}

template<class T>
inline void write_block_type(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_block_type_pin_class(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_block_type_pin_class(i, data, iter);
        os << "<pin_class";
        os << " type=\"" << lookup_pin_type[(int)in.get_pin_class_type(child_data, child_iter)] << "\"";
        os << ">";
        write_pin_class(in, os, child_data, child_iter);
        os << "</pin_class>\n";
    }
}

template<class T>
inline void write_block_types(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_block_types_block_type(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_block_types_block_type(i, data, iter);
        os << "<block_type";
        os << " height=\"" << in.get_block_type_height(child_data, child_iter) << "\"";
        os << " id=\"" << in.get_block_type_id(child_data, child_iter) << "\"";
        os << " name=\"" << in.get_block_type_name(child_data, child_iter) << "\"";
        os << " width=\"" << in.get_block_type_width(child_data, child_iter) << "\"";
        os << ">";
        write_block_type(in, os, child_data, child_iter);
        os << "</block_type>\n";
    }
}

template<class T>
inline void write_grid_locs(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_grid_locs_grid_loc(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_grid_locs_grid_loc(i, data, iter);
        os << "<grid_loc";
        os << " block_type_id=\"" << in.get_grid_loc_block_type_id(child_data, child_iter) << "\"";
        os << " height_offset=\"" << in.get_grid_loc_height_offset(child_data, child_iter) << "\"";
        os << " width_offset=\"" << in.get_grid_loc_width_offset(child_data, child_iter) << "\"";
        os << " x=\"" << in.get_grid_loc_x(child_data, child_iter) << "\"";
        os << " y=\"" << in.get_grid_loc_y(child_data, child_iter) << "\"";
        os << "/>\n";
    }
}

template<class T>
inline void write_meta(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    os << in.get_meta_value(data, iter);
}

template<class T>
inline void write_metadata(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_metadata_meta(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_metadata_meta(i, data, iter);
        os << "<meta";
        os << " name=\"" << in.get_meta_name(child_data, child_iter) << "\"";
        os << ">";
        write_meta(in, os, child_data, child_iter);
        os << "</meta>\n";
    }
}

template<class T>
inline void write_node(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    std::tie(child_data, child_iter) = in.get_node_loc(data, iter);
    os << "<loc";
    os << " ptc=\"" << in.get_node_loc_ptc(child_data, child_iter) << "\"";
    if ((bool)in.get_node_loc_side(child_data, child_iter))
        os << " side=\"" << lookup_loc_side[(int)in.get_node_loc_side(child_data, child_iter)] << "\"";
    os << " xhigh=\"" << in.get_node_loc_xhigh(child_data, child_iter) << "\"";
    os << " xlow=\"" << in.get_node_loc_xlow(child_data, child_iter) << "\"";
    os << " yhigh=\"" << in.get_node_loc_yhigh(child_data, child_iter) << "\"";
    os << " ylow=\"" << in.get_node_loc_ylow(child_data, child_iter) << "\"";
    os << "/>\n";
    if (in.has_node_timing(data, iter)) {
        std::tie(child_data, child_iter) = in.get_node_timing(data, iter);
        os << "<timing";
        os << " C=\"" << in.get_node_timing_C(child_data, child_iter) << "\"";
        os << " R=\"" << in.get_node_timing_R(child_data, child_iter) << "\"";
        os << "/>\n";
    }
    if (in.has_node_segment(data, iter)) {
        std::tie(child_data, child_iter) = in.get_node_segment(data, iter);
        os << "<segment";
        os << " segment_id=\"" << in.get_node_segment_segment_id(child_data, child_iter) << "\"";
        os << "/>\n";
    }
    if (in.has_node_metadata(data, iter)) {
        std::tie(child_data, child_iter) = in.get_node_metadata(data, iter);
        os << "<metadata>\n";
        write_metadata(in, os, child_data, child_iter);
        os << "</metadata>\n";
    }
}

template<class T>
inline void write_rr_nodes(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_rr_nodes_node(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_rr_nodes_node(i, data, iter);
        os << "<node";
        os << " capacity=\"" << in.get_node_capacity(child_data, child_iter) << "\"";
        if ((bool)in.get_node_direction(child_data, child_iter))
            os << " direction=\"" << lookup_node_direction[(int)in.get_node_direction(child_data, child_iter)] << "\"";
        os << " id=\"" << in.get_node_id(child_data, child_iter) << "\"";
        os << " type=\"" << lookup_node_type[(int)in.get_node_type(child_data, child_iter)] << "\"";
        os << ">";
        write_node(in, os, child_data, child_iter);
        os << "</node>\n";
    }
}

template<class T>
inline void write_edge(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    if (in.has_edge_metadata(data, iter)) {
        std::tie(child_data, child_iter) = in.get_edge_metadata(data, iter);
        os << "<metadata>\n";
        write_metadata(in, os, child_data, child_iter);
        os << "</metadata>\n";
    }
}

template<class T>
inline void write_rr_edges(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    for (size_t i = 0, n = in.num_rr_edges_edge(data, iter); i < n; i++) {
        std::tie(child_data, child_iter) = in.get_rr_edges_edge(i, data, iter);
        os << "<edge";
        os << " sink_node=\"" << in.get_edge_sink_node(child_data, child_iter) << "\"";
        os << " src_node=\"" << in.get_edge_src_node(child_data, child_iter) << "\"";
        os << " switch_id=\"" << in.get_edge_switch_id(child_data, child_iter) << "\"";
        os << ">";
        write_edge(in, os, child_data, child_iter);
        os << "</edge>\n";
    }
}

template<class T>
inline void write_rr_graph(T& in, std::ostream& os, const void* data, void* iter) {
    (void)in;
    (void)os;
    (void)data;
    (void)iter;
    const void* child_data;
    void* child_iter;
    std::tie(child_data, child_iter) = in.get_rr_graph_channels(data, iter);
    os << "<channels>\n";
    write_channels(in, os, child_data, child_iter);
    os << "</channels>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_switches(data, iter);
    os << "<switches>\n";
    write_switches(in, os, child_data, child_iter);
    os << "</switches>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_segments(data, iter);
    os << "<segments>\n";
    write_segments(in, os, child_data, child_iter);
    os << "</segments>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_block_types(data, iter);
    os << "<block_types>\n";
    write_block_types(in, os, child_data, child_iter);
    os << "</block_types>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_grid(data, iter);
    os << "<grid>\n";
    write_grid_locs(in, os, child_data, child_iter);
    os << "</grid>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_rr_nodes(data, iter);
    os << "<rr_nodes>\n";
    write_rr_nodes(in, os, child_data, child_iter);
    os << "</rr_nodes>\n";
    std::tie(child_data, child_iter) = in.get_rr_graph_rr_edges(data, iter);
    os << "<rr_edges>\n";
    write_rr_edges(in, os, child_data, child_iter);
    os << "</rr_edges>\n";
}

inline void dfa_error(const char* wrong, const int* states, const char* const* lookup, int len) {
    std::vector<std::string> expected;
    for (int i = 0; i < len; i++) {
        if (states[i] != -1) expected.push_back(lookup[i]);
    }

    std::string expected_or = expected[0];
    for (unsigned int i = 1; i < expected.size(); i++)
        expected_or += std::string(" or ") + expected[i];

    throw std::runtime_error("Expected " + expected_or + ", found " + std::string(wrong));
}

template<std::size_t N>
inline void all_error(std::bitset<N> gstate, const char* const* lookup) {
    std::vector<std::string> missing;
    for (unsigned int i = 0; i < N; i++) {
        if (gstate[i] == 0) missing.push_back(lookup[i]);
    }

    std::string missing_and = missing[0];
    for (unsigned int i = 1; i < missing.size(); i++)
        missing_and += std::string(", ") + missing[i];

    throw std::runtime_error("Didn't find required elements " + missing_and + ".");
}

template<std::size_t N>
inline void attr_error(std::bitset<N> astate, const char* const* lookup) {
    std::vector<std::string> missing;
    for (unsigned int i = 0; i < N; i++) {
        if (astate[i] == 0) missing.push_back(lookup[i]);
    }

    std::string missing_and = missing[0];
    for (unsigned int i = 1; i < missing.size(); i++)
        missing_and += std::string(", ") + missing[i];

    throw std::runtime_error("Didn't find required attributes " + missing_and + ".");
}

} /* namespace uxsd */
