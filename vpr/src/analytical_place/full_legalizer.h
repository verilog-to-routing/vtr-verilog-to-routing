/**
 * @file
 * @author  Alex Singer
 * @date    September 2024
 * @brief   Defines the FullLegalizer class which takes a partial AP placement
 *          and generates a fully legal clustering and placement which can be
 *          routed by VTR.
 */

#pragma once

#include <memory>
#include <vector>
#include "ap_flow_enums.h"

// Forward declarations
class APNetlist;
class AtomNetlist;
class ClusteredNetlist;
class DeviceGrid;
class PartialPlacement;
class PlaceMacros;
class Prepacker;
struct t_arch;
struct t_logical_block_type;
struct t_vpr_setup;

/**
 * @brief The full legalizer in an AP flow
 *
 * Given a valid partial placement (of any level of legality), will produce a
 * fully legal clustering and clustered placement for use in the rest of the
 * VTR flow.
 */
class FullLegalizer {
public:
    virtual ~FullLegalizer() {}

    FullLegalizer(const APNetlist& ap_netlist,
                  const AtomNetlist& atom_netlist,
                  const Prepacker& prepacker,
                  t_vpr_setup& vpr_setup,
                  const t_arch& arch,
                  const DeviceGrid& device_grid,
                  const std::vector<t_logical_block_type>& logical_block_types)
            : ap_netlist_(ap_netlist),
              atom_netlist_(atom_netlist),
              prepacker_(prepacker),
              vpr_setup_(vpr_setup),
              arch_(arch),
              device_grid_(device_grid),
              logical_block_types_(logical_block_types) {}

    /**
     * @brief Perform legalization on the given partial placement solution
     *
     *  @param p_placement  A valid partial placement (passes verify method).
     *                      This implies that all blocks are placed on the
     *                      device grid and fixed blocks are observed.
     */
    virtual void legalize(const PartialPlacement& p_placement) = 0;

protected:
    /// @brief The AP Netlist to fully legalize the flat placement of.
    const APNetlist& ap_netlist_;

    /// @brief The Atom Netlist used to generate the AP Netlist.
    const AtomNetlist& atom_netlist_;

    /// @brief The Prepacker used to create molecules from the Atom Netlist.
    const Prepacker& prepacker_;

    /// @brief The VPR setup options passed into the VPR flow. This must be
    ///        mutable since some parts of packing modify the options.
    t_vpr_setup& vpr_setup_;

    /// @brief Information on the architecture of the FPGA.
    const t_arch& arch_;

    /// @brief The device grid which records where clusters can be placed.
    const DeviceGrid& device_grid_;

    /// @brief A list of the logical block types in the architecture.
    const std::vector<t_logical_block_type>& logical_block_types_;
};

std::unique_ptr<FullLegalizer> make_full_legalizer(e_ap_full_legalizer full_legalizer_type,
                                                   const APNetlist& ap_netlist,
                                                   const AtomNetlist& atom_netlist,
                                                   const Prepacker& prepacker,
                                                   t_vpr_setup& vpr_setup,
                                                   const t_arch& arch,
                                                   const DeviceGrid& device_grid,
                                                   const std::vector<t_logical_block_type>& logical_block_types);

/**
 * @brief The Naive Full Legalizer.
 *
 * This Full Legalizer will try to create clusters exactly where they want to
 * according to the Partial Placement. It will grow clusters from atoms that
 * are placed in the same tile, then it will try to place the cluster at that
 * location. If a location cannot be found, once all other clusters have tried
 * to be placed, it will try to find anywhere the cluster will fit and place it
 * there.
 */
class NaiveFullLegalizer : public FullLegalizer {
public:
    using FullLegalizer::FullLegalizer;

    /**
     * @brief Perform naive full legalization.
     */
    void legalize(const PartialPlacement& p_placement) final;

private:
    /**
     * @brief Helper method to create the clusters from the given partial
     *        placement.
     * TODO: Should return a ClusteredNetlist object, but need to wait until
     *       it is separated from load_cluster_constraints.
     */
    void create_clusters(const PartialPlacement& p_placement);

    /**
     * @brief Helper method to place the clusters based on the given partial
     *        placement.
     */
    void place_clusters(const ClusteredNetlist& clb_nlist,
                        const PlaceMacros& place_macros,
                        const PartialPlacement& p_placement);

};

/**
 * @brief APPack: A flat-placement-informed Packer Placer.
 *
 * The idea of APPack is to use the flat-placement information generated by the
 * AP Flow to guide the Packer and Placer to a better solution.
 *
 * In the Packer, the flat-placement can provide more context for the clusters
 * to pull in atoms that want to be near the other atoms in the cluster, and
 * repell atoms that are far apart. This can potentially make better clusters
 * than a Packer that does not know that information.
 *
 * In the Placer, the flat-placement can help decide where clusters of atoms
 * want to be placed. If this placement is then fed into a Simulated Annealing
 * based Detailed Placement step, this would enable it to converge on a better
 * answer faster.
 */
class APPack : public FullLegalizer {
public:
    using FullLegalizer::FullLegalizer;

    /**
     * @brief Run APPack.
     *
     * This will call the Packer and Placer using the options provided by the
     * user for these stages in VPR.
     */
    void legalize(const PartialPlacement& p_placement) final;
};

