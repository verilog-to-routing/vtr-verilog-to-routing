#ifndef VPR_CONTEXT_H
#define VPR_CONTEXT_H
#include <unordered_map>
#include <memory>

#include "vtr_matrix.h"
#include "netlist.h"
#include "atom_netlist.h"
#include "rr_node.h"
#include "tatum/TimingGraph.hpp"
#include "tatum/TimingConstraints.hpp"
#include "power.h"
#include "power_components.h"

struct Context {
    //Contexts are uncopyable
    Context() = default;
    Context(Context&) = delete;
    Context& operator=(Context&) = delete;
};

//State relating to the atom-level netlist
struct AtomContext : public Context {
    /********************************************************************
     Atom Netlist
     ********************************************************************/
    /* Atom netlist */
    AtomNetlist nlist;

    /* Mappins to/from the Atom Netlist */
    AtomLookup lookup;
};

//State relating to timing
struct TimingContext : public Context {
    /********************************************************************
     Timing
     ********************************************************************/
    std::shared_ptr<tatum::TimingGraph> graph;
    std::shared_ptr<tatum::TimingConstraints> constraints;

    t_timing_constraints* sdc; //TODO: remove classic SDC

    struct timing_analysis_profile_info {
        double timing_analysis_wallclock_time() const {
            return sta_wallclock_time + slack_wallclock_time;
        }

        double old_timing_analysis_wallclock_time() const {
            return old_sta_wallclock_time + old_delay_annotation_wallclock_time;
        }

        double sta_wallclock_time = 0.;
        double slack_wallclock_time = 0.;
        size_t num_full_updates = 0;

        double old_sta_wallclock_time = 0.;
        double old_delay_annotation_wallclock_time = 0.;
        size_t num_old_sta_full_updates = 0;
    };
    timing_analysis_profile_info stats;
};

//State relating the device
struct DeviceContext : public Context {
    /*********************************************************************
     Physical FPGA architecture 
     *********************************************************************/

    /* x and y dimensions of the FPGA itself, the core of the FPGA is from [1..nx][1..ny], the I/Os form a perimeter surrounding the core */
    int nx, ny;
    struct s_grid_tile **grid; /* FPGA complex blocks grid [0..nx+1][0..ny+1] */

    /* Special pointers to identify special blocks on an FPGA: I/Os, unused, and default */
    t_type_ptr IO_TYPE;
    t_type_ptr EMPTY_TYPE;
    t_type_ptr FILL_TYPE;

    /* block_types are blocks that can be moved by the placer
     such as: I/Os, CLBs, memories, multipliers, etc
     Different types of physical block are contained in type descriptors
     */
    int num_block_types;
    struct s_type_descriptor *block_types;

    /*******************************************************************
     Routing related
     ********************************************************************/

    /* chan_width is for x|y-directed channels; i.e. between rows */
    t_chan_width chan_width;

    /* Structures to define the routing architecture of the FPGA.           */
    int num_rr_nodes;
    t_rr_node *rr_nodes; /* [0..num_rr_nodes-1]          */

    int num_rr_indexed_data;
    t_rr_indexed_data *rr_indexed_data; /* [0 .. num_rr_indexed_data-1] */

    vtr::t_ivec ***rr_node_indices;

    int num_rr_switches;
    s_rr_switch_inf *rr_switch_inf; /* autogenerated in build_rr_graph based on switch fan-in. [0..(num_rr_switches-1)] */

    int num_arch_switches;
    s_arch_switch_inf *arch_switch_inf; /* [0..(num_arch_switches-1)] */

    /*
     * switch_fanin_remap is only used for printing out switch fanin stats (the -switch_stats option)
     * array index: [0..(num_arch_switches-1)]; 
     * map key: num of all possible fanin of that type of switch on chip
     * map value: remapped switch index (index in rr_switch_inf)
     */
    map<int, int> *switch_fanin_remap; 

    /*******************************************************************
     Clock Network
     ********************************************************************/
    t_clock_arch * clock_arch;

    /*******************************************************************
     Timing related
     ********************************************************************/
    //TODO: Remove these max_internal_delay globals when the classic timing analyzer is removed
    float pb_max_internal_delay; /* biggest internal delay of block */
    const t_pb_type *pbtype_max_internal_delay; /* block type with highest internal delay */
};

//State relating to power analysis
struct PowerContext : public Context {
    /*******************************************************************
     Power
     ********************************************************************/
    t_solution_inf solution_inf;
    t_power_output* output;
    t_power_commonly_used* commonly_used;
    t_power_tech* tech;
    t_power_arch* arch;
    t_net_power * clb_net_power;


    /* Atom net power info */
    std::unordered_map<AtomNetId,t_net_power> atom_net_power;
    t_power_components by_component;
};

//State relating to clustering
struct ClusteringContext : public Context {
    /********************************************************************
     CLB Netlist
     ********************************************************************/
    /* blocks in the clustered netlist */
    int num_blocks;
    struct s_block *blocks;

    /* External-to-complex blocks, post-packed netlist [NETS ONLY]*/
    t_netlist clbs_nlist;

    std::string clustering_id; //SHA256 digest of the .net file
};


//State relating to placement
struct PlacementContext : public Context {
    //TODO: move blocks .x/.y/.z out of clustered netlist into here

    std::vector<t_block_loc> block_locs;

    std::string placement_id; //SHA256 digest of .place file
};

//State relating to routing
struct RoutingContext : public Context {
    /* [0..num_nets-1] of linked list start pointers.  Defines the routing.  */
    struct s_trace **trace_head, **trace_tail;

    t_rr_node_state* rr_node_state; /* [0..num_rr_nodes-1] */

    int **net_rr_terminals; /* [0..num_nets-1][0..num_pins-1] */

    int **rr_blk_source; /* [0..num_blocks-1][0..num_class-1] */

    std::string routing_id; //SHA256 digest of .route file
};

class VprContext {
    public:
        const DeviceContext& device() const { return device_; }
        DeviceContext& mutable_device() { return device_; }

        const AtomContext& atom() const { return atom_; }
        AtomContext& mutable_atom() { return atom_; }

        const TimingContext& timing() const { return timing_; }
        TimingContext& mutable_timing() { return timing_; }

        const PowerContext& power() const { return power_; }
        PowerContext& mutable_power() { return power_; }

        const ClusteringContext& clustering() const { return clustering_; }
        ClusteringContext& mutable_clustering() { return clustering_; }

        const PlacementContext& placement() const { return placement_; }
        PlacementContext& mutable_placement() { return placement_; }

        const RoutingContext& routing() const { return routing_; }
        RoutingContext& mutable_routing() { return routing_; }
    private:
        DeviceContext device_;

        AtomContext atom_;

        TimingContext timing_;
        PowerContext power_;

        ClusteringContext clustering_;
        PlacementContext placement_;
        RoutingContext routing_;
};

#endif
