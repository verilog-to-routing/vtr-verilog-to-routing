/*
 * This source file contains a Verilog description of an IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2005-2011 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 2 complex words per cycle
//   Throughput: one transform every 32 cycles
//   Latency: 332 cycles

//   Resources required:
//     20 multipliers (16 x 16 bit)
//     34 adders (16 x 16 bit)
//     4 RAMs (16 words, 32 bits per word)
//     4 RAMs (8 words, 32 bits per word)
//     12 RAMs (64 words, 32 bits per word)
//     4 RAMs (32 words, 32 bits per word)
//     2 ROMs (32 words, 16 bits per word)
//     2 ROMs (8 words, 16 bits per word)
//     12 ROMs (32 words, 5 bits per word)
//     2 ROMs (16 words, 16 bits per word)

// Generated on Fri Jul 25 15:42:10 EDT 2014

// Latency: 332 clock cycles
// Throughput: 1 transform every 32 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 32 cycles.  This means that
// 32 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 332 cycles.  This means that
// the 'next_out' will be asserted 332 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


module dft_testbench();
   reg clk, reset, next;
   wire next_out;
   integer i, j, k, l, m;
   reg [15:0] counter;
   reg [15:0] in [3:0];
   wire [15:0] X0;
   wire [15:0] Y0;
   wire [15:0] X1;
   wire [15:0] Y1;
   wire [15:0] X2;
   wire [15:0] Y2;
   wire [15:0] X3;
   wire [15:0] Y3;
   reg clrCnt;
   assign X0 = in[0];
   assign X1 = in[1];
   assign X2 = in[2];
   assign X3 = in[3];

   initial clk = 0;

   always #10000 clk = ~clk;


   // Instantiate top-level module of core 'X' signals are system inputs
   // and 'Y' signals are system outputs
   dft_top dft_top_instance (.clk(clk), .reset(reset), .next(next), .next_out(next_out),
    .X0(X0), .Y0(Y0),
    .X1(X1), .Y1(Y1),
    .X2(X2), .Y2(Y2),
    .X3(X3), .Y3(Y3));

   // You can use this counter to verify that the gap and latency are as expected.
   always @(posedge clk) begin
      if (clrCnt) counter <= 0;
      else counter <= counter+1;
   end


   initial begin
      @(posedge clk);
      @(posedge clk);

      // On the next cycle, begin loading input vector.
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // The 64 complex data points enter the system over 32 cycles
      for (j=0; j < 31; j = j+1) begin
          // Input: 2 complex words per cycle
         for (k=0; k < 4; k = k+1) begin
            in[k] <= j*4 + k;
         end
         @(posedge clk);
      end
      j = 31;
      for (k=0; k < 4; k = k+1) begin
         in[k] <= j*4 + k;
      end


      @(posedge clk);
      // Wait until the next data vector can be entered
      while (counter < 30)
        @(posedge clk);

      // On the next cycle, we will start the next data vector
      next <= 1;
      clrCnt <= 1;
      @(posedge clk);
      clrCnt <= 0;
      next <= 0;

      // Start entering next input vector
      for (j=0; j < 31; j = j+1) begin
         // Input 4 words per cycle
         for (k=0; k < 4; k = k+1) begin
            in[k] <= 128 + j*4 + k;
          end
          @(posedge clk);
       end
       j = 31;
       for (k=0; k < 4; k = k+1) begin
          in[k] <= 128 + j*4 + k;
       end
   end


   initial begin
      // set initial values
      in[0] <= 0;
      in[1] <= 0;
      in[2] <= 0;
      in[3] <= 0;
      next <= 0;
      reset <= 0;

      @(posedge clk);
      reset <= 1;
      @(posedge clk);
      reset <= 0;
      @(posedge clk);
      @(posedge clk);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 1---");

      for (m=0; m < 31; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      // Wait until next_out goes high, then wait one clock cycle and begin receiving data
      @(posedge next_out);
      @(posedge clk); #1;
      $display("--- begin output 2---");

      for (m=0; m < 31; m=m+1) begin
         $display("%x", Y0);
         $display("%x", Y1);
         $display("%x", Y2);
         $display("%x", Y3);
         @(posedge clk); #1;
      end
      $display("%x", Y0);
      $display("%x", Y1);
      $display("%x", Y2);
      $display("%x", Y3);
      $finish;
   end
endmodule

// Latency: 332
// Gap: 32
// module_name_is:dft_top
module dft_top(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0_0;
   wire [15:0] t0_1;
   wire [15:0] t0_2;
   wire [15:0] t0_3;
   wire next_0;
   wire [15:0] t1_0;
   wire [15:0] t1_1;
   wire [15:0] t1_2;
   wire [15:0] t1_3;
   wire next_1;
   wire [15:0] t2_0;
   wire [15:0] t2_1;
   wire [15:0] t2_2;
   wire [15:0] t2_3;
   wire next_2;
   wire [15:0] t3_0;
   wire [15:0] t3_1;
   wire [15:0] t3_2;
   wire [15:0] t3_3;
   wire next_3;
   wire [15:0] t4_0;
   wire [15:0] t4_1;
   wire [15:0] t4_2;
   wire [15:0] t4_3;
   wire next_4;
   wire [15:0] t5_0;
   wire [15:0] t5_1;
   wire [15:0] t5_2;
   wire [15:0] t5_3;
   wire next_5;
   wire [15:0] t6_0;
   wire [15:0] t6_1;
   wire [15:0] t6_2;
   wire [15:0] t6_3;
   wire next_6;
   wire [15:0] t7_0;
   wire [15:0] t7_1;
   wire [15:0] t7_2;
   wire [15:0] t7_3;
   wire next_7;
   wire [15:0] t8_0;
   wire [15:0] t8_1;
   wire [15:0] t8_2;
   wire [15:0] t8_3;
   wire next_8;
   wire [15:0] t9_0;
   wire [15:0] t9_1;
   wire [15:0] t9_2;
   wire [15:0] t9_3;
   wire next_9;
   wire [15:0] t10_0;
   wire [15:0] t10_1;
   wire [15:0] t10_2;
   wire [15:0] t10_3;
   wire next_10;
   wire [15:0] t11_0;
   wire [15:0] t11_1;
   wire [15:0] t11_2;
   wire [15:0] t11_3;
   wire next_11;
   wire [15:0] t12_0;
   wire [15:0] t12_1;
   wire [15:0] t12_2;
   wire [15:0] t12_3;
   wire next_12;
   wire [15:0] t13_0;
   wire [15:0] t13_1;
   wire [15:0] t13_2;
   wire [15:0] t13_3;
   wire next_13;
   wire [15:0] t14_0;
   wire [15:0] t14_1;
   wire [15:0] t14_2;
   wire [15:0] t14_3;
   wire next_14;
   wire [15:0] t15_0;
   wire [15:0] t15_1;
   wire [15:0] t15_2;
   wire [15:0] t15_3;
   wire next_15;
   wire [15:0] t16_0;
   wire [15:0] t16_1;
   wire [15:0] t16_2;
   wire [15:0] t16_3;
   wire next_16;
   wire [15:0] t17_0;
   wire [15:0] t17_1;
   wire [15:0] t17_2;
   wire [15:0] t17_3;
   wire next_17;
   wire [15:0] t18_0;
   wire [15:0] t18_1;
   wire [15:0] t18_2;
   wire [15:0] t18_3;
   wire next_18;
   assign t0_0 = X0;
   assign Y0 = t18_0;
   assign t0_1 = X1;
   assign Y1 = t18_1;
   assign t0_2 = X2;
   assign Y2 = t18_2;
   assign t0_3 = X3;
   assign Y3 = t18_3;
   assign next_0 = next;
   assign next_out = next_18;

// latency=68, gap=32
   rc30655 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3));


// latency=2, gap=32
   codeBlock30657 stage1(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3));


// latency=8, gap=32
   rc30737 stage2(.clk(clk), .reset(reset), .next(next_2), .next_out(next_3),
    .X0(t2_0), .Y0(t3_0),
    .X1(t2_1), .Y1(t3_1),
    .X2(t2_2), .Y2(t3_2),
    .X3(t2_3), .Y3(t3_3));


// latency=8, gap=32
   DirSum_30916 stage3(.next(next_3), .clk(clk), .reset(reset), .next_out(next_4),
       .X0(t3_0), .Y0(t4_0),
       .X1(t3_1), .Y1(t4_1),
       .X2(t3_2), .Y2(t4_2),
       .X3(t3_3), .Y3(t4_3));


// latency=2, gap=32
   codeBlock30919 stage4(.clk(clk), .reset(reset), .next_in(next_4), .next_out(next_5),
       .X0_in(t4_0), .Y0(t5_0),
       .X1_in(t4_1), .Y1(t5_1),
       .X2_in(t4_2), .Y2(t5_2),
       .X3_in(t4_3), .Y3(t5_3));


// latency=12, gap=32
   rc30999 stage5(.clk(clk), .reset(reset), .next(next_5), .next_out(next_6),
    .X0(t5_0), .Y0(t6_0),
    .X1(t5_1), .Y1(t6_1),
    .X2(t5_2), .Y2(t6_2),
    .X3(t5_3), .Y3(t6_3));


// latency=8, gap=32
   DirSum_31186 stage6(.next(next_6), .clk(clk), .reset(reset), .next_out(next_7),
       .X0(t6_0), .Y0(t7_0),
       .X1(t6_1), .Y1(t7_1),
       .X2(t6_2), .Y2(t7_2),
       .X3(t6_3), .Y3(t7_3));


// latency=2, gap=32
   codeBlock31189 stage7(.clk(clk), .reset(reset), .next_in(next_7), .next_out(next_8),
       .X0_in(t7_0), .Y0(t8_0),
       .X1_in(t7_1), .Y1(t8_1),
       .X2_in(t7_2), .Y2(t8_2),
       .X3_in(t7_3), .Y3(t8_3));


// latency=20, gap=32
   rc31269 stage8(.clk(clk), .reset(reset), .next(next_8), .next_out(next_9),
    .X0(t8_0), .Y0(t9_0),
    .X1(t8_1), .Y1(t9_1),
    .X2(t8_2), .Y2(t9_2),
    .X3(t8_3), .Y3(t9_3));


// latency=8, gap=32
   DirSum_31472 stage9(.next(next_9), .clk(clk), .reset(reset), .next_out(next_10),
       .X0(t9_0), .Y0(t10_0),
       .X1(t9_1), .Y1(t10_1),
       .X2(t9_2), .Y2(t10_2),
       .X3(t9_3), .Y3(t10_3));


// latency=2, gap=32
   codeBlock31475 stage10(.clk(clk), .reset(reset), .next_in(next_10), .next_out(next_11),
       .X0_in(t10_0), .Y0(t11_0),
       .X1_in(t10_1), .Y1(t11_1),
       .X2_in(t10_2), .Y2(t11_2),
       .X3_in(t10_3), .Y3(t11_3));


// latency=36, gap=32
   rc31555 stage11(.clk(clk), .reset(reset), .next(next_11), .next_out(next_12),
    .X0(t11_0), .Y0(t12_0),
    .X1(t11_1), .Y1(t12_1),
    .X2(t11_2), .Y2(t12_2),
    .X3(t11_3), .Y3(t12_3));


// latency=8, gap=32
   DirSum_31790 stage12(.next(next_12), .clk(clk), .reset(reset), .next_out(next_13),
       .X0(t12_0), .Y0(t13_0),
       .X1(t12_1), .Y1(t13_1),
       .X2(t12_2), .Y2(t13_2),
       .X3(t12_3), .Y3(t13_3));


// latency=2, gap=32
   codeBlock31793 stage13(.clk(clk), .reset(reset), .next_in(next_13), .next_out(next_14),
       .X0_in(t13_0), .Y0(t14_0),
       .X1_in(t13_1), .Y1(t14_1),
       .X2_in(t13_2), .Y2(t14_2),
       .X3_in(t13_3), .Y3(t14_3));


// latency=68, gap=32
   rc31873 stage14(.clk(clk), .reset(reset), .next(next_14), .next_out(next_15),
    .X0(t14_0), .Y0(t15_0),
    .X1(t14_1), .Y1(t15_1),
    .X2(t14_2), .Y2(t15_2),
    .X3(t14_3), .Y3(t15_3));


// latency=8, gap=32
   DirSum_32171 stage15(.next(next_15), .clk(clk), .reset(reset), .next_out(next_16),
       .X0(t15_0), .Y0(t16_0),
       .X1(t15_1), .Y1(t16_1),
       .X2(t15_2), .Y2(t16_2),
       .X3(t15_3), .Y3(t16_3));


// latency=2, gap=32
   codeBlock32174 stage16(.clk(clk), .reset(reset), .next_in(next_16), .next_out(next_17),
       .X0_in(t16_0), .Y0(t17_0),
       .X1_in(t16_1), .Y1(t17_1),
       .X2_in(t16_2), .Y2(t17_2),
       .X3_in(t16_3), .Y3(t17_3));


// latency=68, gap=32
   rc32254 stage17(.clk(clk), .reset(reset), .next(next_17), .next_out(next_18),
    .X0(t17_0), .Y0(t18_0),
    .X1(t17_1), .Y1(t18_1),
    .X2(t17_2), .Y2(t18_2),
    .X3(t17_3), .Y3(t18_3));


endmodule

// Latency: 68
// Gap: 32
module rc30655(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm30653 instPerm33199(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet30653(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [4:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        5'd0: control <= 1'b1;
        5'd1: control <= 1'b1;
        5'd2: control <= 1'b1;
        5'd3: control <= 1'b1;
        5'd4: control <= 1'b1;
        5'd5: control <= 1'b1;
        5'd6: control <= 1'b1;
        5'd7: control <= 1'b1;
        5'd8: control <= 1'b1;
        5'd9: control <= 1'b1;
        5'd10: control <= 1'b1;
        5'd11: control <= 1'b1;
        5'd12: control <= 1'b1;
        5'd13: control <= 1'b1;
        5'd14: control <= 1'b1;
        5'd15: control <= 1'b1;
        5'd16: control <= 1'b0;
        5'd17: control <= 1'b0;
        5'd18: control <= 1'b0;
        5'd19: control <= 1'b0;
        5'd20: control <= 1'b0;
        5'd21: control <= 1'b0;
        5'd22: control <= 1'b0;
        5'd23: control <= 1'b0;
        5'd24: control <= 1'b0;
        5'd25: control <= 1'b0;
        5'd26: control <= 1'b0;
        5'd27: control <= 1'b0;
        5'd28: control <= 1'b0;
        5'd29: control <= 1'b0;
        5'd30: control <= 1'b0;
        5'd31: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 68
// Gap: 32
module perm30653(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 32;

   parameter addrbits = 5;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm0;
   assign tm0 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33204(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33205(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

nextReg #(31, 5) nextReg_33216(.X(next), .Y(next2), .reset(reset), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33217(.X(next2), .Y(next3), .clk(clk));
nextReg #(32, 5) nextReg_33220(.X(next3), .Y(next4), .reset(reset), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33221(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(31, 1) shiftFIFO_33224(.X(tm0), .Y(tm0_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33227(.X(tm0_d), .Y(tm0_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 5) shiftFIFO_33232(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd0 <= 16;
	     {1'd0,  5'd1}: s1rd0 <= 24;
	     {1'd0,  5'd2}: s1rd0 <= 20;
	     {1'd0,  5'd3}: s1rd0 <= 28;
	     {1'd0,  5'd4}: s1rd0 <= 18;
	     {1'd0,  5'd5}: s1rd0 <= 26;
	     {1'd0,  5'd6}: s1rd0 <= 22;
	     {1'd0,  5'd7}: s1rd0 <= 30;
	     {1'd0,  5'd8}: s1rd0 <= 17;
	     {1'd0,  5'd9}: s1rd0 <= 25;
	     {1'd0,  5'd10}: s1rd0 <= 21;
	     {1'd0,  5'd11}: s1rd0 <= 29;
	     {1'd0,  5'd12}: s1rd0 <= 19;
	     {1'd0,  5'd13}: s1rd0 <= 27;
	     {1'd0,  5'd14}: s1rd0 <= 23;
	     {1'd0,  5'd15}: s1rd0 <= 31;
	     {1'd0,  5'd16}: s1rd0 <= 0;
	     {1'd0,  5'd17}: s1rd0 <= 8;
	     {1'd0,  5'd18}: s1rd0 <= 4;
	     {1'd0,  5'd19}: s1rd0 <= 12;
	     {1'd0,  5'd20}: s1rd0 <= 2;
	     {1'd0,  5'd21}: s1rd0 <= 10;
	     {1'd0,  5'd22}: s1rd0 <= 6;
	     {1'd0,  5'd23}: s1rd0 <= 14;
	     {1'd0,  5'd24}: s1rd0 <= 1;
	     {1'd0,  5'd25}: s1rd0 <= 9;
	     {1'd0,  5'd26}: s1rd0 <= 5;
	     {1'd0,  5'd27}: s1rd0 <= 13;
	     {1'd0,  5'd28}: s1rd0 <= 3;
	     {1'd0,  5'd29}: s1rd0 <= 11;
	     {1'd0,  5'd30}: s1rd0 <= 7;
	     {1'd0,  5'd31}: s1rd0 <= 15;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm0_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd1 <= 0;
	     {1'd0,  5'd1}: s1rd1 <= 8;
	     {1'd0,  5'd2}: s1rd1 <= 4;
	     {1'd0,  5'd3}: s1rd1 <= 12;
	     {1'd0,  5'd4}: s1rd1 <= 2;
	     {1'd0,  5'd5}: s1rd1 <= 10;
	     {1'd0,  5'd6}: s1rd1 <= 6;
	     {1'd0,  5'd7}: s1rd1 <= 14;
	     {1'd0,  5'd8}: s1rd1 <= 1;
	     {1'd0,  5'd9}: s1rd1 <= 9;
	     {1'd0,  5'd10}: s1rd1 <= 5;
	     {1'd0,  5'd11}: s1rd1 <= 13;
	     {1'd0,  5'd12}: s1rd1 <= 3;
	     {1'd0,  5'd13}: s1rd1 <= 11;
	     {1'd0,  5'd14}: s1rd1 <= 7;
	     {1'd0,  5'd15}: s1rd1 <= 15;
	     {1'd0,  5'd16}: s1rd1 <= 16;
	     {1'd0,  5'd17}: s1rd1 <= 24;
	     {1'd0,  5'd18}: s1rd1 <= 20;
	     {1'd0,  5'd19}: s1rd1 <= 28;
	     {1'd0,  5'd20}: s1rd1 <= 18;
	     {1'd0,  5'd21}: s1rd1 <= 26;
	     {1'd0,  5'd22}: s1rd1 <= 22;
	     {1'd0,  5'd23}: s1rd1 <= 30;
	     {1'd0,  5'd24}: s1rd1 <= 17;
	     {1'd0,  5'd25}: s1rd1 <= 25;
	     {1'd0,  5'd26}: s1rd1 <= 21;
	     {1'd0,  5'd27}: s1rd1 <= 29;
	     {1'd0,  5'd28}: s1rd1 <= 19;
	     {1'd0,  5'd29}: s1rd1 <= 27;
	     {1'd0,  5'd30}: s1rd1 <= 23;
	     {1'd0,  5'd31}: s1rd1 <= 31;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet30653 sw(tm0_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr0 <= 16;
	      {1'd0, 5'd1}: s2wr0 <= 17;
	      {1'd0, 5'd2}: s2wr0 <= 18;
	      {1'd0, 5'd3}: s2wr0 <= 19;
	      {1'd0, 5'd4}: s2wr0 <= 20;
	      {1'd0, 5'd5}: s2wr0 <= 21;
	      {1'd0, 5'd6}: s2wr0 <= 22;
	      {1'd0, 5'd7}: s2wr0 <= 23;
	      {1'd0, 5'd8}: s2wr0 <= 24;
	      {1'd0, 5'd9}: s2wr0 <= 25;
	      {1'd0, 5'd10}: s2wr0 <= 26;
	      {1'd0, 5'd11}: s2wr0 <= 27;
	      {1'd0, 5'd12}: s2wr0 <= 28;
	      {1'd0, 5'd13}: s2wr0 <= 29;
	      {1'd0, 5'd14}: s2wr0 <= 30;
	      {1'd0, 5'd15}: s2wr0 <= 31;
	      {1'd0, 5'd16}: s2wr0 <= 0;
	      {1'd0, 5'd17}: s2wr0 <= 1;
	      {1'd0, 5'd18}: s2wr0 <= 2;
	      {1'd0, 5'd19}: s2wr0 <= 3;
	      {1'd0, 5'd20}: s2wr0 <= 4;
	      {1'd0, 5'd21}: s2wr0 <= 5;
	      {1'd0, 5'd22}: s2wr0 <= 6;
	      {1'd0, 5'd23}: s2wr0 <= 7;
	      {1'd0, 5'd24}: s2wr0 <= 8;
	      {1'd0, 5'd25}: s2wr0 <= 9;
	      {1'd0, 5'd26}: s2wr0 <= 10;
	      {1'd0, 5'd27}: s2wr0 <= 11;
	      {1'd0, 5'd28}: s2wr0 <= 12;
	      {1'd0, 5'd29}: s2wr0 <= 13;
	      {1'd0, 5'd30}: s2wr0 <= 14;
	      {1'd0, 5'd31}: s2wr0 <= 15;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm0_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr1 <= 0;
	      {1'd0, 5'd1}: s2wr1 <= 1;
	      {1'd0, 5'd2}: s2wr1 <= 2;
	      {1'd0, 5'd3}: s2wr1 <= 3;
	      {1'd0, 5'd4}: s2wr1 <= 4;
	      {1'd0, 5'd5}: s2wr1 <= 5;
	      {1'd0, 5'd6}: s2wr1 <= 6;
	      {1'd0, 5'd7}: s2wr1 <= 7;
	      {1'd0, 5'd8}: s2wr1 <= 8;
	      {1'd0, 5'd9}: s2wr1 <= 9;
	      {1'd0, 5'd10}: s2wr1 <= 10;
	      {1'd0, 5'd11}: s2wr1 <= 11;
	      {1'd0, 5'd12}: s2wr1 <= 12;
	      {1'd0, 5'd13}: s2wr1 <= 13;
	      {1'd0, 5'd14}: s2wr1 <= 14;
	      {1'd0, 5'd15}: s2wr1 <= 15;
	      {1'd0, 5'd16}: s2wr1 <= 16;
	      {1'd0, 5'd17}: s2wr1 <= 17;
	      {1'd0, 5'd18}: s2wr1 <= 18;
	      {1'd0, 5'd19}: s2wr1 <= 19;
	      {1'd0, 5'd20}: s2wr1 <= 20;
	      {1'd0, 5'd21}: s2wr1 <= 21;
	      {1'd0, 5'd22}: s2wr1 <= 22;
	      {1'd0, 5'd23}: s2wr1 <= 23;
	      {1'd0, 5'd24}: s2wr1 <= 24;
	      {1'd0, 5'd25}: s2wr1 <= 25;
	      {1'd0, 5'd26}: s2wr1 <= 26;
	      {1'd0, 5'd27}: s2wr1 <= 27;
	      {1'd0, 5'd28}: s2wr1 <= 28;
	      {1'd0, 5'd29}: s2wr1 <= 29;
	      {1'd0, 5'd30}: s2wr1 <= 30;
	      {1'd0, 5'd31}: s2wr1 <= 31;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule




module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule

module nextReg(X, Y, reset, clk);
   parameter depth=2, logDepth=1;

   output Y;
   input X;
   input              clk, reset;
   reg [logDepth:0] count;
   reg                active;

   assign Y = (count == depth) ? 1 : 0;

   always @ (posedge clk) begin
      if (reset == 1) begin
         count <= 0;
         active <= 0;
      end
      else if (X == 1) begin
         active <= 1;
         count <= 1;
      end
      else if (count == depth) begin
         count <= 0;
         active <= 0;
      end
      else if (active)
         count <= count+1;
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock30657(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33239(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a309;
   wire signed [15:0] a310;
   wire signed [15:0] a311;
   wire signed [15:0] a312;
   wire signed [15:0] t141;
   wire signed [15:0] t142;
   wire signed [15:0] t143;
   wire signed [15:0] t144;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a309 = X0;
   assign a310 = X2;
   assign a311 = X1;
   assign a312 = X3;
   assign Y0 = t141;
   assign Y1 = t142;
   assign Y2 = t143;
   assign Y3 = t144;

    addfxp #(16, 1) add30669(.a(a309), .b(a310), .clk(clk), .q(t141));    // 0
    addfxp #(16, 1) add30684(.a(a311), .b(a312), .clk(clk), .q(t142));    // 0
    subfxp #(16, 1) sub30698(.a(a309), .b(a310), .clk(clk), .q(t143));    // 0
    subfxp #(16, 1) sub30712(.a(a311), .b(a312), .clk(clk), .q(t144));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 8
// Gap: 2
module rc30737(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm30735 instPerm33240(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet30735(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [0:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        1'd0: control <= 1'b1;
        1'd1: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 8
// Gap: 2
module perm30735(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 2;

   parameter addrbits = 1;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm1;
   assign tm1 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33245(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33246(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(1, 1) shiftFIFO_33255(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33256(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(2, 1) shiftFIFO_33257(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33258(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33261(.X(tm1), .Y(tm1_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33264(.X(tm1_d), .Y(tm1_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 1) shiftFIFO_33269(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd0 <= 1;
	     {1'd0,  1'd1}: s1rd0 <= 0;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm1_d, s1rdloc})
	     {1'd0,  1'd0}: s1rd1 <= 0;
	     {1'd0,  1'd1}: s1rd1 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet30735 sw(tm1_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr0 <= 1;
	      {1'd0, 1'd1}: s2wr0 <= 0;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm1_dd, writeCycle})
	      {1'd0, 1'd0}: s2wr1 <= 0;
	      {1'd0, 1'd1}: s2wr1 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 8
// Gap: 2
module DirSum_30916(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [0:0] i5;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i5 <= 0;
      end
      else begin
         if (next == 1)
            i5 <= 0;
         else if (i5 == 1)
            i5 <= 0;
         else
            i5 <= i5 + 1;
      end
   end

   codeBlock30740 codeBlockIsnt33270(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i5_in(i5),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D18_30906(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D20_30914(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hc000;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock30740(clk, reset, next_in, next_out,
   i5_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [0:0] i5_in;
   reg [0:0] i5;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_33273(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a293;
   wire signed [15:0] a282;
   wire signed [15:0] a296;
   wire signed [15:0] a286;
   wire signed [15:0] a297;
   wire signed [15:0] a298;
   reg signed [15:0] tm137;
   reg signed [15:0] tm141;
   reg signed [15:0] tm153;
   reg signed [15:0] tm160;
   reg signed [15:0] tm138;
   reg signed [15:0] tm142;
   reg signed [15:0] tm154;
   reg signed [15:0] tm161;
   wire signed [15:0] tm4;
   wire signed [15:0] a287;
   wire signed [15:0] tm5;
   wire signed [15:0] a289;
   reg signed [15:0] tm139;
   reg signed [15:0] tm143;
   reg signed [15:0] tm155;
   reg signed [15:0] tm162;
   reg signed [15:0] tm31;
   reg signed [15:0] tm32;
   reg signed [15:0] tm140;
   reg signed [15:0] tm144;
   reg signed [15:0] tm156;
   reg signed [15:0] tm163;
   reg signed [15:0] tm157;
   reg signed [15:0] tm164;
   wire signed [15:0] a288;
   wire signed [15:0] a290;
   wire signed [15:0] a291;
   wire signed [15:0] a292;
   reg signed [15:0] tm158;
   reg signed [15:0] tm165;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   reg signed [15:0] tm159;
   reg signed [15:0] tm166;


   assign a293 = X0;
   assign a282 = a293;
   assign a296 = X1;
   assign a286 = a296;
   assign a297 = X2;
   assign a298 = X3;
   assign a287 = tm4;
   assign a289 = tm5;
   assign Y0 = tm159;
   assign Y1 = tm166;

   D18_30906 instD18inst0_30906(.addr(i5[0:0]), .out(tm4), .clk(clk));

   D20_30914 instD20inst0_30914(.addr(i5[0:0]), .out(tm5), .clk(clk));

    multfix #(16, 2) m30838(.a(tm31), .b(tm140), .clk(clk), .q_sc(a288), .q_unsc(), .rst(reset));
    multfix #(16, 2) m30860(.a(tm32), .b(tm144), .clk(clk), .q_sc(a290), .q_unsc(), .rst(reset));
    multfix #(16, 2) m30877(.a(tm32), .b(tm140), .clk(clk), .q_sc(a291), .q_unsc(), .rst(reset));
    multfix #(16, 2) m30888(.a(tm31), .b(tm144), .clk(clk), .q_sc(a292), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub30866(.a(a288), .b(a290), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add30895(.a(a291), .b(a292), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm31 <= 0;
         tm140 <= 0;
         tm32 <= 0;
         tm144 <= 0;
         tm32 <= 0;
         tm140 <= 0;
         tm31 <= 0;
         tm144 <= 0;
      end
      else begin
         i5 <= i5_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm137 <= a297;
         tm141 <= a298;
         tm153 <= a282;
         tm160 <= a286;
         tm138 <= tm137;
         tm142 <= tm141;
         tm154 <= tm153;
         tm161 <= tm160;
         tm139 <= tm138;
         tm143 <= tm142;
         tm155 <= tm154;
         tm162 <= tm161;
         tm31 <= a287;
         tm32 <= a289;
         tm140 <= tm139;
         tm144 <= tm143;
         tm156 <= tm155;
         tm163 <= tm162;
         tm157 <= tm156;
         tm164 <= tm163;
         tm158 <= tm157;
         tm165 <= tm164;
         tm159 <= tm158;
         tm166 <= tm165;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock30919(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33276(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a249;
   wire signed [15:0] a250;
   wire signed [15:0] a251;
   wire signed [15:0] a252;
   wire signed [15:0] t117;
   wire signed [15:0] t118;
   wire signed [15:0] t119;
   wire signed [15:0] t120;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a249 = X0;
   assign a250 = X2;
   assign a251 = X1;
   assign a252 = X3;
   assign Y0 = t117;
   assign Y1 = t118;
   assign Y2 = t119;
   assign Y3 = t120;

    addfxp #(16, 1) add30931(.a(a249), .b(a250), .clk(clk), .q(t117));    // 0
    addfxp #(16, 1) add30946(.a(a251), .b(a252), .clk(clk), .q(t118));    // 0
    subfxp #(16, 1) sub30960(.a(a249), .b(a250), .clk(clk), .q(t119));    // 0
    subfxp #(16, 1) sub30974(.a(a251), .b(a252), .clk(clk), .q(t120));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 12
// Gap: 4
module rc30999(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm30997 instPerm33277(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet30997(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [1:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        2'd0: control <= 1'b1;
        2'd1: control <= 1'b1;
        2'd2: control <= 1'b0;
        2'd3: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 12
// Gap: 4
module perm30997(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 4;

   parameter addrbits = 2;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm6;
   assign tm6 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33282(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33283(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(3, 1) shiftFIFO_33292(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33293(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33294(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33295(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33298(.X(tm6), .Y(tm6_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33301(.X(tm6_d), .Y(tm6_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 2) shiftFIFO_33306(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm6_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd0 <= 2;
	     {1'd0,  2'd1}: s1rd0 <= 3;
	     {1'd0,  2'd2}: s1rd0 <= 0;
	     {1'd0,  2'd3}: s1rd0 <= 1;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm6_d, s1rdloc})
	     {1'd0,  2'd0}: s1rd1 <= 0;
	     {1'd0,  2'd1}: s1rd1 <= 1;
	     {1'd0,  2'd2}: s1rd1 <= 2;
	     {1'd0,  2'd3}: s1rd1 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet30997 sw(tm6_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm6_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr0 <= 2;
	      {1'd0, 2'd1}: s2wr0 <= 3;
	      {1'd0, 2'd2}: s2wr0 <= 0;
	      {1'd0, 2'd3}: s2wr0 <= 1;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm6_dd, writeCycle})
	      {1'd0, 2'd0}: s2wr1 <= 0;
	      {1'd0, 2'd1}: s2wr1 <= 1;
	      {1'd0, 2'd2}: s2wr1 <= 2;
	      {1'd0, 2'd3}: s2wr1 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 8
// Gap: 4
module DirSum_31186(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [1:0] i4;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i4 <= 0;
      end
      else begin
         if (next == 1)
            i4 <= 0;
         else if (i4 == 3)
            i4 <= 0;
         else
            i4 <= i4 + 1;
      end
   end

   codeBlock31002 codeBlockIsnt33307(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i4_in(i4),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D14_31172(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h2d41;
      2: out3 <= 16'h0;
      3: out3 <= 16'hd2bf;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D16_31184(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hd2bf;
      2: out3 <= 16'hc000;
      3: out3 <= 16'hd2bf;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock31002(clk, reset, next_in, next_out,
   i4_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [1:0] i4_in;
   reg [1:0] i4;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_33310(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a233;
   wire signed [15:0] a222;
   wire signed [15:0] a236;
   wire signed [15:0] a226;
   wire signed [15:0] a237;
   wire signed [15:0] a238;
   reg signed [15:0] tm167;
   reg signed [15:0] tm171;
   reg signed [15:0] tm183;
   reg signed [15:0] tm190;
   reg signed [15:0] tm168;
   reg signed [15:0] tm172;
   reg signed [15:0] tm184;
   reg signed [15:0] tm191;
   wire signed [15:0] tm9;
   wire signed [15:0] a227;
   wire signed [15:0] tm10;
   wire signed [15:0] a229;
   reg signed [15:0] tm169;
   reg signed [15:0] tm173;
   reg signed [15:0] tm185;
   reg signed [15:0] tm192;
   reg signed [15:0] tm39;
   reg signed [15:0] tm40;
   reg signed [15:0] tm170;
   reg signed [15:0] tm174;
   reg signed [15:0] tm186;
   reg signed [15:0] tm193;
   reg signed [15:0] tm187;
   reg signed [15:0] tm194;
   wire signed [15:0] a228;
   wire signed [15:0] a230;
   wire signed [15:0] a231;
   wire signed [15:0] a232;
   reg signed [15:0] tm188;
   reg signed [15:0] tm195;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   reg signed [15:0] tm189;
   reg signed [15:0] tm196;


   assign a233 = X0;
   assign a222 = a233;
   assign a236 = X1;
   assign a226 = a236;
   assign a237 = X2;
   assign a238 = X3;
   assign a227 = tm9;
   assign a229 = tm10;
   assign Y0 = tm189;
   assign Y1 = tm196;

   D14_31172 instD14inst0_31172(.addr(i4[1:0]), .out(tm9), .clk(clk));

   D16_31184 instD16inst0_31184(.addr(i4[1:0]), .out(tm10), .clk(clk));

    multfix #(16, 2) m31100(.a(tm39), .b(tm170), .clk(clk), .q_sc(a228), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31122(.a(tm40), .b(tm174), .clk(clk), .q_sc(a230), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31139(.a(tm40), .b(tm170), .clk(clk), .q_sc(a231), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31150(.a(tm39), .b(tm174), .clk(clk), .q_sc(a232), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub31128(.a(a228), .b(a230), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add31157(.a(a231), .b(a232), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm39 <= 0;
         tm170 <= 0;
         tm40 <= 0;
         tm174 <= 0;
         tm40 <= 0;
         tm170 <= 0;
         tm39 <= 0;
         tm174 <= 0;
      end
      else begin
         i4 <= i4_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm167 <= a237;
         tm171 <= a238;
         tm183 <= a222;
         tm190 <= a226;
         tm168 <= tm167;
         tm172 <= tm171;
         tm184 <= tm183;
         tm191 <= tm190;
         tm169 <= tm168;
         tm173 <= tm172;
         tm185 <= tm184;
         tm192 <= tm191;
         tm39 <= a227;
         tm40 <= a229;
         tm170 <= tm169;
         tm174 <= tm173;
         tm186 <= tm185;
         tm193 <= tm192;
         tm187 <= tm186;
         tm194 <= tm193;
         tm188 <= tm187;
         tm195 <= tm194;
         tm189 <= tm188;
         tm196 <= tm195;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock31189(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33313(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a189;
   wire signed [15:0] a190;
   wire signed [15:0] a191;
   wire signed [15:0] a192;
   wire signed [15:0] t93;
   wire signed [15:0] t94;
   wire signed [15:0] t95;
   wire signed [15:0] t96;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a189 = X0;
   assign a190 = X2;
   assign a191 = X1;
   assign a192 = X3;
   assign Y0 = t93;
   assign Y1 = t94;
   assign Y2 = t95;
   assign Y3 = t96;

    addfxp #(16, 1) add31201(.a(a189), .b(a190), .clk(clk), .q(t93));    // 0
    addfxp #(16, 1) add31216(.a(a191), .b(a192), .clk(clk), .q(t94));    // 0
    subfxp #(16, 1) sub31230(.a(a189), .b(a190), .clk(clk), .q(t95));    // 0
    subfxp #(16, 1) sub31244(.a(a191), .b(a192), .clk(clk), .q(t96));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 20
// Gap: 8
module rc31269(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm31267 instPerm33314(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet31267(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [2:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        3'd0: control <= 1'b1;
        3'd1: control <= 1'b1;
        3'd2: control <= 1'b1;
        3'd3: control <= 1'b1;
        3'd4: control <= 1'b0;
        3'd5: control <= 1'b0;
        3'd6: control <= 1'b0;
        3'd7: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 20
// Gap: 8
module perm31267(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 8;

   parameter addrbits = 3;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm11;
   assign tm11 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33319(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33320(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

shiftRegFIFO #(7, 1) shiftFIFO_33329(.X(next), .Y(next2), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33330(.X(next2), .Y(next3), .clk(clk));
shiftRegFIFO #(8, 1) shiftFIFO_33331(.X(next3), .Y(next4), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33332(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(7, 1) shiftFIFO_33335(.X(tm11), .Y(tm11_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33338(.X(tm11_d), .Y(tm11_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 3) shiftFIFO_33343(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm11_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd0 <= 4;
	     {1'd0,  3'd1}: s1rd0 <= 5;
	     {1'd0,  3'd2}: s1rd0 <= 6;
	     {1'd0,  3'd3}: s1rd0 <= 7;
	     {1'd0,  3'd4}: s1rd0 <= 0;
	     {1'd0,  3'd5}: s1rd0 <= 1;
	     {1'd0,  3'd6}: s1rd0 <= 2;
	     {1'd0,  3'd7}: s1rd0 <= 3;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm11_d, s1rdloc})
	     {1'd0,  3'd0}: s1rd1 <= 0;
	     {1'd0,  3'd1}: s1rd1 <= 1;
	     {1'd0,  3'd2}: s1rd1 <= 2;
	     {1'd0,  3'd3}: s1rd1 <= 3;
	     {1'd0,  3'd4}: s1rd1 <= 4;
	     {1'd0,  3'd5}: s1rd1 <= 5;
	     {1'd0,  3'd6}: s1rd1 <= 6;
	     {1'd0,  3'd7}: s1rd1 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet31267 sw(tm11_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm11_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr0 <= 4;
	      {1'd0, 3'd1}: s2wr0 <= 5;
	      {1'd0, 3'd2}: s2wr0 <= 6;
	      {1'd0, 3'd3}: s2wr0 <= 7;
	      {1'd0, 3'd4}: s2wr0 <= 0;
	      {1'd0, 3'd5}: s2wr0 <= 1;
	      {1'd0, 3'd6}: s2wr0 <= 2;
	      {1'd0, 3'd7}: s2wr0 <= 3;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm11_dd, writeCycle})
	      {1'd0, 3'd0}: s2wr1 <= 0;
	      {1'd0, 3'd1}: s2wr1 <= 1;
	      {1'd0, 3'd2}: s2wr1 <= 2;
	      {1'd0, 3'd3}: s2wr1 <= 3;
	      {1'd0, 3'd4}: s2wr1 <= 4;
	      {1'd0, 3'd5}: s2wr1 <= 5;
	      {1'd0, 3'd6}: s2wr1 <= 6;
	      {1'd0, 3'd7}: s2wr1 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 8
// Gap: 8
module DirSum_31472(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [2:0] i3;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i3 <= 0;
      end
      else begin
         if (next == 1)
            i3 <= 0;
         else if (i3 == 7)
            i3 <= 0;
         else
            i3 <= i3 + 1;
      end
   end

   codeBlock31272 codeBlockIsnt33344(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i3_in(i3),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D10_31450(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h3b21;
      2: out3 <= 16'h2d41;
      3: out3 <= 16'h187e;
      4: out3 <= 16'h0;
      5: out3 <= 16'he782;
      6: out3 <= 16'hd2bf;
      7: out3 <= 16'hc4df;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D12_31470(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'he782;
      2: out3 <= 16'hd2bf;
      3: out3 <= 16'hc4df;
      4: out3 <= 16'hc000;
      5: out3 <= 16'hc4df;
      6: out3 <= 16'hd2bf;
      7: out3 <= 16'he782;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock31272(clk, reset, next_in, next_out,
   i3_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [2:0] i3_in;
   reg [2:0] i3;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_33347(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a173;
   wire signed [15:0] a162;
   wire signed [15:0] a176;
   wire signed [15:0] a166;
   wire signed [15:0] a177;
   wire signed [15:0] a178;
   reg signed [15:0] tm197;
   reg signed [15:0] tm201;
   reg signed [15:0] tm213;
   reg signed [15:0] tm220;
   reg signed [15:0] tm198;
   reg signed [15:0] tm202;
   reg signed [15:0] tm214;
   reg signed [15:0] tm221;
   wire signed [15:0] tm14;
   wire signed [15:0] a167;
   wire signed [15:0] tm15;
   wire signed [15:0] a169;
   reg signed [15:0] tm199;
   reg signed [15:0] tm203;
   reg signed [15:0] tm215;
   reg signed [15:0] tm222;
   reg signed [15:0] tm47;
   reg signed [15:0] tm48;
   reg signed [15:0] tm200;
   reg signed [15:0] tm204;
   reg signed [15:0] tm216;
   reg signed [15:0] tm223;
   reg signed [15:0] tm217;
   reg signed [15:0] tm224;
   wire signed [15:0] a168;
   wire signed [15:0] a170;
   wire signed [15:0] a171;
   wire signed [15:0] a172;
   reg signed [15:0] tm218;
   reg signed [15:0] tm225;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   reg signed [15:0] tm219;
   reg signed [15:0] tm226;


   assign a173 = X0;
   assign a162 = a173;
   assign a176 = X1;
   assign a166 = a176;
   assign a177 = X2;
   assign a178 = X3;
   assign a167 = tm14;
   assign a169 = tm15;
   assign Y0 = tm219;
   assign Y1 = tm226;

   D10_31450 instD10inst0_31450(.addr(i3[2:0]), .out(tm14), .clk(clk));

   D12_31470 instD12inst0_31470(.addr(i3[2:0]), .out(tm15), .clk(clk));

    multfix #(16, 2) m31370(.a(tm47), .b(tm200), .clk(clk), .q_sc(a168), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31392(.a(tm48), .b(tm204), .clk(clk), .q_sc(a170), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31409(.a(tm48), .b(tm200), .clk(clk), .q_sc(a171), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31420(.a(tm47), .b(tm204), .clk(clk), .q_sc(a172), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub31398(.a(a168), .b(a170), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add31427(.a(a171), .b(a172), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm47 <= 0;
         tm200 <= 0;
         tm48 <= 0;
         tm204 <= 0;
         tm48 <= 0;
         tm200 <= 0;
         tm47 <= 0;
         tm204 <= 0;
      end
      else begin
         i3 <= i3_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm197 <= a177;
         tm201 <= a178;
         tm213 <= a162;
         tm220 <= a166;
         tm198 <= tm197;
         tm202 <= tm201;
         tm214 <= tm213;
         tm221 <= tm220;
         tm199 <= tm198;
         tm203 <= tm202;
         tm215 <= tm214;
         tm222 <= tm221;
         tm47 <= a167;
         tm48 <= a169;
         tm200 <= tm199;
         tm204 <= tm203;
         tm216 <= tm215;
         tm223 <= tm222;
         tm217 <= tm216;
         tm224 <= tm223;
         tm218 <= tm217;
         tm225 <= tm224;
         tm219 <= tm218;
         tm226 <= tm225;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock31475(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33350(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a129;
   wire signed [15:0] a130;
   wire signed [15:0] a131;
   wire signed [15:0] a132;
   wire signed [15:0] t69;
   wire signed [15:0] t70;
   wire signed [15:0] t71;
   wire signed [15:0] t72;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a129 = X0;
   assign a130 = X2;
   assign a131 = X1;
   assign a132 = X3;
   assign Y0 = t69;
   assign Y1 = t70;
   assign Y2 = t71;
   assign Y3 = t72;

    addfxp #(16, 1) add31487(.a(a129), .b(a130), .clk(clk), .q(t69));    // 0
    addfxp #(16, 1) add31502(.a(a131), .b(a132), .clk(clk), .q(t70));    // 0
    subfxp #(16, 1) sub31516(.a(a129), .b(a130), .clk(clk), .q(t71));    // 0
    subfxp #(16, 1) sub31530(.a(a131), .b(a132), .clk(clk), .q(t72));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 36
// Gap: 16
module rc31555(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm31553 instPerm33351(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet31553(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [3:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        4'd0: control <= 1'b1;
        4'd1: control <= 1'b1;
        4'd2: control <= 1'b1;
        4'd3: control <= 1'b1;
        4'd4: control <= 1'b1;
        4'd5: control <= 1'b1;
        4'd6: control <= 1'b1;
        4'd7: control <= 1'b1;
        4'd8: control <= 1'b0;
        4'd9: control <= 1'b0;
        4'd10: control <= 1'b0;
        4'd11: control <= 1'b0;
        4'd12: control <= 1'b0;
        4'd13: control <= 1'b0;
        4'd14: control <= 1'b0;
        4'd15: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 36
// Gap: 16
module perm31553(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 16;

   parameter addrbits = 4;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm16;
   assign tm16 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33356(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33357(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

nextReg #(15, 4) nextReg_33368(.X(next), .Y(next2), .reset(reset), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33369(.X(next2), .Y(next3), .clk(clk));
nextReg #(16, 4) nextReg_33372(.X(next3), .Y(next4), .reset(reset), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33373(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(15, 1) shiftFIFO_33376(.X(tm16), .Y(tm16_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33379(.X(tm16_d), .Y(tm16_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 4) shiftFIFO_33384(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm16_d, s1rdloc})
	     {1'd0,  4'd0}: s1rd0 <= 8;
	     {1'd0,  4'd1}: s1rd0 <= 9;
	     {1'd0,  4'd2}: s1rd0 <= 10;
	     {1'd0,  4'd3}: s1rd0 <= 11;
	     {1'd0,  4'd4}: s1rd0 <= 12;
	     {1'd0,  4'd5}: s1rd0 <= 13;
	     {1'd0,  4'd6}: s1rd0 <= 14;
	     {1'd0,  4'd7}: s1rd0 <= 15;
	     {1'd0,  4'd8}: s1rd0 <= 0;
	     {1'd0,  4'd9}: s1rd0 <= 1;
	     {1'd0,  4'd10}: s1rd0 <= 2;
	     {1'd0,  4'd11}: s1rd0 <= 3;
	     {1'd0,  4'd12}: s1rd0 <= 4;
	     {1'd0,  4'd13}: s1rd0 <= 5;
	     {1'd0,  4'd14}: s1rd0 <= 6;
	     {1'd0,  4'd15}: s1rd0 <= 7;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm16_d, s1rdloc})
	     {1'd0,  4'd0}: s1rd1 <= 0;
	     {1'd0,  4'd1}: s1rd1 <= 1;
	     {1'd0,  4'd2}: s1rd1 <= 2;
	     {1'd0,  4'd3}: s1rd1 <= 3;
	     {1'd0,  4'd4}: s1rd1 <= 4;
	     {1'd0,  4'd5}: s1rd1 <= 5;
	     {1'd0,  4'd6}: s1rd1 <= 6;
	     {1'd0,  4'd7}: s1rd1 <= 7;
	     {1'd0,  4'd8}: s1rd1 <= 8;
	     {1'd0,  4'd9}: s1rd1 <= 9;
	     {1'd0,  4'd10}: s1rd1 <= 10;
	     {1'd0,  4'd11}: s1rd1 <= 11;
	     {1'd0,  4'd12}: s1rd1 <= 12;
	     {1'd0,  4'd13}: s1rd1 <= 13;
	     {1'd0,  4'd14}: s1rd1 <= 14;
	     {1'd0,  4'd15}: s1rd1 <= 15;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet31553 sw(tm16_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm16_dd, writeCycle})
	      {1'd0, 4'd0}: s2wr0 <= 8;
	      {1'd0, 4'd1}: s2wr0 <= 9;
	      {1'd0, 4'd2}: s2wr0 <= 10;
	      {1'd0, 4'd3}: s2wr0 <= 11;
	      {1'd0, 4'd4}: s2wr0 <= 12;
	      {1'd0, 4'd5}: s2wr0 <= 13;
	      {1'd0, 4'd6}: s2wr0 <= 14;
	      {1'd0, 4'd7}: s2wr0 <= 15;
	      {1'd0, 4'd8}: s2wr0 <= 0;
	      {1'd0, 4'd9}: s2wr0 <= 1;
	      {1'd0, 4'd10}: s2wr0 <= 2;
	      {1'd0, 4'd11}: s2wr0 <= 3;
	      {1'd0, 4'd12}: s2wr0 <= 4;
	      {1'd0, 4'd13}: s2wr0 <= 5;
	      {1'd0, 4'd14}: s2wr0 <= 6;
	      {1'd0, 4'd15}: s2wr0 <= 7;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm16_dd, writeCycle})
	      {1'd0, 4'd0}: s2wr1 <= 0;
	      {1'd0, 4'd1}: s2wr1 <= 1;
	      {1'd0, 4'd2}: s2wr1 <= 2;
	      {1'd0, 4'd3}: s2wr1 <= 3;
	      {1'd0, 4'd4}: s2wr1 <= 4;
	      {1'd0, 4'd5}: s2wr1 <= 5;
	      {1'd0, 4'd6}: s2wr1 <= 6;
	      {1'd0, 4'd7}: s2wr1 <= 7;
	      {1'd0, 4'd8}: s2wr1 <= 8;
	      {1'd0, 4'd9}: s2wr1 <= 9;
	      {1'd0, 4'd10}: s2wr1 <= 10;
	      {1'd0, 4'd11}: s2wr1 <= 11;
	      {1'd0, 4'd12}: s2wr1 <= 12;
	      {1'd0, 4'd13}: s2wr1 <= 13;
	      {1'd0, 4'd14}: s2wr1 <= 14;
	      {1'd0, 4'd15}: s2wr1 <= 15;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 8
// Gap: 16
module DirSum_31790(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [3:0] i2;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i2 <= 0;
      end
      else begin
         if (next == 1)
            i2 <= 0;
         else if (i2 == 15)
            i2 <= 0;
         else
            i2 <= i2 + 1;
      end
   end

   codeBlock31558 codeBlockIsnt33389(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i2_in(i2),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D6_31752(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h3ec5;
      2: out3 <= 16'h3b21;
      3: out3 <= 16'h3537;
      4: out3 <= 16'h2d41;
      5: out3 <= 16'h238e;
      6: out3 <= 16'h187e;
      7: out3 <= 16'hc7c;
      8: out3 <= 16'h0;
      9: out3 <= 16'hf384;
      10: out3 <= 16'he782;
      11: out3 <= 16'hdc72;
      12: out3 <= 16'hd2bf;
      13: out3 <= 16'hcac9;
      14: out3 <= 16'hc4df;
      15: out3 <= 16'hc13b;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D8_31788(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hf384;
      2: out3 <= 16'he782;
      3: out3 <= 16'hdc72;
      4: out3 <= 16'hd2bf;
      5: out3 <= 16'hcac9;
      6: out3 <= 16'hc4df;
      7: out3 <= 16'hc13b;
      8: out3 <= 16'hc000;
      9: out3 <= 16'hc13b;
      10: out3 <= 16'hc4df;
      11: out3 <= 16'hcac9;
      12: out3 <= 16'hd2bf;
      13: out3 <= 16'hdc72;
      14: out3 <= 16'he782;
      15: out3 <= 16'hf384;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock31558(clk, reset, next_in, next_out,
   i2_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [3:0] i2_in;
   reg [3:0] i2;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_33392(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a113;
   wire signed [15:0] a102;
   wire signed [15:0] a116;
   wire signed [15:0] a106;
   wire signed [15:0] a117;
   wire signed [15:0] a118;
   reg signed [15:0] tm227;
   reg signed [15:0] tm231;
   reg signed [15:0] tm243;
   reg signed [15:0] tm250;
   reg signed [15:0] tm228;
   reg signed [15:0] tm232;
   reg signed [15:0] tm244;
   reg signed [15:0] tm251;
   wire signed [15:0] tm19;
   wire signed [15:0] a107;
   wire signed [15:0] tm20;
   wire signed [15:0] a109;
   reg signed [15:0] tm229;
   reg signed [15:0] tm233;
   reg signed [15:0] tm245;
   reg signed [15:0] tm252;
   reg signed [15:0] tm55;
   reg signed [15:0] tm56;
   reg signed [15:0] tm230;
   reg signed [15:0] tm234;
   reg signed [15:0] tm246;
   reg signed [15:0] tm253;
   reg signed [15:0] tm247;
   reg signed [15:0] tm254;
   wire signed [15:0] a108;
   wire signed [15:0] a110;
   wire signed [15:0] a111;
   wire signed [15:0] a112;
   reg signed [15:0] tm248;
   reg signed [15:0] tm255;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   reg signed [15:0] tm249;
   reg signed [15:0] tm256;


   assign a113 = X0;
   assign a102 = a113;
   assign a116 = X1;
   assign a106 = a116;
   assign a117 = X2;
   assign a118 = X3;
   assign a107 = tm19;
   assign a109 = tm20;
   assign Y0 = tm249;
   assign Y1 = tm256;

   D6_31752 instD6inst0_31752(.addr(i2[3:0]), .out(tm19), .clk(clk));

   D8_31788 instD8inst0_31788(.addr(i2[3:0]), .out(tm20), .clk(clk));

    multfix #(16, 2) m31656(.a(tm55), .b(tm230), .clk(clk), .q_sc(a108), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31678(.a(tm56), .b(tm234), .clk(clk), .q_sc(a110), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31695(.a(tm56), .b(tm230), .clk(clk), .q_sc(a111), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31706(.a(tm55), .b(tm234), .clk(clk), .q_sc(a112), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub31684(.a(a108), .b(a110), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add31713(.a(a111), .b(a112), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm55 <= 0;
         tm230 <= 0;
         tm56 <= 0;
         tm234 <= 0;
         tm56 <= 0;
         tm230 <= 0;
         tm55 <= 0;
         tm234 <= 0;
      end
      else begin
         i2 <= i2_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm227 <= a117;
         tm231 <= a118;
         tm243 <= a102;
         tm250 <= a106;
         tm228 <= tm227;
         tm232 <= tm231;
         tm244 <= tm243;
         tm251 <= tm250;
         tm229 <= tm228;
         tm233 <= tm232;
         tm245 <= tm244;
         tm252 <= tm251;
         tm55 <= a107;
         tm56 <= a109;
         tm230 <= tm229;
         tm234 <= tm233;
         tm246 <= tm245;
         tm253 <= tm252;
         tm247 <= tm246;
         tm254 <= tm253;
         tm248 <= tm247;
         tm255 <= tm254;
         tm249 <= tm248;
         tm256 <= tm255;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock31793(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33395(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a69;
   wire signed [15:0] a70;
   wire signed [15:0] a71;
   wire signed [15:0] a72;
   wire signed [15:0] t45;
   wire signed [15:0] t46;
   wire signed [15:0] t47;
   wire signed [15:0] t48;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a69 = X0;
   assign a70 = X2;
   assign a71 = X1;
   assign a72 = X3;
   assign Y0 = t45;
   assign Y1 = t46;
   assign Y2 = t47;
   assign Y3 = t48;

    addfxp #(16, 1) add31805(.a(a69), .b(a70), .clk(clk), .q(t45));    // 0
    addfxp #(16, 1) add31820(.a(a71), .b(a72), .clk(clk), .q(t46));    // 0
    subfxp #(16, 1) sub31834(.a(a69), .b(a70), .clk(clk), .q(t47));    // 0
    subfxp #(16, 1) sub31848(.a(a71), .b(a72), .clk(clk), .q(t48));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 68
// Gap: 32
module rc31873(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm31871 instPerm33396(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet31871(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [4:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        5'd0: control <= 1'b1;
        5'd1: control <= 1'b1;
        5'd2: control <= 1'b1;
        5'd3: control <= 1'b1;
        5'd4: control <= 1'b1;
        5'd5: control <= 1'b1;
        5'd6: control <= 1'b1;
        5'd7: control <= 1'b1;
        5'd8: control <= 1'b1;
        5'd9: control <= 1'b1;
        5'd10: control <= 1'b1;
        5'd11: control <= 1'b1;
        5'd12: control <= 1'b1;
        5'd13: control <= 1'b1;
        5'd14: control <= 1'b1;
        5'd15: control <= 1'b1;
        5'd16: control <= 1'b0;
        5'd17: control <= 1'b0;
        5'd18: control <= 1'b0;
        5'd19: control <= 1'b0;
        5'd20: control <= 1'b0;
        5'd21: control <= 1'b0;
        5'd22: control <= 1'b0;
        5'd23: control <= 1'b0;
        5'd24: control <= 1'b0;
        5'd25: control <= 1'b0;
        5'd26: control <= 1'b0;
        5'd27: control <= 1'b0;
        5'd28: control <= 1'b0;
        5'd29: control <= 1'b0;
        5'd30: control <= 1'b0;
        5'd31: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 68
// Gap: 32
module perm31871(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 32;

   parameter addrbits = 5;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm21;
   assign tm21 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33401(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33402(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

nextReg #(31, 5) nextReg_33413(.X(next), .Y(next2), .reset(reset), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33414(.X(next2), .Y(next3), .clk(clk));
nextReg #(32, 5) nextReg_33417(.X(next3), .Y(next4), .reset(reset), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33418(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(31, 1) shiftFIFO_33421(.X(tm21), .Y(tm21_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33424(.X(tm21_d), .Y(tm21_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 5) shiftFIFO_33429(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm21_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd0 <= 16;
	     {1'd0,  5'd1}: s1rd0 <= 17;
	     {1'd0,  5'd2}: s1rd0 <= 18;
	     {1'd0,  5'd3}: s1rd0 <= 19;
	     {1'd0,  5'd4}: s1rd0 <= 20;
	     {1'd0,  5'd5}: s1rd0 <= 21;
	     {1'd0,  5'd6}: s1rd0 <= 22;
	     {1'd0,  5'd7}: s1rd0 <= 23;
	     {1'd0,  5'd8}: s1rd0 <= 24;
	     {1'd0,  5'd9}: s1rd0 <= 25;
	     {1'd0,  5'd10}: s1rd0 <= 26;
	     {1'd0,  5'd11}: s1rd0 <= 27;
	     {1'd0,  5'd12}: s1rd0 <= 28;
	     {1'd0,  5'd13}: s1rd0 <= 29;
	     {1'd0,  5'd14}: s1rd0 <= 30;
	     {1'd0,  5'd15}: s1rd0 <= 31;
	     {1'd0,  5'd16}: s1rd0 <= 0;
	     {1'd0,  5'd17}: s1rd0 <= 1;
	     {1'd0,  5'd18}: s1rd0 <= 2;
	     {1'd0,  5'd19}: s1rd0 <= 3;
	     {1'd0,  5'd20}: s1rd0 <= 4;
	     {1'd0,  5'd21}: s1rd0 <= 5;
	     {1'd0,  5'd22}: s1rd0 <= 6;
	     {1'd0,  5'd23}: s1rd0 <= 7;
	     {1'd0,  5'd24}: s1rd0 <= 8;
	     {1'd0,  5'd25}: s1rd0 <= 9;
	     {1'd0,  5'd26}: s1rd0 <= 10;
	     {1'd0,  5'd27}: s1rd0 <= 11;
	     {1'd0,  5'd28}: s1rd0 <= 12;
	     {1'd0,  5'd29}: s1rd0 <= 13;
	     {1'd0,  5'd30}: s1rd0 <= 14;
	     {1'd0,  5'd31}: s1rd0 <= 15;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm21_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd1 <= 0;
	     {1'd0,  5'd1}: s1rd1 <= 1;
	     {1'd0,  5'd2}: s1rd1 <= 2;
	     {1'd0,  5'd3}: s1rd1 <= 3;
	     {1'd0,  5'd4}: s1rd1 <= 4;
	     {1'd0,  5'd5}: s1rd1 <= 5;
	     {1'd0,  5'd6}: s1rd1 <= 6;
	     {1'd0,  5'd7}: s1rd1 <= 7;
	     {1'd0,  5'd8}: s1rd1 <= 8;
	     {1'd0,  5'd9}: s1rd1 <= 9;
	     {1'd0,  5'd10}: s1rd1 <= 10;
	     {1'd0,  5'd11}: s1rd1 <= 11;
	     {1'd0,  5'd12}: s1rd1 <= 12;
	     {1'd0,  5'd13}: s1rd1 <= 13;
	     {1'd0,  5'd14}: s1rd1 <= 14;
	     {1'd0,  5'd15}: s1rd1 <= 15;
	     {1'd0,  5'd16}: s1rd1 <= 16;
	     {1'd0,  5'd17}: s1rd1 <= 17;
	     {1'd0,  5'd18}: s1rd1 <= 18;
	     {1'd0,  5'd19}: s1rd1 <= 19;
	     {1'd0,  5'd20}: s1rd1 <= 20;
	     {1'd0,  5'd21}: s1rd1 <= 21;
	     {1'd0,  5'd22}: s1rd1 <= 22;
	     {1'd0,  5'd23}: s1rd1 <= 23;
	     {1'd0,  5'd24}: s1rd1 <= 24;
	     {1'd0,  5'd25}: s1rd1 <= 25;
	     {1'd0,  5'd26}: s1rd1 <= 26;
	     {1'd0,  5'd27}: s1rd1 <= 27;
	     {1'd0,  5'd28}: s1rd1 <= 28;
	     {1'd0,  5'd29}: s1rd1 <= 29;
	     {1'd0,  5'd30}: s1rd1 <= 30;
	     {1'd0,  5'd31}: s1rd1 <= 31;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet31871 sw(tm21_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm21_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr0 <= 16;
	      {1'd0, 5'd1}: s2wr0 <= 17;
	      {1'd0, 5'd2}: s2wr0 <= 18;
	      {1'd0, 5'd3}: s2wr0 <= 19;
	      {1'd0, 5'd4}: s2wr0 <= 20;
	      {1'd0, 5'd5}: s2wr0 <= 21;
	      {1'd0, 5'd6}: s2wr0 <= 22;
	      {1'd0, 5'd7}: s2wr0 <= 23;
	      {1'd0, 5'd8}: s2wr0 <= 24;
	      {1'd0, 5'd9}: s2wr0 <= 25;
	      {1'd0, 5'd10}: s2wr0 <= 26;
	      {1'd0, 5'd11}: s2wr0 <= 27;
	      {1'd0, 5'd12}: s2wr0 <= 28;
	      {1'd0, 5'd13}: s2wr0 <= 29;
	      {1'd0, 5'd14}: s2wr0 <= 30;
	      {1'd0, 5'd15}: s2wr0 <= 31;
	      {1'd0, 5'd16}: s2wr0 <= 0;
	      {1'd0, 5'd17}: s2wr0 <= 1;
	      {1'd0, 5'd18}: s2wr0 <= 2;
	      {1'd0, 5'd19}: s2wr0 <= 3;
	      {1'd0, 5'd20}: s2wr0 <= 4;
	      {1'd0, 5'd21}: s2wr0 <= 5;
	      {1'd0, 5'd22}: s2wr0 <= 6;
	      {1'd0, 5'd23}: s2wr0 <= 7;
	      {1'd0, 5'd24}: s2wr0 <= 8;
	      {1'd0, 5'd25}: s2wr0 <= 9;
	      {1'd0, 5'd26}: s2wr0 <= 10;
	      {1'd0, 5'd27}: s2wr0 <= 11;
	      {1'd0, 5'd28}: s2wr0 <= 12;
	      {1'd0, 5'd29}: s2wr0 <= 13;
	      {1'd0, 5'd30}: s2wr0 <= 14;
	      {1'd0, 5'd31}: s2wr0 <= 15;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm21_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr1 <= 0;
	      {1'd0, 5'd1}: s2wr1 <= 1;
	      {1'd0, 5'd2}: s2wr1 <= 2;
	      {1'd0, 5'd3}: s2wr1 <= 3;
	      {1'd0, 5'd4}: s2wr1 <= 4;
	      {1'd0, 5'd5}: s2wr1 <= 5;
	      {1'd0, 5'd6}: s2wr1 <= 6;
	      {1'd0, 5'd7}: s2wr1 <= 7;
	      {1'd0, 5'd8}: s2wr1 <= 8;
	      {1'd0, 5'd9}: s2wr1 <= 9;
	      {1'd0, 5'd10}: s2wr1 <= 10;
	      {1'd0, 5'd11}: s2wr1 <= 11;
	      {1'd0, 5'd12}: s2wr1 <= 12;
	      {1'd0, 5'd13}: s2wr1 <= 13;
	      {1'd0, 5'd14}: s2wr1 <= 14;
	      {1'd0, 5'd15}: s2wr1 <= 15;
	      {1'd0, 5'd16}: s2wr1 <= 16;
	      {1'd0, 5'd17}: s2wr1 <= 17;
	      {1'd0, 5'd18}: s2wr1 <= 18;
	      {1'd0, 5'd19}: s2wr1 <= 19;
	      {1'd0, 5'd20}: s2wr1 <= 20;
	      {1'd0, 5'd21}: s2wr1 <= 21;
	      {1'd0, 5'd22}: s2wr1 <= 22;
	      {1'd0, 5'd23}: s2wr1 <= 23;
	      {1'd0, 5'd24}: s2wr1 <= 24;
	      {1'd0, 5'd25}: s2wr1 <= 25;
	      {1'd0, 5'd26}: s2wr1 <= 26;
	      {1'd0, 5'd27}: s2wr1 <= 27;
	      {1'd0, 5'd28}: s2wr1 <= 28;
	      {1'd0, 5'd29}: s2wr1 <= 29;
	      {1'd0, 5'd30}: s2wr1 <= 30;
	      {1'd0, 5'd31}: s2wr1 <= 31;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule


// Latency: 8
// Gap: 32
module DirSum_32171(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [4:0] i1;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i1 <= 0;
      end
      else begin
         if (next == 1)
            i1 <= 0;
         else if (i1 == 31)
            i1 <= 0;
         else
            i1 <= i1 + 1;
      end
   end

   codeBlock31875 codeBlockIsnt33434(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i1_in(i1),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D2_32101(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h4000;
      1: out3 <= 16'h3fb1;
      2: out3 <= 16'h3ec5;
      3: out3 <= 16'h3d3f;
      4: out3 <= 16'h3b21;
      5: out3 <= 16'h3871;
      6: out3 <= 16'h3537;
      7: out3 <= 16'h3179;
      8: out3 <= 16'h2d41;
      9: out3 <= 16'h289a;
      10: out3 <= 16'h238e;
      11: out3 <= 16'h1e2b;
      12: out3 <= 16'h187e;
      13: out3 <= 16'h1294;
      14: out3 <= 16'hc7c;
      15: out3 <= 16'h646;
      16: out3 <= 16'h0;
      17: out3 <= 16'hf9ba;
      18: out3 <= 16'hf384;
      19: out3 <= 16'hed6c;
      20: out3 <= 16'he782;
      21: out3 <= 16'he1d5;
      22: out3 <= 16'hdc72;
      23: out3 <= 16'hd766;
      24: out3 <= 16'hd2bf;
      25: out3 <= 16'hce87;
      26: out3 <= 16'hcac9;
      27: out3 <= 16'hc78f;
      28: out3 <= 16'hc4df;
      29: out3 <= 16'hc2c1;
      30: out3 <= 16'hc13b;
      31: out3 <= 16'hc04f;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D4_32169(addr, out, clk);
   input clk;
   output [15:0] out;
   reg [15:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 16'h0;
      1: out3 <= 16'hf9ba;
      2: out3 <= 16'hf384;
      3: out3 <= 16'hed6c;
      4: out3 <= 16'he782;
      5: out3 <= 16'he1d5;
      6: out3 <= 16'hdc72;
      7: out3 <= 16'hd766;
      8: out3 <= 16'hd2bf;
      9: out3 <= 16'hce87;
      10: out3 <= 16'hcac9;
      11: out3 <= 16'hc78f;
      12: out3 <= 16'hc4df;
      13: out3 <= 16'hc2c1;
      14: out3 <= 16'hc13b;
      15: out3 <= 16'hc04f;
      16: out3 <= 16'hc000;
      17: out3 <= 16'hc04f;
      18: out3 <= 16'hc13b;
      19: out3 <= 16'hc2c1;
      20: out3 <= 16'hc4df;
      21: out3 <= 16'hc78f;
      22: out3 <= 16'hcac9;
      23: out3 <= 16'hce87;
      24: out3 <= 16'hd2bf;
      25: out3 <= 16'hd766;
      26: out3 <= 16'hdc72;
      27: out3 <= 16'he1d5;
      28: out3 <= 16'he782;
      29: out3 <= 16'hed6c;
      30: out3 <= 16'hf384;
      31: out3 <= 16'hf9ba;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



// Latency: 8
// Gap: 1
module codeBlock31875(clk, reset, next_in, next_out,
   i1_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [4:0] i1_in;
   reg [4:0] i1;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_33437(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a53;
   wire signed [15:0] a42;
   wire signed [15:0] a56;
   wire signed [15:0] a46;
   wire signed [15:0] a57;
   wire signed [15:0] a58;
   reg signed [15:0] tm257;
   reg signed [15:0] tm261;
   reg signed [15:0] tm273;
   reg signed [15:0] tm280;
   reg signed [15:0] tm258;
   reg signed [15:0] tm262;
   reg signed [15:0] tm274;
   reg signed [15:0] tm281;
   wire signed [15:0] tm24;
   wire signed [15:0] a47;
   wire signed [15:0] tm25;
   wire signed [15:0] a49;
   reg signed [15:0] tm259;
   reg signed [15:0] tm263;
   reg signed [15:0] tm275;
   reg signed [15:0] tm282;
   reg signed [15:0] tm63;
   reg signed [15:0] tm64;
   reg signed [15:0] tm260;
   reg signed [15:0] tm264;
   reg signed [15:0] tm276;
   reg signed [15:0] tm283;
   reg signed [15:0] tm277;
   reg signed [15:0] tm284;
   wire signed [15:0] a48;
   wire signed [15:0] a50;
   wire signed [15:0] a51;
   wire signed [15:0] a52;
   reg signed [15:0] tm278;
   reg signed [15:0] tm285;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;
   reg signed [15:0] tm279;
   reg signed [15:0] tm286;


   assign a53 = X0;
   assign a42 = a53;
   assign a56 = X1;
   assign a46 = a56;
   assign a57 = X2;
   assign a58 = X3;
   assign a47 = tm24;
   assign a49 = tm25;
   assign Y0 = tm279;
   assign Y1 = tm286;

   D2_32101 instD2inst0_32101(.addr(i1[4:0]), .out(tm24), .clk(clk));

   D4_32169 instD4inst0_32169(.addr(i1[4:0]), .out(tm25), .clk(clk));

    multfix #(16, 2) m31973(.a(tm63), .b(tm260), .clk(clk), .q_sc(a48), .q_unsc(), .rst(reset));
    multfix #(16, 2) m31995(.a(tm64), .b(tm264), .clk(clk), .q_sc(a50), .q_unsc(), .rst(reset));
    multfix #(16, 2) m32012(.a(tm64), .b(tm260), .clk(clk), .q_sc(a51), .q_unsc(), .rst(reset));
    multfix #(16, 2) m32023(.a(tm63), .b(tm264), .clk(clk), .q_sc(a52), .q_unsc(), .rst(reset));
    subfxp #(16, 1) sub32001(.a(a48), .b(a50), .clk(clk), .q(Y2));    // 6
    addfxp #(16, 1) add32030(.a(a51), .b(a52), .clk(clk), .q(Y3));    // 6


   always @(posedge clk) begin
      if (reset == 1) begin
         tm63 <= 0;
         tm260 <= 0;
         tm64 <= 0;
         tm264 <= 0;
         tm64 <= 0;
         tm260 <= 0;
         tm63 <= 0;
         tm264 <= 0;
      end
      else begin
         i1 <= i1_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm257 <= a57;
         tm261 <= a58;
         tm273 <= a42;
         tm280 <= a46;
         tm258 <= tm257;
         tm262 <= tm261;
         tm274 <= tm273;
         tm281 <= tm280;
         tm259 <= tm258;
         tm263 <= tm262;
         tm275 <= tm274;
         tm282 <= tm281;
         tm63 <= a47;
         tm64 <= a49;
         tm260 <= tm259;
         tm264 <= tm263;
         tm276 <= tm275;
         tm283 <= tm282;
         tm277 <= tm276;
         tm284 <= tm283;
         tm278 <= tm277;
         tm285 <= tm284;
         tm279 <= tm278;
         tm286 <= tm285;
      end
   end
endmodule

// Latency: 2
// Gap: 1
module codeBlock32174(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [15:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_33440(.X(next), .Y(next_out), .clk(clk));


   wire signed [15:0] a9;
   wire signed [15:0] a10;
   wire signed [15:0] a11;
   wire signed [15:0] a12;
   wire signed [15:0] t21;
   wire signed [15:0] t22;
   wire signed [15:0] t23;
   wire signed [15:0] t24;
   wire signed [15:0] Y0;
   wire signed [15:0] Y1;
   wire signed [15:0] Y2;
   wire signed [15:0] Y3;


   assign a9 = X0;
   assign a10 = X2;
   assign a11 = X1;
   assign a12 = X3;
   assign Y0 = t21;
   assign Y1 = t22;
   assign Y2 = t23;
   assign Y3 = t24;

    addfxp #(16, 1) add32186(.a(a9), .b(a10), .clk(clk), .q(t21));    // 0
    addfxp #(16, 1) add32201(.a(a11), .b(a12), .clk(clk), .q(t22));    // 0
    subfxp #(16, 1) sub32215(.a(a9), .b(a10), .clk(clk), .q(t23));    // 0
    subfxp #(16, 1) sub32229(.a(a11), .b(a12), .clk(clk), .q(t24));    // 0


   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

// Latency: 68
// Gap: 32
module rc32254(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [15:0] X0,
      X1,
      X2,
      X3;

   output [15:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [31:0] t0;
   wire [31:0] s0;
   assign t0 = {X0, X1};
   wire [31:0] t1;
   wire [31:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[31:16];
   assign Y1 = s0[15:0];
   assign Y2 = s1[31:16];
   assign Y3 = s1[15:0];

   perm32252 instPerm33441(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module swNet32252(itr, clk, ct
,       x0, y0
,       x1, y1
);

    parameter width = 32;

    input [4:0] ct;
    input clk;
    input [0:0] itr;
    input [width-1:0] x0;
    output reg [width-1:0] y0;
    input [width-1:0] x1;
    output reg [width-1:0] y1;
    wire [width-1:0] t0_0, t0_1;
    reg [width-1:0] t1_0, t1_1;

    reg [0:0] control;

    always @(posedge clk) begin
      case(ct)
        5'd0: control <= 1'b1;
        5'd1: control <= 1'b1;
        5'd2: control <= 1'b1;
        5'd3: control <= 1'b1;
        5'd4: control <= 1'b1;
        5'd5: control <= 1'b1;
        5'd6: control <= 1'b1;
        5'd7: control <= 1'b1;
        5'd8: control <= 1'b1;
        5'd9: control <= 1'b1;
        5'd10: control <= 1'b1;
        5'd11: control <= 1'b1;
        5'd12: control <= 1'b1;
        5'd13: control <= 1'b1;
        5'd14: control <= 1'b1;
        5'd15: control <= 1'b1;
        5'd16: control <= 1'b0;
        5'd17: control <= 1'b0;
        5'd18: control <= 1'b0;
        5'd19: control <= 1'b0;
        5'd20: control <= 1'b0;
        5'd21: control <= 1'b0;
        5'd22: control <= 1'b0;
        5'd23: control <= 1'b0;
        5'd24: control <= 1'b0;
        5'd25: control <= 1'b0;
        5'd26: control <= 1'b0;
        5'd27: control <= 1'b0;
        5'd28: control <= 1'b0;
        5'd29: control <= 1'b0;
        5'd30: control <= 1'b0;
        5'd31: control <= 1'b0;
      endcase
   end

// synthesis attribute rom_style of control is "distributed"
   reg [0:0] control0;
    always @(posedge clk) begin
       control0 <= control;
    end
    assign t0_0 = x0;
    assign t0_1 = x1;
   always @(posedge clk) begin
         t1_0 <= (control0[0] == 0) ? t0_0 : t0_1;
         t1_1 <= (control0[0] == 0) ? t0_1 : t0_0;
   end
    always @(posedge clk) begin
        y0 <= t1_0;
        y1 <= t1_1;
    end
endmodule

// Latency: 68
// Gap: 32
module perm32252(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter width = 32;

   parameter depth = 32;

   parameter addrbits = 5;

   parameter muxbits = 1;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  t0;
   wire [width-1:0]  s0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  t1;
   wire [width-1:0]  s1;
   input next, reset, clk;
   output next_out;
   reg [addrbits-1:0] s1rdloc, s2rdloc;

    reg [addrbits-1:0] s1wr0;
   reg [addrbits-1:0] s1rd0, s2wr0, s2rd0;
   reg [addrbits-1:0] s1rd1, s2wr1, s2rd1;
   reg s1wr_en, state1, state2, state3;
   wire 	      next2, next3, next4;
   reg 		      inFlip0, outFlip0_z, outFlip1;
   wire 	      inFlip1, outFlip0;

   wire [0:0] tm26;
   assign tm26 = 0;

shiftRegFIFO #(3, 1) shiftFIFO_33446(.X(outFlip0), .Y(inFlip1), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33447(.X(outFlip0_z), .Y(outFlip0), .clk(clk));
//   shiftRegFIFO #(2, 1) inFlip1Reg(outFlip0, inFlip1, clk);
//   shiftRegFIFO #(1, 1) outFlip0Reg(outFlip0_z, outFlip0, clk);
   
   memMod_dist #(depth*2, width, addrbits+1) s1mem0(x0, t0, {inFlip0, s1wr0}, {outFlip0, s1rd0}, s1wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s1mem1(x1, t1, {inFlip0, s1wr0}, {outFlip0, s1rd1}, s1wr_en, clk);

nextReg #(31, 5) nextReg_33458(.X(next), .Y(next2), .reset(reset), .clk(clk));
shiftRegFIFO #(4, 1) shiftFIFO_33459(.X(next2), .Y(next3), .clk(clk));
nextReg #(32, 5) nextReg_33462(.X(next3), .Y(next4), .reset(reset), .clk(clk));
shiftRegFIFO #(1, 1) shiftFIFO_33463(.X(next4), .Y(next_out), .clk(clk));
shiftRegFIFO #(31, 1) shiftFIFO_33466(.X(tm26), .Y(tm26_d), .clk(clk));
shiftRegFIFO #(3, 1) shiftFIFO_33469(.X(tm26_d), .Y(tm26_dd), .clk(clk));
//   shiftRegFIFO #(depth-1, 1) n1(next, next2, clk);
//   shiftRegFIFO #(3, 1)       n2(next2, next3, clk);
//   shiftRegFIFO #(depth, 1)   n3(next3, next4, clk);
//   shiftRegFIFO #(1, 1)       n4(next4, next_out, clk);   
   
   wire [addrbits-1:0] 	      muxCycle, writeCycle;
assign muxCycle = s1rdloc;
shiftRegFIFO #(3, 5) shiftFIFO_33474(.X(muxCycle), .Y(writeCycle), .clk(clk));
        
   wire 		      readInt, s2wr_en;   
   assign 		      readInt = (state2 == 1);

   shiftRegFIFO #(4, 1) writeIntReg(readInt, s2wr_en, clk);

   memMod_dist #(depth*2, width, addrbits+1) s2mem0(s0, y0, {inFlip1, s2wr0}, {outFlip1, s2rdloc}, s2wr_en, clk);
   memMod_dist #(depth*2, width, addrbits+1) s2mem1(s1, y1, {inFlip1, s2wr1}, {outFlip1, s2rdloc}, s2wr_en, clk);
   always @(posedge clk) begin
      if (reset == 1) begin
	 state1 <= 0;
	 inFlip0 <= 0;	 
      end
      else if (next == 1) begin
	 s1wr0 <= 0;
	 state1 <= 1;
	 s1wr_en <= 1;
	 inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
      end
      else begin
	 case(state1)
	   0: begin
	      s1wr0 <= 0;
	      state1 <= 0;
	      s1wr_en <= 0;
	      inFlip0 <= inFlip0;	      
	   end
	   1: begin
	      s1wr0 <= (s1wr0 == depth-1) ? 0 : s1wr0 + 1;
	      state1 <= 1;
         s1wr_en <= 1;
	      inFlip0 <= (s1wr0 == depth-1) ? ~inFlip0 : inFlip0;
	   end
	 endcase
      end      
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	       state2 <= 0;
	       outFlip0_z <= 0;	 
      end
      else if (next2 == 1) begin
	       s1rdloc <= 0;
	       state2 <= 1;
	       outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
      end
      else begin
	 case(state2)
	   0: begin
	      s1rdloc <= 0;
	      state2 <= 0;
	      outFlip0_z <= outFlip0_z;	 
	   end
	   1: begin
	      s1rdloc <= (s1rdloc == depth-1) ? 0 : s1rdloc + 1;
         state2 <= 1;
	      outFlip0_z <= (s1rdloc == depth-1) ? ~outFlip0_z : outFlip0_z;
	   end	     
	 endcase
      end
   end
   
   always @(posedge clk) begin
      if (reset == 1) begin
	 state3 <= 0;
	 outFlip1 <= 0;	 
      end
      else if (next4 == 1) begin
	 s2rdloc <= 0;
	 state3 <= 1;
	 outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;	      
      end
      else begin
	 case(state3)
	   0: begin
	      s2rdloc <= 0;
	      state3 <= 0;
	      outFlip1 <= outFlip1;
	   end
	   1: begin
	      s2rdloc <= (s2rdloc == depth-1) ? 0 : s2rdloc + 1;
         state3 <= 1;
	      outFlip1 <= (s2rdloc == depth-1) ? ~outFlip1 : outFlip1;
	   end	     
	 endcase
      end
   end
   always @(posedge clk) begin
      case({tm26_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd0 <= 1;
	     {1'd0,  5'd1}: s1rd0 <= 3;
	     {1'd0,  5'd2}: s1rd0 <= 5;
	     {1'd0,  5'd3}: s1rd0 <= 7;
	     {1'd0,  5'd4}: s1rd0 <= 9;
	     {1'd0,  5'd5}: s1rd0 <= 11;
	     {1'd0,  5'd6}: s1rd0 <= 13;
	     {1'd0,  5'd7}: s1rd0 <= 15;
	     {1'd0,  5'd8}: s1rd0 <= 17;
	     {1'd0,  5'd9}: s1rd0 <= 19;
	     {1'd0,  5'd10}: s1rd0 <= 21;
	     {1'd0,  5'd11}: s1rd0 <= 23;
	     {1'd0,  5'd12}: s1rd0 <= 25;
	     {1'd0,  5'd13}: s1rd0 <= 27;
	     {1'd0,  5'd14}: s1rd0 <= 29;
	     {1'd0,  5'd15}: s1rd0 <= 31;
	     {1'd0,  5'd16}: s1rd0 <= 0;
	     {1'd0,  5'd17}: s1rd0 <= 2;
	     {1'd0,  5'd18}: s1rd0 <= 4;
	     {1'd0,  5'd19}: s1rd0 <= 6;
	     {1'd0,  5'd20}: s1rd0 <= 8;
	     {1'd0,  5'd21}: s1rd0 <= 10;
	     {1'd0,  5'd22}: s1rd0 <= 12;
	     {1'd0,  5'd23}: s1rd0 <= 14;
	     {1'd0,  5'd24}: s1rd0 <= 16;
	     {1'd0,  5'd25}: s1rd0 <= 18;
	     {1'd0,  5'd26}: s1rd0 <= 20;
	     {1'd0,  5'd27}: s1rd0 <= 22;
	     {1'd0,  5'd28}: s1rd0 <= 24;
	     {1'd0,  5'd29}: s1rd0 <= 26;
	     {1'd0,  5'd30}: s1rd0 <= 28;
	     {1'd0,  5'd31}: s1rd0 <= 30;
      endcase      
   end

// synthesis attribute rom_style of s1rd0 is "block"
   always @(posedge clk) begin
      case({tm26_d, s1rdloc})
	     {1'd0,  5'd0}: s1rd1 <= 0;
	     {1'd0,  5'd1}: s1rd1 <= 2;
	     {1'd0,  5'd2}: s1rd1 <= 4;
	     {1'd0,  5'd3}: s1rd1 <= 6;
	     {1'd0,  5'd4}: s1rd1 <= 8;
	     {1'd0,  5'd5}: s1rd1 <= 10;
	     {1'd0,  5'd6}: s1rd1 <= 12;
	     {1'd0,  5'd7}: s1rd1 <= 14;
	     {1'd0,  5'd8}: s1rd1 <= 16;
	     {1'd0,  5'd9}: s1rd1 <= 18;
	     {1'd0,  5'd10}: s1rd1 <= 20;
	     {1'd0,  5'd11}: s1rd1 <= 22;
	     {1'd0,  5'd12}: s1rd1 <= 24;
	     {1'd0,  5'd13}: s1rd1 <= 26;
	     {1'd0,  5'd14}: s1rd1 <= 28;
	     {1'd0,  5'd15}: s1rd1 <= 30;
	     {1'd0,  5'd16}: s1rd1 <= 1;
	     {1'd0,  5'd17}: s1rd1 <= 3;
	     {1'd0,  5'd18}: s1rd1 <= 5;
	     {1'd0,  5'd19}: s1rd1 <= 7;
	     {1'd0,  5'd20}: s1rd1 <= 9;
	     {1'd0,  5'd21}: s1rd1 <= 11;
	     {1'd0,  5'd22}: s1rd1 <= 13;
	     {1'd0,  5'd23}: s1rd1 <= 15;
	     {1'd0,  5'd24}: s1rd1 <= 17;
	     {1'd0,  5'd25}: s1rd1 <= 19;
	     {1'd0,  5'd26}: s1rd1 <= 21;
	     {1'd0,  5'd27}: s1rd1 <= 23;
	     {1'd0,  5'd28}: s1rd1 <= 25;
	     {1'd0,  5'd29}: s1rd1 <= 27;
	     {1'd0,  5'd30}: s1rd1 <= 29;
	     {1'd0,  5'd31}: s1rd1 <= 31;
      endcase      
   end

// synthesis attribute rom_style of s1rd1 is "block"
    swNet32252 sw(tm26_d, clk, muxCycle, t0, s0, t1, s1);

   always @(posedge clk) begin
      case({tm26_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr0 <= 16;
	      {1'd0, 5'd1}: s2wr0 <= 17;
	      {1'd0, 5'd2}: s2wr0 <= 18;
	      {1'd0, 5'd3}: s2wr0 <= 19;
	      {1'd0, 5'd4}: s2wr0 <= 20;
	      {1'd0, 5'd5}: s2wr0 <= 21;
	      {1'd0, 5'd6}: s2wr0 <= 22;
	      {1'd0, 5'd7}: s2wr0 <= 23;
	      {1'd0, 5'd8}: s2wr0 <= 24;
	      {1'd0, 5'd9}: s2wr0 <= 25;
	      {1'd0, 5'd10}: s2wr0 <= 26;
	      {1'd0, 5'd11}: s2wr0 <= 27;
	      {1'd0, 5'd12}: s2wr0 <= 28;
	      {1'd0, 5'd13}: s2wr0 <= 29;
	      {1'd0, 5'd14}: s2wr0 <= 30;
	      {1'd0, 5'd15}: s2wr0 <= 31;
	      {1'd0, 5'd16}: s2wr0 <= 0;
	      {1'd0, 5'd17}: s2wr0 <= 1;
	      {1'd0, 5'd18}: s2wr0 <= 2;
	      {1'd0, 5'd19}: s2wr0 <= 3;
	      {1'd0, 5'd20}: s2wr0 <= 4;
	      {1'd0, 5'd21}: s2wr0 <= 5;
	      {1'd0, 5'd22}: s2wr0 <= 6;
	      {1'd0, 5'd23}: s2wr0 <= 7;
	      {1'd0, 5'd24}: s2wr0 <= 8;
	      {1'd0, 5'd25}: s2wr0 <= 9;
	      {1'd0, 5'd26}: s2wr0 <= 10;
	      {1'd0, 5'd27}: s2wr0 <= 11;
	      {1'd0, 5'd28}: s2wr0 <= 12;
	      {1'd0, 5'd29}: s2wr0 <= 13;
	      {1'd0, 5'd30}: s2wr0 <= 14;
	      {1'd0, 5'd31}: s2wr0 <= 15;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr0 is "block"
   always @(posedge clk) begin
      case({tm26_dd, writeCycle})
	      {1'd0, 5'd0}: s2wr1 <= 0;
	      {1'd0, 5'd1}: s2wr1 <= 1;
	      {1'd0, 5'd2}: s2wr1 <= 2;
	      {1'd0, 5'd3}: s2wr1 <= 3;
	      {1'd0, 5'd4}: s2wr1 <= 4;
	      {1'd0, 5'd5}: s2wr1 <= 5;
	      {1'd0, 5'd6}: s2wr1 <= 6;
	      {1'd0, 5'd7}: s2wr1 <= 7;
	      {1'd0, 5'd8}: s2wr1 <= 8;
	      {1'd0, 5'd9}: s2wr1 <= 9;
	      {1'd0, 5'd10}: s2wr1 <= 10;
	      {1'd0, 5'd11}: s2wr1 <= 11;
	      {1'd0, 5'd12}: s2wr1 <= 12;
	      {1'd0, 5'd13}: s2wr1 <= 13;
	      {1'd0, 5'd14}: s2wr1 <= 14;
	      {1'd0, 5'd15}: s2wr1 <= 15;
	      {1'd0, 5'd16}: s2wr1 <= 16;
	      {1'd0, 5'd17}: s2wr1 <= 17;
	      {1'd0, 5'd18}: s2wr1 <= 18;
	      {1'd0, 5'd19}: s2wr1 <= 19;
	      {1'd0, 5'd20}: s2wr1 <= 20;
	      {1'd0, 5'd21}: s2wr1 <= 21;
	      {1'd0, 5'd22}: s2wr1 <= 22;
	      {1'd0, 5'd23}: s2wr1 <= 23;
	      {1'd0, 5'd24}: s2wr1 <= 24;
	      {1'd0, 5'd25}: s2wr1 <= 25;
	      {1'd0, 5'd26}: s2wr1 <= 26;
	      {1'd0, 5'd27}: s2wr1 <= 27;
	      {1'd0, 5'd28}: s2wr1 <= 28;
	      {1'd0, 5'd29}: s2wr1 <= 29;
	      {1'd0, 5'd30}: s2wr1 <= 30;
	      {1'd0, 5'd31}: s2wr1 <= 31;
      endcase // case(writeCycle)
   end // always @ (posedge clk)

// synthesis attribute rom_style of s2wr1 is "block"
endmodule



						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule
