#!/usr/bin/env perl

#use warnings 'all';
#use strict;
#use FindBin;
#use Math::Round;

use verilog::gen;

my $scriptInfo = 
	"/*------------------------------------------------------------------------------\n" .
	" * This code was generated by Spiral Multiplier Block Generator, www.spiral.net\n" .
	" * Copyright (c) 2006, Carnegie Mellon University\n" .
	" * All rights reserved.\n" .
	" * The code is distributed under a BSD style license\n" .
	" * (see http://www.opensource.org/licenses/bsd-license.php)\n" .
	" *------------------------------------------------------------------------------" .
	" */\n";

#-----------------------------------------------------------------------
# @brief generates the base form of the multiplication, each constant
#  is represented as a wire with its representative name via standard
#  verilog multiplication
# @param fh File handle to print to - pass like \*FH
# @param ports used to aquire input and outputs
# @param outputBitwidth bitwidth of outputs
# @param inputBitwidth bitwidth of inputs
# @param fixedPoint shift value of fixedPoint values
# @param constants array of values to multiply input by
# @param prefix string to prepend to each verilog variable
# @return undefined
#-----------------------------------------------------------------------
sub genVanillaMultiplication {
	
	my ($fh, $ports, $outputBitwidth, $inputBitwidth, $fixedPoint, $constants, $prefix) = @_;
	my %val_used =("1" => 1);
	
	my $constantCount = scalar(@$constants);

	print  $fh "//Multipliers\n\n";

	my $wireWidths = $inputBitwidth + $fixedPoint;
	my $assignStatements = "  assign ${prefix}1 = ". $ports->{i_data} . "0;\n";
	my $outputAssignStatements = "";

	print $fh "  wire [" . ($wireWidths - 1) . ":0]\n"; 
	print $fh "    ${prefix}1";

	for(my $i = 0; $i <  $constantCount; $i++){
	my $const = fix_zero($constants->[$i]);
	my $wireName = "${prefix}" . checkPos($const);
	
	$outputAssignStatements .= 
		"  assign " . $ports->{o_data} . "$i" . " = $wireName";
	if($wireWidths > $outputBitwidth){
		$outputAssignStatements .= "[" . ($wireWidths - 1) .
		":" . ($wireWidths - $outputBitwidth) . "]";
	}
	$outputAssignStatements .= ";\n";
	
	if($val_used{$const}){
		next;
	}
	$val_used{$const} = 1;
	print $fh ",\n    ${prefix}" . checkPos($const);
	$assignStatements .= "  assign ${prefix}" . checkPos($const) . " = (${prefix}1 * ";
	
	if($const < 0){
		$assignStatements .= "(-1 * ${wireWidths}\'d" . (-1 * $const) . ")";
	}else{
		$assignStatements .= "${wireWidths}\'d${const}";
	}
	
	$assignStatements .= ");\n";
	}
	
	print $fh ";\n\n$assignStatements\n";
	print $fh "$outputAssignStatements\n";
	
}

#-----------------------------------------------------------------------
# @brief generates the adderChain form of the multiplication,
#  shift and add chains are generated from the acm tool
# @param fh File handle to print to - pass like \*FH
# @param ports used to aquire input and outputs
# @param outputBitwidth bitwidth of outputs
# @param inputBitwidth bitwidth of inputs
# @param fixedPoint shift value of fixedPoint values
# @param constants array of values to multiply input by
# @param prefix string to prepend to each verilog variable
# @return undefined
#-----------------------------------------------------------------------
sub genOptMultiplication {

	my ($fh, $ports, $outputBitwidth, $inputBitwidth, $fixedPoint, $constants, $prefix, $acmOutput, $debug) = @_;
	my $acm_args = "";
	my $anyZeros = 0;

	my $wireWidths = $inputBitwidth + $fixedPoint;
	my %wireVal = ("${prefix}1" => 1, "${prefix}1" => 0);

	print $fh "  //Multipliers:\n\n";

	my $constantCount = scalar(@$constants);  
	
	for(my $i = 0; $i < $constantCount; $i++){
	$constants->[$i] = fix_zero($constants->[$i]);
	if($constants->[$i] != 0){
		$acm_args .= " " .$constants->[$i];
	}
	else{
		$anyZeros = 1;
	}
	}
	
	if($acmOutput){
	if(!open(ACM_OUT, "./acm2values.pl -acmOutput $acmOutput 2>&1 |")){
		print STDERR "Error executing acm2value.pl\n";
		exit(-2);
	}
	}
	elsif(!open(ACM_OUT, "./acm2values.pl $acm_args 2>&1 |")){
	print STDERR "Error executing acm2value.pl\n";
	exit(-2);
	}

	my $assignStatements = "  assign ${prefix}1 = ". $ports->{i_data} . "0;\n";
	print $fh "  wire [" . ($wireWidths - 1) . ":0]\n"; 
	print $fh "    ${prefix}1";

	if($anyZeros){
		print $fh ",\n    ${prefix}0";
		$assignStatements .= "  assign ${prefix}0 = 0;\n"; 
	}
	
	#                          0      1       2       3       4      5         6         7        8          9
	#insert these: @info = (outWire, type, inputA, inputB, op_low, op_high, out_low, out_high, next_low, next_high);
	my %wireInfo = ();
	
	my @wireZero_info = ("${prefix}0", "NULL", "NULL", "NULL", 0, 0, 0, 0, 0, 0);
	$wireInfo{"${prefix}0"} = \@wireZero_info;
	my @wireOne_info = ("${prefix}1", "NULL", "NULL", "NULL", 0, $inputBitwidth - 1, 0, $inputBitwidth-1, 0, 0);
	$wireInfo{"${prefix}1"} = \@wireOne_info;

	my $shr_seen = 0;
	
	my $MSB = ($wireWidths - 1);

	while(my $line = <ACM_OUT>){
	# regxp accepts:  z = op(x, y);
	if($line =~ /\s*\/\//){
		#comment
		next;
	}

	if($line =~ /\s*(\w+)\s*=\s*(\w+)\((\w+),\s*(\w+)\);/){
		my ($wire, $op, $x, $y) = ($1, $2, $3, $4);
		
		my @x_info = ();
		my @y_info = ();
		my $x_low = 0;
		my $x_high = 0;
		my $y_low = 0;
		my $y_high = 0;
		my $op_low = 0;
		my $op_high = 0;
		my $out_low = 0;
		my $out_high = 0;
		
		my $x_info_ptr = $wireInfo{$x};
		my $y_info_ptr = $wireInfo{$y};
		
		if(defined($x_info_ptr)){
		@x_info = @$x_info_ptr;
		$x_low = $x_info[6];
		$x_high = $x_info[7];
		}
		if(defined($y_info_ptr)){
		@y_info = @$y_info_ptr;
		$y_low = $y_info[6];
		$y_high = $y_info[7];
		}
		
		if($op eq "add"){
		$op_low = max($x_low, $y_low);
		$out_low = min($x_low, $y_low);
		$op_high = max($x_high, $y_high);
		$out_high = min($op_high + 1, $MSB);
		}
		elsif($op eq "sub"){
		$op_low = max($x_low, $y_low);
		$out_low = min($x_low, $y_low);
		$op_high = max($x_high, $y_high);
		$out_high = min($op_high + 1, $MSB);
		}
		elsif($op eq "shl"){
		$op_low = 0;
		$out_low = min($x_low + $y, $MSB);
		$op_high = 0;
		$out_high = min($x_high + $y, $MSB);
		}
		elsif($op eq "shr"){
		$op_low = 0;
		$out_low = max($x_low - $y, 0);
		$op_high = 0;
		$out_high = max($x_high - $y, 0);		
		
		$shr_seen = 1;
		}
		else{
			print STDERR "Error, operation($op) is not valid.\n";
			exit(-2);
		}
		
#	    print STDERR "wire1: $wire = $op($x, $y) op($op_low, $op_high) out($out_low, $out_high)\n";
#	    print STDERR "    x: $x($x_low, $x_high)\n";
#	    print STDERR "    y: $y($y_low, $y_high)\n";
		
		my @info = ($wire, $op, $x, $y, $op_low, $op_high, $out_low, $out_high, 0, 0);
		$wireInfo{$wire} = \@info;
		print $fh ",\n    $wire";
	}
	# regxp accepts:  z = neg(x);
	elsif($line =~ /\s*(\w+)\s*=\s*neg\s*\(\s*(\w+)\s*\);/){
		my ($wire, $x) = ($1, $2);
		  
		my $x_info_ptr = $wireInfo{$x};
		

		my @x_info = @$x_info_ptr;
		
		my $x_low = $x_info[6];
		my $x_high = $x_info[7];
		
		my $op_low = $x_low;
		my $op_high = $x_high;
		my $out_low = $op_low;
		my $out_high = $op_high;
		
		my @info = ($wire, "neg", $x, 0, $op_low, $op_high, $out_low, $out_high, 0, 0);
		
#	    print STDERR "wire1: $wire = neg($x) op($op_low, $op_high) out($out_low, $out_high)\n";
#	    print STDERR "    x: $x($x_low, $x_high)\n";

		$wireInfo{$wire} = \@info;
		
		print $fh ",\n    $wire";
	}
	else{
		print STDERR "Error, unkown acm2value output:\n";
		do{
		print STDERR $line;
		}while($line = <ACM_OUT>);
		exit(-2);
	}
	}
	
	if(!close(ACM_OUT)){ #check exit code
	print STDERR "Error executing acm2value.pl: nonzero exit code\n";
	exit(-2);
	}
	
	print $fh ";\n\n";
	    
	if($shr_seen){
#	print STDERR  "\n//NB: SHR seen\n";
	}
	
	my @wireQueue = ();
	# a means of making sure that a wire isn't in the queue multiple times
	my %wireQueueHash = ();

	#for refererence:
	#                          0      1       2       3       4      5         6         7        8          9
	#insert these: @info = (outWire, type, inputA, inputB, op_low, op_high, out_low, out_high, next_low, next_high);

	#Calculate Area Estimate Here
	for(my $i = 0; $i < $constantCount; $i++){
	my $const = fix_zero($constants->[$i]);
	if(($const == 0 )
	   ||($const == 1)){
		#free?
		next;
	}
	my $wireName = "${prefix}" . checkPos($const);

	if(!($wireQueueHash{$wireName})){
		push(@wireQueue, $wireName);
		$wireQueueHash{$wireName} = 1;
	}
	my $wire = $wireInfo{$wireName};
	
	$wire->[8] = ($wireWidths - $outputBitwidth);
	$wire->[9] = $MSB;
	}

	while(defined(my $wireName = shift(@wireQueue))){
	my $wire = $wireInfo{$wireName};
	$wireQueueHash{$wireName} = 0;

	my $y = $wire->[3];
	my $x = $wire->[2];

	my $op = $wire->[1];

#	print STDERR "wire2: $wireName = $op($x,$y)\n";

	if($op eq "NULL" || $op eq ""){
		next;
	}elsif($op eq "add" ||
		   $op eq "sub"){
		my $y_wire = $wireInfo{$y};
		
		$y_wire->[8] = $wire->[8];
		$y_wire->[9] = $wire->[9];
		
		if(!($wireQueueHash{$y})){
		push(@wireQueue, $y);
		$wireQueueHash{$y} = 1;
		}
		
		my $x_wire = $wireInfo{$x};
		
		$x_wire->[8] = $wire->[8];
		$x_wire->[9] = $wire->[9];
		
		if(!($wireQueueHash{$x})){
		push(@wireQueue, $x);
		$wireQueueHash{$x} = 1;
		}
		
		
	}elsif($op eq "neg"){
		my $x_wire = $wireInfo{$x};
		
		$x_wire->[8] = $wire->[8];
		$x_wire->[9] = $wire->[9];
		
		if(!($wireQueueHash{$x})){
		push(@wireQueue, $x);
		$wireQueueHash{$x} = 1;
		}

	}elsif($op eq "shl"){
		my $x_wire = $wireInfo{$x};
		
		$x_wire->[8] = max($wire->[8]-$y, 0);
		$x_wire->[9] = max($wire->[9]-$y, 0);
		
		if(!($wireQueueHash{$x})){
		push(@wireQueue, $x);
		$wireQueueHash{$x} = 1;
		}

	}elsif($op eq "shr"){
		my $x_wire = $wireInfo{$x};
		
		$x_wire->[8] = min($wire->[8]+$y, $MSB);
		$x_wire->[9] = min($wire->[9]+$y, $MSB);
		
		if(!($wireQueueHash{$x})){
		push(@wireQueue, $x);
		$wireQueueHash{$x} = 1;
		}

	}else{
		print STDERR "Error, operation($op) is not valid. Fix me.\n";
		exit(-2);
	}
	}
	
	my $areaEstimate = 0;
	
	#                          0      1       2       3       4      5         6         7        8          9
	#insert these: @info = (outWire, type, inputA, inputB, op_low, op_high, out_low, out_high, next_low, next_high);
	my $wireKey;
	foreach $wireKey (sort (keys %wireInfo)){
	my $wire = $wireInfo{$wireKey};
	my @info = @$wire;
	
	my ($outWire, $op, $x, $y, $op_low, $op_high, $out_low, $out_high, $next_low, $next_high) = @info;

#	print STDERR "wire: $wireKey = $op($x,$y)";

	my $insideArea = 0;

	if($op eq "NULL"){
	}elsif($op eq "add" ||
		   $op eq "sub" ||
		   $op eq "neg" ){
		my $low = $op_low;#max($next_low, $op_low);
		my $high = min($next_high, $op_high);
		
		if($op eq "add"){
		$insideArea = adderArea($high - $low + 1);
		$assignStatements .= "  assign $outWire = $x + $y;";
		$assignStatements .= " //$insideArea = adderArea($low,$high)" if($debug);
		$assignStatements .= "\n"; 
		}elsif($op eq "sub"){
		$insideArea = subArea($high - $low + 1);
		$assignStatements .= "  assign $outWire = $x - $y;";
		$assignStatements .= " //$insideArea = subArea($low,$high)" if($debug);
		$assignStatements .= "\n"; 
		}else{#neg
		$insideArea = negArea($high - $low + 1);
		$assignStatements .= "  assign $outWire = -1 * $x;";
		$assignStatements .= " //$insideArea = negArea($low,$high)" if($debug);
		$assignStatements .= "\n"; 		
		}
		
#	    print STDERR "[$low($next_low,$op_low) : $high($next_high,$op_high)] = $insideArea ";
		
	}elsif($op eq "shl"){
		my $low = $out_low;#max($next_low, $out_low);
		my $high = min($next_high, $out_high);
		$assignStatements .= "  assign $outWire = $x << $y;";
		$assignStatements .= " //shl($low,$high)" if($debug);
		$assignStatements .= "\n"; 
	}elsif($op eq "shr"){
		my $low = $out_low;#max($out_low, $next_low);
		my $high = min($next_high, $out_high);
		$assignStatements .= "  assign $outWire = $x >> $y;";
		$assignStatements .= " //shr($low,$high)" if($debug);
		$assignStatements .= "\n";
	}else{
		print STDERR "Error, operation($op) is not valid. Fix me.\n";
		exit(-2);
	}
	
	$areaEstimate += $insideArea;
#	print STDERR "\n";
	}
	
#    print STDERR "Total area = $areaEstimate \n";
	
	print $fh $assignStatements . "\n";
	
	my $outputAssignStatements = "";  

	my $LSB = ($wireWidths - $outputBitwidth);

	#tag output assignStatements with bitwidths
	for(my $i = 0; $i < $constantCount; $i++){
	my $const = fix_zero($constants->[$i]);
	my $wireName = "${prefix}" . checkPos($const);
	$outputAssignStatements .= 
		"  assign " . $ports->{o_data} . "$i" . " = $wireName";
	if($wireWidths > $outputBitwidth){
		$outputAssignStatements .= "[" . ($wireWidths - 1) .
		":" . ($wireWidths - $outputBitwidth) . "]";
	}
	$outputAssignStatements .= ";";
	
	if($const == 0 ){
		$outputAssignStatements .= " //BitwidthUsed(none)" if($debug);
	}elsif($const == 1){
		#inputBitwdith
		if($inputBitwidth > $LSB){
		$outputAssignStatements .= " //BitwidthUsed(0, " . ($inputBitwidth-1 - $LSB) .")" if($debug);
		}else{
		$outputAssignStatements .= " //BitwidthUsed(none)" if($debug);
		}
	}else{
		#need to figure out how big:
		my $wire = $wireInfo{$wireName};
		my ($outWire, $op, $x, $y, $op_low, $op_high, $out_low, $out_high, $next_low, $next_high) = @$wire;

		my ($high, $low) = (0,0);
		
		if($op eq "NULL"){
		}elsif($op eq "add" ||
		   $op eq "sub" ||
		   $op eq "neg" ){
		$low = max($op_low, $LSB);
		$high = min($next_high, $op_high);
		}else{
		$low = max($out_low, $LSB);
		$high = min($next_high, $out_high);
		}

		$high -= $LSB;
		$low -= $LSB;
		
		if($high>=$low){
		$outputAssignStatements .= " //BitwidthUsed($low, $high)" if($debug);
		}else{
		$outputAssignStatements .= " //BitwidthUsed(none)" if($debug);
		}
	}
	$outputAssignStatements .= "\n";
	}

	print $fh "$outputAssignStatements" . "\n";

	return $areaEstimate;
}

#-----------------------------------------------------------------------
# @brief puts it all together, reading input, etc
#   generates multiplier block, as expected
#-----------------------------------------------------------------------
sub main {

	#cmdline args = defaults:
	my @constants = ();
	my $bitWidth = 32;
	my $fixedPoint = 0;
	my $moduleName = "multiplier_block";
	my $nonOptimal = 0;
	my $suppressInfo = 0;
	my $optimal = 0;
	my $outFileName;
	my $acmOutput;
	my $trailingBits = 0;
	my $debug = 0;
	my $fh;
	my %ports = 
	("i_data" => "i_data",
	 "o_data" => "o_data");
	
	#my args
	my $parseConstants = 1;

	my $cmdLine = "./multBlockGen.pl " . join(" ", @ARGV);

	#parse args
	for(my $i = 0; $i < scalar(@ARGV); $i++){
	if($ARGV[$i] eq ""){
		next;
	}
	elsif($ARGV[$i] eq "-debug"){
		$debug = 1;
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-moduleName"){
		$i++;
		$moduleName = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-bitWidth"){
		$i++;
		$bitWidth = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-trailingBits"){
		$i++;
		$trailingBits = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-acmOutput"){
		$i++;
		$acmOutput = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-fractionalBits"){
		$i++;
		$fixedPoint = $ARGV[$i];
		$parseConstants = 0;
		if($fixedPoint < 0){
		print "Fractional Bits argument must be non-negative: $ARGV[$i]\n";
		printUsage();
		}
	}
	elsif($ARGV[$i] eq "-inData"){
		$i++;
		$ports{"i_data"} = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-outData"){
		$i++;
		$ports{"o_data"} = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-h" || $ARGV[$i] eq "--help"){
		printUsage();
	}
	elsif($ARGV[$i] eq "-base"){
		$nonOptimal = 1;
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-addChain"){
		$optimal = 1;
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-outFile"){
		$i++;
		$outFileName = $ARGV[$i];
		$parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-suppressInfo"){
		$suppressInfo = 1;
		$parseConstants = 0;
	}
	elsif($parseConstants){
		#verify we were given a number:
		my $temp = getnum($ARGV[$i]);
		if(defined(scalar($temp))){
		push(@constants, $ARGV[$i]);
		}
		else{
		print STDERR "UNDEFINED ARG: " . $ARGV[$i] . "\n";
		printUsage();
		}
	}
	else{
		print STDERR "UNDEFINED ARG: " . $ARGV[$i] . "\n";
		printUsage();
	}
	}

	if(!(scalar(@constants))){
	print STDERR "At least 1 constant is required\n\n";
	printUsage();
	}

	if($bitWidth <= $fixedPoint){
	print STDERR "-fixedPoint must be less than -bitWdith.\n" .
		"Please reduce the -fixedPoint parameter or increase the -bitWidth parameter.\n";
	printUsage();
	}
	
	my $outputPortSize = $bitWidth + $trailingBits;
	if($trailingBits > $fixedPoint){
	print STDERR "trailing bits are not permitted to be more than fixedPoint Bits.\n" .
		"Please reduce the -trailingBits parameter or increase the -fixedPoint parameter.\n";
	printUsage();
	}

	if(defined($outFileName)){
	if(!open(OUTFILE, "> $outFileName")){
		print STDERR "Unable to open outfile for writing: $outFileName\n";
		exit(-2);
	}
	$fh = \*OUTFILE;
	}
	else{
	$fh = \*STDOUT;
	}

	#ports
	my @portList = (["input  ", $ports{"i_data"}, $bitWidth],
			["output ", $ports{"o_data"}, $outputPortSize, scalar(@constants)]);	  
	
	my $optSuffix = "";
	my $vanillaSuffix = "";
	if($optimal && $nonOptimal){
	$optSuffix = "_addChain";
	$vanillaSuffix = "_base";
	}
	elsif(!($optimal || $nonOptimal)){
	$optimal = 1; #default
	}

	unless ($suppressInfo){
	print $fh $scriptInfo;
	print "/* " . $cmdLine . "*/";
	}

	my $prefix = "w";

	if($optimal){
	genHeader($fh, $moduleName . $optSuffix, \@portList);
	my $areaEst = genOptMultiplication($fh, \%ports, $outputPortSize, $bitWidth, $fixedPoint, \@constants, $prefix, $acmOutput, $debug);
	genTail($fh, $moduleName . $optSuffix, $areaEst);
	}
	if($nonOptimal){
	genHeader($fh, $moduleName . $vanillaSuffix, \@portList);
	genVanillaMultiplication($fh, \%ports, $outputPortSize, $bitWidth, $fixedPoint, \@constants, $prefix);
	genTail($fh, $moduleName . $vanillaSuffix);
	}

	close($fh) if(defined($outFileName));

	return 1;
}

#-----------------------------------------------------------------------
# @brief prints the usage and exits -1
#-----------------------------------------------------------------------
sub printUsage(){
	
	print STDERR <<EOF;

$scriptInfo

  ./multBlockGen.pl 10 20 30 40 30 20 10 [-moduleName acmFilter] [-bitWidth 32]
	     [-trailingBits 0] [-fractionalBits value] [-inData i_data] [-outData o_data]
	     [-base] [-addChain] [-outFile fileName] [-suppressInfo] [-acmOutput file]

  constants:the constants to multiply by.
	must occur before any options

  -moduleName: verilog module name
  -bitWidth: How many bits of data the multiplier multiplies by
  -fractionalBits: how many bits of data are below the decimal point, default: 0
	 when this is used, the constants still need to be whole numbers, merely 
	 2^x is now construed to be 1, where x is the fixedPoint value
  -trailingBits: how many bits to leave dangling after the final fixedPoint
	 shift.  Must be less than or equal to fixedPoint.  Defaults to 0.
  -inData: verilog input port name
  -outData: verilog output port name
  -base: generate the vanilla, non-optimized version, for comparison
	 may be used in conjunction with -addChain, will generate 2 modules 
  -addChain: generate the optimized version, default
	 may be used in conjunction with -base, will generate 2 modules

  -outFile: print output to said fileName, defaults to stdout

  -suppressInfo: exclude script info from the verilog output

  -acmOutput: instead of calling acm on the commandline, parse the pregenerated output
	 provided here


EOF

  exit(-1);
}

if(!main()){
	printf("Script Failed.\n");
	exit(-1);
}
else{
	exit(0);
}

1;