#!/usr/bin/env perl

use warnings 'all';
use strict;
use FindBin;
use Math::Round;

my $scriptInfo = 
    "/*------------------------------------------------------------------------------\n" .
    " * Verilog generated by $FindBin::RealScript:\n" .
    " *      generates FIR filter verilog for constant multiplier chains\n" .
    " * author: jtrapass (Joseph Paul Trapasso)\n" .
    " * based on the mcm tool by Yevgen Voronenko\n" .
    " * under the guidance of James Hoe and Markus Pueschel\n" .
    " *------------------------------------------------------------------------------" .
    " */\n";

#-----------------------------------------------------------------------
# @brief replaces integer value with representative integer string
# @param x value to convert to string
# @return abs of x, with an _ if x is negative, eg:
#     6 => 6
#    -2 => 2_
#     0 => 0
#-----------------------------------------------------------------------
sub checkPos{ 
    my ($x) = @_;
    #necessary to weed out -0
    if($x == 0){
	return "0";
    }
    elsif($x < 0){
	my $new_val = -1 * $x;
	return "${new_val}_";
    }
    else{
	return "$x";
    }
}

#-----------------------------------------------------------------------
# @brief prints the necessary code to cleanly register 1 input
#-----------------------------------------------------------------------
sub registerIn{
    my ($inData, $inReg, $bitWidth, $clk) = @_;
    
    print 
	"  reg [" . ($bitWidth - 1) . ":0] $inReg;\n\n" .
	"  always@(posedge $clk) begin\n" .
	"    $inReg <= $inData;\n" .
	"  end\n\n";
}

#-----------------------------------------------------------------------
# @brief prints the necessary code to cleanly register 1 output
#-----------------------------------------------------------------------
sub registerOut{
    my ($outData, $outReg, $bitWidth, $clk) = @_;
    
    print 
	"  reg [" . ($bitWidth - 1) . ":0] $outData;\n" .
	"  wire [" . ($bitWidth - 1) . ":0] $outReg;\n\n" .
	"  always@(posedge $clk) begin\n" .
	"    $outData <= $outReg;\n" .
	"  end\n\n";
}

#-----------------------------------------------------------------------
# getnum and is_numeric
# borrowed from: http://www.unix.org.ua/orelly/perl/cookbook/ch02_02.htm
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# @brief obtain the numeric value of the string, decimal or integer
# @param str string to extract value from
# @return numeric value or undefined if no value extractable
#-----------------------------------------------------------------------
sub getnum {
    use POSIX qw(strtod);
    my $str = shift;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    $! = 0;
    my($num, $unparsed) = strtod($str);
    if (($str eq '') || ($unparsed != 0) || $!) {
        return;
    } else {
        return $num;
    } 
}

#-----------------------------------------------------------------------
# @brief checks if the string is numeric
# @param str string to check
# @return true if numeric, false otherwise
#-----------------------------------------------------------------------
sub is_numeric { defined scalar &getnum } 

#-----------------------------------------------------------------------
# @brief removes negative values of 0
# @param value value to compare
# @return value, if not (-0), 0 if it is
#-----------------------------------------------------------------------
sub fix_zero {
    my ($value) = @_;
    if($value == 0){
	return 0;
    }
    return $value;
} 

#-----------------------------------------------------------------------
# @brief prints header and port declations
#-----------------------------------------------------------------------
sub genHeader {
    my ($moduleName, $portNames, $portTypes, $portSizes) = @_;
    
    #Header information explaining file
    print "\nmodule $moduleName (";
    
    my $portModeDecl = "  // Port mode declarations:\n";
    for(my $i = 0; $i < scalar(@$portNames); $i++){
	print "\n    " . @$portNames[$i];
	$portModeDecl .=  "  " .
	    $portTypes->[$i] . " " .
	    $portSizes->[$i] . " " .
	    $portNames->[$i] . ";\n";
	if ($i == scalar(@$portNames) - 1){
	    #last port, no comma
	    print "\n";
	}
	else{
	    print ",";
	}
    }

    print ");\n";

    print "\n" . $portModeDecl . "\n";
    
}

#-----------------------------------------------------------------------
# @brief ends the module, with a useful comment to describe it
#-----------------------------------------------------------------------
sub genTail {
    my ($moduleName) = @_;

    print "endmodule //$moduleName\n\n";
}

#-----------------------------------------------------------------------
# @brief generates the base form of the multiplication, each constant
#  is represented as a wire with its representative name via standard
#  verilog multiplication
#-----------------------------------------------------------------------
sub genVanillaMultiplication {
    
    my ($ports, $bitWidth, $fixedPoint, $constants, $prefix) = @_;
    my %val_used =("1" => 1);

    print  "//Multipliers\n\n";

    my $assignStatements = "  assign ${prefix}1 = ". $ports->{i_data} . ";\n";
    print "  wire [" . ($fixedPoint + $bitWidth - 1) . ":0]\n"; 
    print "    ${prefix}1";

    foreach my $const(@$constants){
	$const = fix_zero($const);
	if($val_used{$const}){
	    next;
	}
	$val_used{$const} = 1;
	print ",\n    ${prefix}" . checkPos($const);
	$assignStatements .= "  assign ${prefix}" . checkPos($const) . " = (${prefix}1 * $const)"
	    . ";\n";
    }

    print ";\n\n$assignStatements\n";

}

#-----------------------------------------------------------------------
# @brief generates the adderChain form of the multiplication,
#  shift and add chains are generated from the acm tool
#-----------------------------------------------------------------------
sub genOptMultiplication {

    my ($ports, $bitWidth, $fixedPoint, $constants, $prefix) = @_;
    my $acm_args = "";
    my $anyZeros = 0;

    my %wireVal = ("${prefix}1" => 1, "${prefix}1" => 0);

    print "  //Multipliers:\n\n";

    my $constantCount = scalar(@$constants);
    
    for(my $i = 0; $i < $constantCount; $i++){
	if($constants->[$i] != 0){
	    $acm_args .= " " .$constants->[$i];
	}
	else{
	    $anyZeros = 1;
	}
    }

    if(!open(ACM_OUT, "./acm2values.pl $acm_args 2>&1 |")){
	print "Error executing acm2value.pl\n";
	exit(-2);
    }
    
    my $assignStatements = "  assign ${prefix}1 = ". $ports->{i_data} . ";\n";
    print "  wire [" . (($bitWidth - 1) + $fixedPoint) . ":0]\n"; 
    print "    ${prefix}1";

    if($anyZeros){
	print ",\n    ${prefix}0";
	$assignStatements .= "  assign ${prefix}0 = 0;\n"; 
    }
    
    while(my $line = <ACM_OUT>){
	# regxp accepts:  z = op(x, y);
	if($line =~ /\s*(\w+)\s*=\s*(\w+)\((\w+),\s*(\w+)\);/){
	    my ($wire, $op, $x, $y) = ($1, $2, $3, $4);
	    
	    if($op eq "add"){
		$assignStatements .= "  assign $wire = $x + $y;\n"; 
	    }
	    elsif($op eq "sub"){
	    	$assignStatements .= "  assign $wire = $x - $y;\n"; 
	    }
	    elsif($op eq "shl"){
		$assignStatements .= "  assign $wire = $x << $y;\n"; 
	    }
	    elsif($op eq "shr"){
	    	$assignStatements .= "  assign $wire = $x >> $y;\n"; 
	    }

	    ##deprecated
	    #elsif($op eq "cmul"){
	    #   $assignStatements .= "  assign $wire = $x * $y;\n"; 
	    #}

	    else{
		print "Error 1, operation($op) is not valid.\n";
		exit(-2);
	    }
	    
	    print ",\n    $wire";
	}
	# regxp accepts:  z = neg(x);
	elsif($line =~ /\s*(\w+)\s*=\s*neg\s*\(\s*(\w+)\s*\);/){
	    my ($wire, $x) = ($1, $2);
	    
	    $assignStatements .= "  assign $wire = -1 * $x;\n"; 
	    
	    print ",\n    $wire";
	}
	else{
	    print "Error, unkown acm2value output:\n";
	    do{
		print $line;
	    }while($line = <ACM_OUT>);
	    exit(-2);
	}
    }
    
    if(!close(ACM_OUT)){ #check exit code
	print "Error executing acm2value.pl: nonzero exit code\n";
	exit(-2);
    }
    
    print ";\n\n";
    
    print $assignStatements . "\n";
}

#-----------------------------------------------------------------------
# @brief generates the array shifting to move the data through the array
#  step by step adding the parts of the filter
#-----------------------------------------------------------------------
sub genAlwaysBlock {

    my ($ports, $bitWidth, $fixedPoint, $constants, $prefix) = @_;
    
    if (scalar(@$constants)){

	my $arrayName = "step";
	print "  reg [" . ($fixedPoint + $bitWidth - 1) . ":0] $arrayName [" .(scalar(@$constants) - 1) . ":0];\n\n";

	print "  always@(posedge ". $ports->{"clk"} . ") begin\n";
	print "    ${arrayName}[0] <=  $prefix" . checkPos($constants->[0]) . ";\n";
	for(my $i = 1; $i < (scalar(@$constants)); $i++){
	    print "    ${arrayName}[$i] <=  ${arrayName}[". ($i - 1) . "] + " . $prefix . checkPos($constants->[$i]) . ";\n";
	}
	print "  end\n\n";

	print "  assign " . $ports->{"o_data"} . " = ${arrayName}[". (scalar(@$constants)-1) . "][". ($fixedPoint + $bitWidth - 1) .":$fixedPoint];\n";
    }
    else{
	print "Error - must have at least 1 constant\n";
	printUsage();
    }
}

#-----------------------------------------------------------------------
# @brief generates a testBench, which provides the filter with an impulse
#  and, if all goes correct, should return a time reversed reading of the
#  filter
#-----------------------------------------------------------------------
sub genTestBench{
    my ($ports, $moduleList, $bitwidth, $filterSteps, $registerDelays, $fixedPoint, $constants) = @_;
    
    print "  integer testEndedGracefully;\n\n";

    print "  reg [" . ($bitwidth - 1) . ":0] inData;\n".
	"  reg clk;\n";
    
    my $verify;
    
    if(!scalar(@$moduleList)){
	print "Error: Cannot write a testBench for no modules.\n";
	exit(-2);
    }
    
    foreach my $module(@$moduleList){
	print 
	    "  wire  [" . ($bitwidth - 1) . ":0] ${module}_out;\n" .
	    "  integer ${module}_val;\n";
    }
    
    print "\n";
    
    print
	"  initial begin\n";
    
    print "    \$display(\"                   Time, ". join("_val, ", @$moduleList) . "_val\");\n";
    
    print
	"    clk = 1;\n".
	"    forever \#1 clk =~clk;\n".
	"  end\n\n";
    
    foreach my $module(@$moduleList){
	print 
	    "  ${module} my_${module}(\n".
	    "    ." . $ports->{"clk"} ."(clk),\n".
	    "    ." . $ports->{"i_data"} ."(inData),\n".
	    "    ." . $ports->{"o_data"} ."(${module}_out)\n".
	    "  );\n\n";
    }
    
    

    my $pr_str = "\$display(\"Output: \%d";
    foreach my $module(@$moduleList){
	$pr_str .= ", %d";
    }
    $pr_str .= "\", \$time";
    foreach my $module(@$moduleList){
	$pr_str .= ", ${module}_val";
    }
    $pr_str .= ");\n";
    
    print "\n  //Convert unsigned values to signed integers for comparison\n";
    foreach my $module(@$moduleList){
	print 
	    "  always@(${module}_out) begin\n" .
	    "    if(${module}_out >= ".(1 << ($bitwidth - 1)).")\n" .
	    "      ${module}_val = ${module}_out - ".(1 << $bitwidth).";\n" .
	    "    else\n" .
	    "      ${module}_val = ${module}_out;\n" .
	    "  end\n\n";
    }
    
    print
	"  initial begin\n" . 
        "    //ignore initial x's and initial\n" .
        "    //delays through registers\n" .
	"    #". (2*($filterSteps + 3*$registerDelays)) .";\n";
    
    for(my $i = scalar(@$constants) - 1; $i >= 0; $i--){
	my $const = $constants->[$i];
	print
	    "\n    @(posedge clk);\n" .
	    "      #0;\n" .
	    "      $pr_str";
	
	foreach my $module(@$moduleList){
	    print
		"      if(($const+1 <= ${module}_val) && (${module}_val <= $const+1))\n" .
		"        \$display(\"ERROR: ${module}_val should be $const\");\n";
	}
    }

    print
	"\n    //All outputs have been seen\n" .
	"    testEndedGracefully <= 1;\n\n";
    
    print   
	"\n    forever @(posedge clk) begin\n" .
	"      #0;\n";
    foreach my $module(@$moduleList){
	print
	    "      if(${module}_val !== 0 )\n" .
	    "        \$display(\"ERROR: ${module}_val should be 0\");\n";
    }

    print
	"    end //always@(posedge clk)\n\n".
	"  end //initial begin\n\n";

    print 
	"  initial begin\n".
	"    testEndedGracefully <= 0;\n" .
	"    inData <= 0;\n".
        "    #". (2*($filterSteps + $registerDelays)) .";\n".
	"    //feed an impulse\n" .
	"    inData <=  1 << $fixedPoint;\n".
	"    #2;\n".
	"    inData <= 0;\n".
	"    #". (2*$filterSteps + 10) .";\n".
        "    if(testEndedGracefully !== 1)\n" .
        "      \$display(\"ERROR: Test ended too soon.  Not all outputs seen.\");\n" .
        "    \$stop;\n".
        "    \$finish;\n".
        "  end\n\n";
}

#-----------------------------------------------------------------------
# @brief puts it all together, reading input, etc
#-----------------------------------------------------------------------
sub main {

    #cmdline args = defaults:
    my @constants = ();
    my $bitWidth = 32;
    my $fixedPoint = 0;
    my $moduleName = "acmFilter";
    my $inReg = 0;
    my $outReg = 0;
    my $nonOptimal = 0;
    my $optimal = 0;
    my $testBench = 0;
    my $testBenchName = "top";
    my $outFile = 0;
    my $outFileName;
    my %ports = 
	("i_data" => "i_data",
	 "o_data" => "o_data",
	 "clk" => "clk");
    
    #my args
	my $parseConstants = 1;

    #parse args
    for(my $i = 0; $i < scalar(@ARGV); $i++){
	if($ARGV[$i] eq ""){
	    next;
	}
	elsif($ARGV[$i] eq "-moduleName"){
	    $i++;
	    $moduleName = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-bitWidth"){
	    $i++;
	    $bitWidth = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-fixedPoint"){
	    $i++;
	    $fixedPoint = $ARGV[$i];
	    $parseConstants = 0;
	    if($fixedPoint < 0){
		print "Fixed point argument must be non-negative: $ARGV[$i]\n";
		printUsage();
	    }
	}
	elsif($ARGV[$i] eq "-inData"){
	    $i++;
	    $ports{"i_data"} = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-inReg"){
	    $inReg = 1;
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-outData"){
	    $i++;
	    $ports{"o_data"} = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-outReg"){
	    $outReg = 1;
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-clk"){
	    $i++;
	    $ports{"clk"} = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-h" || $ARGV[$i] eq "--help"){
	    printUsage();
	}
	elsif($ARGV[$i] eq "-base"){
	    $nonOptimal = 1;
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-addChain"){
	    $optimal = 1;
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-testBench"){
	    $testBench = 1;
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-testBenchName"){
	    $i++;
	    $testBench = 1;
	    $testBenchName = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($ARGV[$i] eq "-outFile"){
	    $i++;
	    $outFile = 1;
	    $outFileName = $ARGV[$i];
	    $parseConstants = 0;
	}
	elsif($parseConstants){
	    #verify we were given a number:
	    my $temp = getnum($ARGV[$i]);
	    if(defined(scalar($temp)) && ($temp == round($temp))){
		push(@constants, $ARGV[$i]);
	    }
	    else{
		print "UNDEFINED ARG: " . $ARGV[$i] . "\n";
		printUsage();
	    }
	}
	else{
	    print "UNDEFINED ARG: " . $ARGV[$i] . "\n";
	    printUsage();
	}
    }

    my $bitEnd = $bitWidth -1;
    #ports
    my @portTypes = (       "input  ",        "output ",        "input  ");
    my @portNames = ($ports{"i_data"}, $ports{"o_data"}, $ports{"clk"});
    my @portSizes = (   "[$bitEnd:0]",    "[$bitEnd:0]",  "      ");

    #registered ports:
    my %regPorts = %ports;

    $regPorts{"i_data"} = $ports{"i_data"} . "_in" if($inReg);
    $regPorts{"o_data"} = $ports{"o_data"} . "_in" if($outReg);

    my $optSuffix = "";
    my $vanillaSuffix = "";
    if($optimal && $nonOptimal){
	$optSuffix = "_addChain";
	$vanillaSuffix = "_base";
    }
    elsif(!($optimal || $nonOptimal)){
	$optimal = 1; #default
    }

    print $scriptInfo;
	
    my $prefix = "w";

    if($optimal){
	genHeader($moduleName . $optSuffix, \@portNames, \@portTypes, \@portSizes);
	registerIn($ports{"i_data"}, $regPorts{"i_data"}, $bitWidth, $ports{"clk"}) if($inReg);
	registerOut($ports{"o_data"}, $regPorts{"o_data"}, $bitWidth, $ports{"clk"}) if($outReg);
	genOptMultiplication(\%regPorts , $bitWidth, $fixedPoint, \@constants, $prefix);
	genAlwaysBlock(\%regPorts , $bitWidth, $fixedPoint, \@constants, $prefix);
	genTail($moduleName . $optSuffix);
    }
    if($nonOptimal){
	genHeader($moduleName . $vanillaSuffix, \@portNames, \@portTypes, \@portSizes);
	registerIn($ports{"i_data"}, $regPorts{"i_data"}, $bitWidth, $ports{"clk"}) if($inReg);
	registerOut($ports{"o_data"}, $regPorts{"o_data"}, $bitWidth, $ports{"clk"}) if($outReg);
	genVanillaMultiplication(\%regPorts , $bitWidth, $fixedPoint, \@constants, $prefix);
	genAlwaysBlock(\%regPorts , $bitWidth, $fixedPoint, \@constants, $prefix);
	genTail($moduleName . $vanillaSuffix);
    }
    if($testBench){
	my @dummy = ();
	my @moduleList =();
	push(@moduleList, $moduleName . $optSuffix) if($optimal);
	push(@moduleList, $moduleName . $vanillaSuffix) if($nonOptimal);
	
	genHeader($testBenchName, \@dummy, \@dummy, \@dummy);
        genTestBench(\%ports, \@moduleList, $bitWidth, scalar(@constants),  (($inReg?1:0) + ($outReg?1:0)),  $fixedPoint, \@constants);
	genTail($testBenchName);
    }
    return 1;
}

#-----------------------------------------------------------------------
# @brief prints the usage and exits -1
#-----------------------------------------------------------------------
sub printUsage(){
    
    print <<EOF;

$scriptInfo

  ./$FindBin::RealScript 10 20 30 40 30 20 10 [-moduleName acmFilter] [-bitWidth 32]
         [-fixedPoint value] [-inData i_data] [-inReg] [-outData o_data] [-outReg] 
         [-clk clk] [-base] [-addChain] [-testBench | -testBenchName top] [-outFile fileName]

  currently prints to stdout, will soon have -outFile working.

  constants:the constants to multiply by.
    must occur before any options

  -moduleName: verilog module name
  -bitWidth: How many bits of data the multiplier multiplies by
  -fixedPoint: how many bits of data are below the decimal point, default: 0
     when this is used, the constants still need to be whole numbers, merely 
     2^x is now construed to be 1, where x is the fixedPoint value
  -inData: verilog input port name
  -inReg: cleanly register input
  -outData: verilog output port name
  -outReg: cleanly register output
  -clk: verilog clk name
  -base: generate the vanilla, non-optimized version, for comparison
     may be used in conjunction with -addChain, will generate 2 modules 
  -addChain: generate the optimized version, default
     may be used in conjunction with -base, will generate 2 modules
  -testBench: generate testBench
     if used alone or in conjunction with one of the above two options, 
     will generate a test bench to print the inputs and outputs
     based on a pseudo random input stream
 
     if used in conjunction with both -base and -addChain, will
     will generate code to compare the output of the two when run
  -testBenchName: generate testBench with the given name

  -outFile print output to said fileName, defaults to stdout

EOF

  exit(-1);
}

if(!main()){
    printf("Script Failed.\n");
    exit(-1);
}
else{
    exit(0);
}

1;