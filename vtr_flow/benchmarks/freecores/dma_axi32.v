/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_defines.v
//---------------------------------------------------------


  
`define FRAME_BITS     12
`define X_BITS         8
`define TOKEN_BITS     6
`define OUT_BITS       4
`define DELAY_BITS     3
`define CMD_CNT_BITS   12
`define INT_CNT_BITS   4
`define WAIT_BITS      12
`define TIMEOUT_BITS   10
`define WDT_BITS       11
`define CMD_BITS       7
`define ID_BITS        1
`define LEN_BITS       4
`define SIZE_BITS      2

`define ID_END_LINE    6
`define ID_LAST        3




/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_reg_params.v
//---------------------------------------------------------


  
   parameter              CMD_LINE0      = 8'h00;
   parameter              CMD_LINE1      = 8'h04;
   parameter              CMD_LINE2      = 8'h08;
   parameter              CMD_LINE3      = 8'h0C;
   parameter              STATIC_LINE0   = 8'h10;
   parameter              STATIC_LINE1   = 8'h14;
   parameter              STATIC_LINE2   = 8'h18;
   parameter              STATIC_LINE3   = 8'h1C;
   parameter              STATIC_LINE4   = 8'h20;
   
   parameter              RESTRICT       = 8'h2C;
   parameter              RD_OFFSETS     = 8'h30;
   parameter              WR_OFFSETS     = 8'h34;
   parameter              FIFO_FULLNESS  = 8'h38;
   parameter              CMD_OUTS       = 8'h3C;
   
   parameter              CH_ENABLE      = 8'h40;
   parameter              CH_START       = 8'h44;
   parameter              CH_ACTIVE      = 8'h48;
   parameter              CH_CMD_COUNTER = 8'h50;
                 
   parameter               INT_RAWSTAT    = 8'hA0;
   parameter               INT_CLEAR      = 8'hA4;
   parameter               INT_ENABLE     = 8'hA8;
   parameter               INT_STATUS     = 8'hAC;


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_reg_params.v
//---------------------------------------------------------


  
   
   parameter              PROC0_STATUS     = 8'h00;
   parameter              PROC1_STATUS     = 8'h04;
   parameter              PROC2_STATUS     = 8'h08;
   parameter              PROC3_STATUS     = 8'h0C;
   parameter              PROC4_STATUS     = 8'h10;
   parameter              PROC5_STATUS     = 8'h14;
   parameter              PROC6_STATUS     = 8'h18;
   parameter              PROC7_STATUS     = 8'h1C;
   parameter              CORE0_JOINT      = 8'h30;
   parameter              CORE1_JOINT      = 8'h34;
   parameter              CORE0_PRIO       = 8'h38;
   parameter              CORE1_PRIO       = 8'h3C;
   parameter              CORE0_CLKDIV     = 8'h40;
   parameter              CORE1_CLKDIV     = 8'h44;
   parameter              CORE0_START      = 8'h48;
   parameter              CORE1_START      = 8'h4C;
   parameter              PERIPH_RX_CTRL   = 8'h50;
   parameter              PERIPH_TX_CTRL   = 8'h54;
   parameter              IDLE             = 8'hD0;
   parameter              USER_DEF_STAT    = 8'hE0;
   parameter              USER_DEF0_STAT0  = 8'hF0;
   parameter              USER_DEF0_STAT1  = 8'hF4;
   parameter              USER_DEF1_STAT0  = 8'hF8;
   parameter              USER_DEF1_STAT1  = 8'hFC;

















/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_apb_mux.v
//---------------------------------------------------------



module  dma_axi32_apb_mux (clk,reset,pclken,psel,penable,pwrite,paddr,prdata,pslverr,pready,psel0,prdata0,pslverr0,psel1,prdata1,pslverr1,psel_reg,prdata_reg,pslverr_reg);

   input                 clk;
   input                 reset;

   input                 pclken;
   input                 psel;
   input                 penable;
   input          pwrite;
   input [12:11]      paddr;
   output [31:0]         prdata;
   output          pslverr;
   output          pready;

   output          psel0;
   input [31:0]      prdata0;
   input           pslverr0;
   
   output          psel1;
   input [31:0]      prdata1;
   input           pslverr1;
   
   output          psel_reg;
   input [31:0]      prdata_reg;
   input           pslverr_reg;

   wire [31:0]          prdata_pre;
   wire          pslverr_pre;
   
   
   reg              pready;
   
   
   assign          psel0    = pclken & psel & (paddr[12:11] == 2'b00);
   assign          psel1    = pclken & psel & (paddr[12:11] == 2'b01);
   assign          psel_reg = pclken & psel & (paddr[12] == 1'b1);

   assign          prdata_pre  = prdata0 | prdata1 | prdata_reg;
   assign          pslverr_pre = pslverr0 | pslverr1 | pslverr_reg;
   
   assign          prdata = prdata_pre;
   assign          pslverr = pslverr_pre;
  

   always @(posedge clk or posedge reset)
     if (reset)
       pready <= #1 1'b0;
     else if (pclken)
       pready <= #1 psel & (~penable);
       
   
endmodule



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: dma_core_arbiter.v
//---------------------------------------------------------



module dma_axi32_core0_arbiter(clk,reset,enable,joint_mode,page_cross,joint_req,prio_top,prio_high,prio_top_num,prio_high_num,hold,ch_ready,ch_active,finish,ch_go_out,ch_num,ch_last);
   
   parameter                CH_LAST       = 1-1;
   
   input             clk;
   input             reset;

   input             enable;

   input             joint_mode;
   input             page_cross;
   input             joint_req;
   input             prio_top;
   input             prio_high;
   input [2:0]             prio_top_num;
   input [2:0]             prio_high_num;
   input             hold;
   
   input [7:0]             ch_ready;
   input [7:0]             ch_active;
   input             finish;
   output             ch_go_out;
   output [2:0]         ch_num;
   output             ch_last;
   

   
   reg [7:0]             current_active;
   wire             current_ready_only;
   wire             ch_last_pre;
   wire             ch_last;
   wire             ready;
   wire             next_ready;
   wire             next_ready0;
   wire             next_ready1;
   wire             prio_top_ready;
   wire             prio_high_ready;
   reg                 in_prog;
   wire             ch_go_pre;
   wire             ch_go_pre_d;
   wire             ch_go_top_pre;
   wire             ch_go_high_pre;
   wire             ch_go;
   wire             ch_go_d;
   wire             ch_go_top;
   wire             ch_go_high;
   wire             ch_go_next;
   wire             hold_d;
   wire             advance_next;
   wire [2:0]             ch_num_pre;
   wire [3:0]             next_ch_num0_pre;
   wire [3:0]             next_ch_num0_pre2;
   wire [2:0]             next_ch_num0;
   wire [3:0]             next_ch_num1_pre;
   wire [3:0]             next_ch_num1_pre2;
   wire [2:0]             next_ch_num1;
   wire [2:0]             next_ch_num_pre;

   assign             ch_go_out = 'd1;
   assign             ch_num    = 'd0;
   assign             ch_last   = 'd1;
   
   
   
endmodule


   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_axim_cmd.v
//---------------------------------------------------------



module dma_axi32_core0_axim_cmd(clk,reset,ch_num,burst_start,burst_addr,burst_size,end_line_cmd,extra_bit,cmd_port,joint_req,joint_pending,cmd_pending,cmd_full,cmd_split,cmd_num,cmd_line,page_cross,AID,AADDR,APORT,ALEN,ASIZE,AVALID,AREADY,AWVALID,AJOINT,axim_timeout_num,axim_timeout);

   parameter                  AXI_WORD_SIZE = 1 ? 2'b10 : 2'b11;
   parameter                  AXI_2 = 1 ? 2 : 3;

   input               clk;
   input               reset;
   
   input [2:0]               ch_num;
   
   input               burst_start;
   input [32-1:0]      burst_addr;
   input [7-1:0]     burst_size;
   input               end_line_cmd;
   input               extra_bit;
   input               cmd_port;
   input               joint_req;
   
   output               joint_pending;
   output               cmd_pending;
   input               cmd_full;
   output               cmd_split;
   output [2:0]           cmd_num;
   output               cmd_line;
   
   output               page_cross;
   
   output [`CMD_BITS-1:0]     AID;
   output [32-1:0]     AADDR;
   output               APORT;
   output [`LEN_BITS-1:0]     ALEN;
   output [1:0]           ASIZE;
   output               AVALID;
   input               AREADY;
   input               AWVALID;
   output               AJOINT;
   
   output [2:0]           axim_timeout_num;
   output               axim_timeout;
   

   
   reg [`CMD_BITS-1:0]           AID;
   reg [`CMD_BITS-1:0]           AID_reg;
   reg [32-1:0]           AADDR;
   reg                   APORT;
   reg [`LEN_BITS-1:0]           ALEN;
   reg [1:0]               ASIZE;
   reg                   AVALID_reg;
   reg                   AJOINT;
   

   wire [`CMD_BITS-1:0]       AID_pre;
   wire [32-1:0]       AADDR_pre;
   wire [1:0]               ASIZE_pre;
   wire [`LEN_BITS-1:0]       ALEN_pre;
   wire [7-1:0]      burst_length;

   wire               cmd;
   reg                   cmd_pending;
   wire               cmd_line_pre;
   wire               cmd_line;

   wire               high_addr_pre;
   wire               high_addr;
   wire [8:0]               burst_reach_pre;
   reg [8:0]               burst_reach;
   reg                   joint_cross;
   wire               page_cross_pre;
   wire               page_cross;
   wire               cross_start;
   wire               cross_start_d;
   wire [8:0]               max_burst;
   reg [8:0]               max_burst_d;
   reg                   next_burst;
   reg [7-1:0]       next_burst_size;
   wire               next_burst_start;
      


   
   assign               high_addr_pre    = burst_addr[11:8] == 4'hf;
   assign               burst_reach_pre  = burst_addr[7:0] + burst_size;
   assign               page_cross       = high_addr & (burst_reach > {1'b1, {8{1'b0}}});
   assign               max_burst        = {1'b1, {8{1'b0}}} - burst_addr[7:0];
   assign               next_burst_start = next_burst & (~AVALID_reg) & (~cmd_full);
   assign               cross_start      = burst_start & page_cross;

   
   prgen_delay #(1) delay_high_addr (.clk(clk), .reset(reset), .din(high_addr_pre), .dout(high_addr));
   prgen_delay #(1) delay_cross_start (.clk(clk), .reset(reset), .din(cross_start), .dout(cross_start_d));
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       burst_reach <= #1 {9{1'b0}};
     else if (high_addr_pre)
       burst_reach <= #1 burst_reach_pre;
   
   always @(posedge clk or posedge reset)
     if (reset)
       next_burst <= #1 1'b0;
     else if (next_burst_start)
       next_burst <= #1 1'b0;
     else if (cross_start)
       next_burst <= #1 1'b1;
          
   always @(posedge clk or posedge reset)
     if (reset)
       max_burst_d <= #1 {9{1'b0}};
     else if (cross_start)
       max_burst_d <= #1 max_burst;
   
   always @(posedge clk or posedge reset)
     if (reset)
       next_burst_size <= #1 {7{1'b0}};
     else if (cross_start)
       next_burst_size <= #1 burst_size;
     else if (cross_start_d)
       next_burst_size <= #1 next_burst_size - max_burst_d;
   
   assign               cmd_split       = cross_start_d;
   
   assign               cmd             = AVALID & AREADY;
   assign               cmd_num         = AID[2:0];
   assign               cmd_line_pre    = cmd & AID[6];              

   assign               joint_pending   = AVALID & (~AREADY) & AJOINT;
   
   always @(posedge clk or posedge reset)
     if (reset)
       cmd_pending <= #1 1'b0;
     else if (burst_start)
       cmd_pending <= #1 1'b1;
     else if (cmd & (~next_burst))
       cmd_pending <= #1 1'b0;
   
   
   prgen_delay #(1) delay_cmd_line (.clk(clk), .reset(reset), .din(cmd_line_pre), .dout(cmd_line));
   
   assign               AID_pre = {
                     end_line_cmd,   //[6]
                     ASIZE_pre[1:0], //[5:4]
                     extra_bit,      //[3]
                     ch_num[2:0]     //[2:0]
                     };

   assign               AADDR_pre = burst_addr;
   
   assign               ASIZE_pre = 
                  burst_size == 'd1 ? 2'b00 :
                  burst_size == 'd2 ? 2'b01 :
                  burst_size == 'd4 ? 2'b10 : 
                  AXI_WORD_SIZE;
   
   assign               burst_length =
                  next_burst    ? next_burst_size :
                  page_cross    ? max_burst       : burst_size;
   
   assign               ALEN_pre =
                  burst_length[7-1:AXI_2] == 'd0 ? {`LEN_BITS{1'b0}} :
                  burst_length[7-1:AXI_2] - 1'b1;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      ASIZE  <= #1 {2{1'b0}};
      AJOINT <= #1 1'b0;
       end
     else if (burst_start)
       begin
      ASIZE  <= #1 ASIZE_pre;
      AJOINT <= #1 joint_req;
       end

   always @(posedge clk or posedge reset)
     if (reset)
       AID_reg <= #1 {`CMD_BITS{1'b0}};
     else if (burst_start)
       AID_reg <= #1 AID_pre;

   always @(AID_reg or next_burst)
     begin
    AID               = AID_reg;
    AID[`ID_END_LINE] = AID_reg[`ID_END_LINE] & (~next_burst);
    AID[`ID_LAST]     = AID_reg[`ID_LAST] & (~next_burst);
     end
   
   always @(posedge clk or posedge reset)
     if (reset)
       AADDR  <= #1 {32{1'b0}};
     else if (next_burst_start)
       AADDR  <= #1 {AADDR[32-1:12], {12{1'b1}}} + 1'b1;
     else if (burst_start)
       AADDR  <= #1 AADDR_pre;

   always @(posedge clk or posedge reset)
     if (reset)
       APORT <= #1 1'b0;
     else if (burst_start)
       APORT <= #1 cmd_port;
   
   always @(posedge clk or posedge reset)
     if (reset)
       ALEN   <= #1 {`LEN_BITS{1'b0}};
     else if (burst_start | next_burst_start)
       ALEN   <= #1 ALEN_pre;

   always @(posedge clk or posedge reset)
     if (reset)
       AVALID_reg <= #1 1'b0;
     else if (AVALID & AREADY)
       AVALID_reg <= #1 1'b0;
     else if ((burst_start & (burst_size > 'd0)) | next_burst_start)
       AVALID_reg <= #1 1'b1;

   assign AVALID = AJOINT ? AVALID_reg & (~AWVALID) : AVALID_reg;
   
   dma_axi32_core0_axim_timeout  dma_axi32_axim_timeout (
                         .clk(clk),
                         .reset(reset),
                         .VALID(AVALID),
                         .READY(AREADY),
                         .ID(AID),
                         .axim_timeout_num(axim_timeout_num),
                         .axim_timeout(axim_timeout)
                         );
   
   
endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_axim_rdata.v
//---------------------------------------------------------



module dma_axi32_core0_axim_rdata(clk,reset,joint_stall,ch_fifo_wr,ch_fifo_wdata,ch_fifo_wsize,ch_fifo_wr_num,rd_transfer_num,rd_transfer,rd_transfer_size,rd_burst_cmd,load_wr,load_wr_num,load_wr_cycle,load_wdata,rd_clr_line,rd_clr_line_num,ARVALID,ARREADY,ARID,RID,RDATA,RLAST,RVALID,RREADY,RREADY_out);
   
   input               clk;
   input               reset;

   input               joint_stall;
   
   output               ch_fifo_wr;
   output [32-1:0]     ch_fifo_wdata;
   output [3-1:0]     ch_fifo_wsize;
   output [2:0]           ch_fifo_wr_num;
   output [2:0]           rd_transfer_num;
   output               rd_transfer;
   input [3-1:0]      rd_transfer_size;
   output               rd_burst_cmd;
   output               load_wr;
   output [2:0]           load_wr_num;
   output [1:0]           load_wr_cycle;
   output [32-1:0]     load_wdata;
   output               rd_clr_line;
   output [2:0]           rd_clr_line_num;

   input               ARVALID;
   input               ARREADY;
   input [`CMD_BITS-1:0]      ARID;
   input [`CMD_BITS-1:0]      RID;
   input [32-1:0]      RDATA;
   input               RLAST;
   input               RVALID;
   input               RREADY; 
   output               RREADY_out;
   

   reg [1:0]               load_wr_cycle;
   wire               load_cmd_id;
   wire               rd_clr_line_pre;
   wire               rd_clr_line_pre_d;
   reg [2:0]               ch_fifo_wr_num_d;
   reg [2:0]               rd_clr_line_num;
 



   
   assign               load_cmd_id     = RID[3];

   assign               RREADY_out      = (~rd_clr_line_pre) & (~rd_clr_line_pre_d) & (~joint_stall);

   assign               rd_transfer_num = RID[2:0];
   
   assign               rd_transfer     = RVALID & RREADY & (~load_cmd_id);
   
   assign               rd_burst_cmd    = rd_transfer & RID[5];

   assign               ch_fifo_wr      = rd_transfer;
      
   assign               ch_fifo_wdata   = RDATA;

   assign               ch_fifo_wsize   = rd_transfer_size;

   assign               ch_fifo_wr_num  = RID[2:0];
 

   assign               rd_clr_line_pre = RVALID & RREADY & RLAST & RID[6] & (~RID[3]);

   prgen_delay #(1) delay_clr(.clk(clk), .reset(reset), .din(rd_clr_line_pre), .dout(rd_clr_line_pre_d));
   prgen_delay #(1) delay_clr2(.clk(clk), .reset(reset), .din(rd_clr_line_pre_d), .dout(rd_clr_line));
   
   always @(posedge clk or posedge reset)
     if (reset)
       ch_fifo_wr_num_d <= #1 3'b000;
     else if (rd_clr_line_pre)
       ch_fifo_wr_num_d <= #1 ch_fifo_wr_num;

   always @(posedge clk or posedge reset)
     if (reset)
       rd_clr_line_num <= #1 3'b000;
     else if (rd_clr_line_pre_d)
       rd_clr_line_num <= #1 ch_fifo_wr_num_d;
   
   assign               load_wr         = RVALID & RREADY & load_cmd_id;

   assign               load_wr_num     = RID[2:0];
   
   assign               load_wdata      = RDATA;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       load_wr_cycle <= #1 2'b00;
     else if (load_wr & load_wr_cycle[0] & 1'b0)
       load_wr_cycle <= #1 2'b00;
     else if (load_wr)
       load_wr_cycle <= #1 load_wr_cycle + 1'b1;


   
   
endmodule

   



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: dma_core_axim_rd.v
//---------------------------------------------------------



module dma_axi32_core0_axim_rd(clk,reset,load_wr,load_wr_num,load_wr_cycle,load_wdata,joint_stall,joint_req,rd_line_cmd,load_req_in_prog,rd_cmd_port,rd_ch_num,rd_burst_start,rd_burst_addr,rd_burst_size,rd_cmd_pending,rd_cmd_split,rd_cmd_line,rd_cmd_num,rd_cmd_full,ch_fifo_wr,ch_fifo_wdata,ch_fifo_wsize,ch_fifo_wr_num,rd_transfer_num,rd_transfer,rd_transfer_size,rd_burst_cmd,rd_clr_line,rd_clr_line_num,rd_slverr,rd_decerr,rd_clr,rd_clr_load,rd_clr_last,rd_ch_num_resp,page_cross,ARADDR,ARPORT,ARLEN,ARSIZE,ARVALID,ARREADY,AWVALID,RDATA,RRESP,RLAST,RVALID,RREADY_out,axim_timeout_ar,axim_timeout_num_ar);

   input               clk;
   input               reset;
   
   output               load_wr;
   output [2:0]           load_wr_num;
   output [1:0]           load_wr_cycle;
   output [32-1:0]     load_wdata;

   input               joint_stall;
   input               joint_req;
   
   //command
   input               rd_line_cmd;
   input               load_req_in_prog;
   input               rd_cmd_port;
   input [2:0]               rd_ch_num;
   input               rd_burst_start;
   input [32-1:0]      rd_burst_addr;
   input [7-1:0]     rd_burst_size;
   output               rd_cmd_pending;
   output               rd_cmd_split;
   output               rd_cmd_line;
   output [2:0]           rd_cmd_num;
   output               rd_cmd_full;
   
   //data
   output               ch_fifo_wr;
   output [32-1:0]     ch_fifo_wdata;
   output [3-1:0]     ch_fifo_wsize;
   output [2:0]           ch_fifo_wr_num;
   output [2:0]           rd_transfer_num;
   output               rd_transfer;
   output [3-1:0]     rd_transfer_size;
   output               rd_burst_cmd;
   output               rd_clr_line;
   output [2:0]           rd_clr_line_num;

   //resp
   output               rd_slverr;
   output               rd_decerr;
   output               rd_clr;
   output               rd_clr_load;
   output               rd_clr_last;
   output [2:0]           rd_ch_num_resp;

   output               page_cross;
   
   output [32-1:0]     ARADDR;
   output               ARPORT;
   output [`LEN_BITS-1:0]     ARLEN;
   output [1:0]           ARSIZE;
   output               ARVALID;
   input               ARREADY;
   input               AWVALID;
   
   input [32-1:0]      RDATA;
   input [1:0]               RRESP;
   input               RLAST;
   input               RVALID;
   output               RREADY_out;
   
   output               axim_timeout_ar;
   output [2:0]           axim_timeout_num_ar;


   wire [`CMD_BITS-1:0]       ARID;
   wire               RVALID_d;
   wire [`CMD_BITS-1:0]          RID;
   reg [32-1:0]           RDATA_d;
   reg [1:0]               RRESP_d;
   reg                   RLAST_d;
   reg [3-1:0]           rd_transfer_size;

   wire               rd_clr_pre;
   wire               RREADY;
   
   
              
   //don't give peripheral clr on cmd read
   assign               rd_clr      = rd_clr_pre & (~rd_clr_last);
   assign               rd_clr_load = rd_clr_pre & rd_clr_last;
   
   prgen_delay #(1) delay_ready(.clk(clk), .reset(reset), .din(RREADY_out), .dout(RREADY));
   
   prgen_delay #(1) delay_rvalid(.clk(clk), .reset(reset), .din(RVALID), .dout(RVALID_d));
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      RRESP_d <= #1 2'b00;
      RDATA_d <= #1 {32{1'b0}};
      RLAST_d <= #1 1'b0;
       end
     else if (RVALID)
       begin
      RRESP_d <= #1 RRESP;
      RDATA_d <= #1 RDATA;
      RLAST_d <= #1 RLAST;
       end
   
   always @(/*AUTOSENSE*/RID)
     begin
    case (RID[5:4])
      2'b00 : rd_transfer_size = 4'd1;
      2'b01 : rd_transfer_size = 4'd2;
      2'b10 : rd_transfer_size = 4'd4;
      2'b11 : rd_transfer_size = 4'd8;
    endcase
     end
   
   
   dma_axi32_core0_axim_cmd
   dma_axi32_axim_rcmd (
             .clk(clk),
             .reset(reset),
             .end_line_cmd(rd_line_cmd),
             .extra_bit(load_req_in_prog),
             .cmd_port(rd_cmd_port),
             .ch_num(rd_ch_num),
             .joint_req(joint_req),
             .burst_start(rd_burst_start),
             .burst_addr(rd_burst_addr),
             .burst_size(rd_burst_size),
             .cmd_pending(rd_cmd_pending),
             .cmd_full(rd_cmd_full),
             .cmd_split(rd_cmd_split),
             .cmd_num(rd_cmd_num),
             .cmd_line(rd_cmd_line),
             .page_cross(page_cross),
             .AID(ARID),
             .AADDR(ARADDR),
             .APORT(ARPORT),
             .ALEN(ARLEN),
             .ASIZE(ARSIZE),
             .AVALID(ARVALID),
             .AREADY(ARREADY),
             .AWVALID(AWVALID),
             .AJOINT(),
             .axim_timeout_num(axim_timeout_num_ar),
             .axim_timeout(axim_timeout_ar)
             );
   
   
   dma_axi32_core0_axim_rdata
   dma_axi32_axim_rdata (
              .clk(clk),
              .reset(reset),
              .load_wr(load_wr),
              .load_wr_num(load_wr_num),
              .load_wr_cycle(load_wr_cycle),
              .load_wdata(load_wdata),
              .joint_stall(joint_stall),
              .ch_fifo_wr(ch_fifo_wr),
              .ch_fifo_wdata(ch_fifo_wdata),
              .ch_fifo_wsize(ch_fifo_wsize),
              .ch_fifo_wr_num(ch_fifo_wr_num),
              .rd_transfer_num(rd_transfer_num),
              .rd_transfer(rd_transfer),
              .rd_transfer_size(rd_transfer_size),
              .rd_clr_line(rd_clr_line),
              .rd_clr_line_num(rd_clr_line_num),
              .rd_burst_cmd(rd_burst_cmd),
              .ARVALID(ARVALID),
              .ARREADY(ARREADY),
              .ARID(ARID),
              .RID(RID),
              .RDATA(RDATA_d),
              .RLAST(RLAST_d),
              .RVALID(RVALID_d),
              .RREADY(RREADY),
              .RREADY_out(RREADY_out)
              );

   
   dma_axi32_core0_axim_resp #(.CMD_DEPTH(2))
   dma_axi32_axim_rresp (
              .clk(clk),
              .reset(reset),
              .slverr(rd_slverr),
              .decerr(rd_decerr),
              .clr(rd_clr_pre),
              .clr_last(rd_clr_last),
              .ch_num_resp(rd_ch_num_resp),
              .resp_full(rd_cmd_full),
              .AID(ARID),
              .AVALID(ARVALID),
              .AREADY(ARREADY),
              .ID(RID),
              .RESP(RRESP_d),
              .VALID(RVALID_d),
              .READY(RREADY),
              .LAST(RLAST_d)
              );

   
endmodule

   



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_axim_resp.v
//---------------------------------------------------------



module dma_axi32_core0_axim_resp(clk,reset,slverr,decerr,clr,clr_last,ch_num_resp,resp_full,AID,AVALID,AREADY,RESP,ID,VALID,READY,LAST);

   parameter                  CMD_DEPTH = 8;
      
   input               clk;
   input               reset;

   output               slverr;
   output               decerr;
   output               clr;
   output               clr_last;
   output [2:0]           ch_num_resp;
   output               resp_full;
   
   
   input [`CMD_BITS-1:0]      AID;
   input               AVALID;
   input               AREADY;
   input [1:0]               RESP;
   output [`CMD_BITS-1:0]     ID;
   input               VALID;
   input               READY;
   input               LAST;


   
   parameter                  RESP_SLVERR = 2'b10;
   parameter                  RESP_DECERR = 2'b11;


   wire               clr_pre;
   wire [2:0]               ch_num_resp_pre;
   wire               clr_last_pre;
   wire               slverr_pre;
   wire               decerr_pre;
   reg [2:0]               ch_num_resp;

   wire               resp_push;
   wire               resp_pop;
   wire               resp_empty;
   wire               resp_full;
   wire [`CMD_BITS-1:0]       ID;
   

   assign               resp_push       = AVALID & AREADY;
   assign               resp_pop        = VALID & READY & LAST;
   
   assign               clr_pre         = resp_pop;
   
   assign               ch_num_resp_pre = ID[2:0] ;
   
   assign               slverr_pre      = clr_pre & RESP == RESP_SLVERR;
   assign               decerr_pre      = clr_pre & RESP == RESP_DECERR;
   
   assign               clr_last_pre    = clr_pre & ID[3];
   
   prgen_delay #(1) delay_clr(.clk(clk), .reset(reset), .din(clr_pre), .dout(clr));
   prgen_delay #(1) delay_clr_last(.clk(clk), .reset(reset), .din(clr_last_pre), .dout(clr_last));
   prgen_delay #(1) delay_slverr(.clk(clk), .reset(reset), .din(slverr_pre), .dout(slverr));
   prgen_delay #(1) delay_decerr(.clk(clk), .reset(reset), .din(decerr_pre), .dout(decerr));
   
   always @(posedge clk or posedge reset)
     if (reset)
       ch_num_resp <= #1 3'b000;
     else if (clr_pre)
       ch_num_resp <= #1 ch_num_resp_pre;
   


   prgen_fifo #(`CMD_BITS, CMD_DEPTH) 
   resp_fifo(
         .clk(clk),
         .reset(reset),
         .push(resp_push),
         .pop(resp_pop),
         .din(AID),
         .dout(ID),
         .empty(resp_empty),
         .full(resp_full)
         );

   
endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_axim_timeout.v
//---------------------------------------------------------



module dma_axi32_core0_axim_timeout(clk,reset,VALID,READY,ID,axim_timeout_num,axim_timeout);

   input               clk;
   input               reset;

   input               VALID;
   input               READY;
   input [`CMD_BITS-1:0]      ID;

   output [2:0]           axim_timeout_num;
   output               axim_timeout;


   
   reg [`TIMEOUT_BITS-1:0]    counter;

   
   assign               axim_timeout_num = ID[2:0];

   assign               axim_timeout = (counter == 'd0);

   
   always @(posedge clk or posedge reset)
     if (reset)
       counter <= #1 {`TIMEOUT_BITS{1'b1}};
     else if (VALID & READY)
       counter <= #1 {`TIMEOUT_BITS{1'b1}};
     else if (VALID)
       counter <= #1 counter - 1'b1;

   
   
endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: dma_core_axim_wdata.v
//---------------------------------------------------------



module dma_axi32_core0_axim_wdata(clk,reset,rd_transfer,rd_transfer_size,ch_fifo_rd,ch_fifo_rsize,ch_fifo_rdata,ch_fifo_rd_valid,ch_fifo_wr_ready,ch_fifo_rd_num,wr_transfer_num,wr_transfer,wr_transfer_size,wr_next_size,wr_resp_full,wr_cmd_full,wr_clr_line,wr_clr_line_num,joint_stall,axim_timeout_num,axim_timeout,AWID,AWADDR,AWLEN,AWSIZE,AWVALID,AWREADY,AJOINT,WDATA,WSTRB,WLAST,WVALID,WREADY);

   input               clk;
   input               reset;

   input               rd_transfer;
   input [3-1:0]      rd_transfer_size;
   output               ch_fifo_rd;
   output [3-1:0]     ch_fifo_rsize;
   input [32-1:0]      ch_fifo_rdata;
   input               ch_fifo_rd_valid;
   input               ch_fifo_wr_ready;
   output [2:0]           ch_fifo_rd_num;
   output [2:0]           wr_transfer_num;
   output               wr_transfer;
   output [3-1:0]     wr_transfer_size;
   output [3-1:0]     wr_next_size;

   input               wr_resp_full;
   output               wr_cmd_full;
   output               wr_clr_line;
   output [2:0]           wr_clr_line_num;

   output               joint_stall;
   
   output [2:0]           axim_timeout_num;
   output               axim_timeout;
   
   
   input [`CMD_BITS-1:0]       AWID;
   input [32-1:0]      AWADDR;
   input [`LEN_BITS-1:0]      AWLEN;
   input [1:0]               AWSIZE;
   input               AWVALID;
   input               AWREADY;
   input               AJOINT;
   
   output [32-1:0]     WDATA;
   output [4-1:0]     WSTRB;
   output               WLAST;
   output               WVALID;
   input               WREADY;

   
   wire [`CMD_BITS-1:0]       WID;
   wire [`CMD_BITS-1:0]       WID_pre;
   reg [4-1:0]           WSTRB_pre;
   wire [1:0]               WSIZE_pre;
   wire [`LEN_BITS-1:0]       WLEN_pre;
   
   wire [`CMD_BITS-1:0]       WID_data;
   wire [4-1:0]       WSTRB_data;
   wire [1:0]               WSIZE_data;
   wire [`LEN_BITS-1:0]       WLEN_data;
   wire               WVALID;
   wire               WLAST;
   wire               valid_last;
   wire               wr_clr_line_stall_pre;
   wire               wr_clr_line_stall;
   wire               wr_clr_line_pre;
   reg [2:0]               wr_clr_line_num;
   wire [2:0]               wr_transfer_num_pre;
   wire               wr_transfer_pre;
   wire [3-1:0]       wr_transfer_size_pre;
   reg [2:0]               wr_transfer_num;
   wire               wr_transfer;
   reg [3-1:0]           wr_transfer_size;
      
   reg [2:0]               last_channel;
   
   wire [`CMD_BITS-1:0]       WID_cmd;
   wire [1:0]               WSIZE_cmd;   
   reg [3-1:0]           wr_next_size;
   wire [`LEN_BITS-1:0]       WLEN_cmd;

   wire               data_ready;
   wire [2:0]               data_fullness_pre;
   reg [2:0]               data_fullness;
   wire               joint_fifo_rd_valid;
   wire               joint_req_out;
   wire               joint_stall;
   wire               rd_transfer_joint;
   wire [3-1:0]       rd_transfer_size_joint;
   wire               rd_transfer_full;
   
   wire               cmd_push;
   wire               cmd_pop;
   wire               cmd_pop_d;
   wire               cmd_empty;
   wire               cmd_full;
   
   wire               cmd_data_push;
   wire               cmd_data_pop;
   wire               cmd_data_empty;
   wire               cmd_data_full;
   
   wire               data_push;
   wire               data_pop;
   wire               data_empty;
   wire               data_full;
   
   reg [`LEN_BITS-1:0]           rd_out_count;
   reg [`LEN_BITS-1:0]           rd_in_count;

   wire               data_pending_pre;
   wire               data_pending;
   wire               line_end;
   wire [2:0]               line_end_num;
   

   //joint
   assign               data_ready        = ch_fifo_rd_valid;
   assign               data_fullness_pre = data_fullness + data_ready - wr_transfer_pre;
   
   always @(posedge clk or posedge reset)
     if (reset)
       data_fullness <= #1 3'd0;
     else if (data_ready | wr_transfer_pre)
       data_fullness <= #1 data_fullness_pre;

   prgen_joint_stall #(3)
     gen_joint_stall (
              .clk(clk),
              .reset(reset),
              .joint_req_out(joint_req_out),
              .rd_transfer(rd_transfer),
              .rd_transfer_size(rd_transfer_size),
              .ch_fifo_rd(ch_fifo_rd),
              .data_fullness_pre(data_fullness_pre),
              .HOLD(1'b0),
              .joint_fifo_rd_valid(joint_fifo_rd_valid),
              .rd_transfer_size_joint(rd_transfer_size_joint),
              .rd_transfer_full(rd_transfer_full),
              .joint_stall(joint_stall)
              );

   
   
   //fifo rd command
   assign               data_pending_pre = WVALID & (~WREADY);

   prgen_delay #(1) delay_pending (.clk(clk), .reset(reset), .din(data_pending_pre), .dout(data_pending));
 
  //assign                   wr_next_size  = 1'b1 << WSIZE_cmd;
   always @(/*AUTOSENSE*/WSIZE_cmd)
     begin
        case (WSIZE_cmd)
          2'b00 : wr_next_size = 4'd1;
          2'b01 : wr_next_size = 4'd2;
          2'b10 : wr_next_size = 4'd4;
          2'b11 : wr_next_size = 4'd8;
        endcase
     end

   assign               ch_fifo_rd = 
                  joint_fifo_rd_valid |
                  
                  ((~cmd_empty) & 
                  (~data_pending) &
                  (~wr_clr_line_stall) &
                  ch_fifo_wr_ready);
   
   
   assign               ch_fifo_rsize =
                  joint_fifo_rd_valid ? rd_transfer_size_joint :
                  WID_cmd[5:4] == 2'b00 ? 4'd1 :
                  WID_cmd[5:4] == 2'b01 ? 4'd2 :
                  WID_cmd[5:4] == 2'b10 ? 4'd4 : 4'd8;
   
   assign               ch_fifo_rd_num   =  WID_cmd[2:0];

   
   prgen_delay #(1) delay_cmd_pop (.clk(clk), .reset(reset), .din(cmd_pop), .dout(cmd_pop_d));
   
   always @(posedge clk or posedge reset)
     if (reset)
       last_channel <= #1 3'b000;
     else if (cmd_push)
       last_channel <= #1 WID_pre[2:0];
      
   
   //update pointers in channel
   assign               wr_transfer_num_pre  = WID_data[2:0];
   
   assign               wr_transfer_pre      = WVALID & WREADY;
   
   assign               wr_transfer_size_pre =
                  WID_data[5:4] == 2'b00 ? 4'd1 :
                  WID_data[5:4] == 2'b01 ? 4'd2 :
                  WID_data[5:4] == 2'b10 ? 4'd4 : 4'd8;
   
   prgen_delay #(1) delay_wr_transfer (.clk(clk), .reset(reset), .din(wr_transfer_pre), .dout(wr_transfer));
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      wr_transfer_num  <= #1 3'd0;
      wr_transfer_size <= #1 3'd0;
       end
     else if (wr_transfer_pre)
       begin
      wr_transfer_num  <= #1 wr_transfer_num_pre;
      wr_transfer_size <= #1 wr_transfer_size_pre;
       end
   
   
   assign               valid_last      = ch_fifo_rd & (rd_out_count == WLEN_cmd) & (~cmd_empty);
      
   assign               wr_clr_line_pre = valid_last & line_end;
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_clr_line_num <= #1 3'd0;
     else if (wr_clr_line_pre)
       wr_clr_line_num <= #1 line_end_num;

   assign wr_clr_line_stall_pre = wr_clr_line_pre & (ch_fifo_rd_num == line_end_num);

   prgen_delay #(1) delay_stall (.clk(clk), .reset(reset), .din(wr_clr_line_stall_pre), .dout(wr_clr_line_stall));

   prgen_delay #(2) delay_clr_line (.clk(clk), .reset(reset), .din(wr_clr_line_pre), .dout(wr_clr_line));
   
   
   //command phase
   assign               wr_cmd_full = cmd_full | cmd_data_full | wr_resp_full;

   assign               cmd_push = AWVALID & AWREADY;
   assign               cmd_pop  = valid_last;
   
   assign               WID_pre   = AWID;
   assign               WLEN_pre  = AWLEN;
   assign               WSIZE_pre = AWSIZE;


   //always @(/*AUTOSENSE*/ - no AUTOSENSE due to defines
   always @(AWADDR or AWSIZE)
     begin              
    case ({AWSIZE[1:0], AWADDR[1:0]})
      //8 bit
      {2'b00, 2'b00} : WSTRB_pre = 4'b0001;
      {2'b00, 2'b01} : WSTRB_pre = 4'b0010;
      {2'b00, 2'b10} : WSTRB_pre = 4'b0100;
      {2'b00, 2'b11} : WSTRB_pre = 4'b1000;

      //16 bit
      {2'b01, 2'b00} : WSTRB_pre = 4'b0011;
      {2'b01, 2'b10} : WSTRB_pre = 4'b1100;

      //32 bit
      default : WSTRB_pre = 4'b1111;
    endcase
     end

   
   prgen_fifo #(`CMD_BITS+`LEN_BITS+2+1, 2) 
   cmd_fifo(
        .clk(clk),
        .reset(reset),
        .push(cmd_push),
        .pop(cmd_pop),
        .din({WID_pre,  
          WSIZE_pre,
          WLEN_pre,
          AJOINT
          }
         ),
        .dout({WID_cmd,
           WSIZE_cmd,
           WLEN_cmd,
           joint_req_out
           }
          ),
        .empty(cmd_empty),
        .full(cmd_full)
        );


   assign               line_end     = WID_cmd[6];
   assign               line_end_num = WID_cmd[2:0];
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_out_count <= #1 {`LEN_BITS{1'b0}};
     else if (cmd_pop)
       rd_out_count <= #1 {`LEN_BITS{1'b0}};
     else if (ch_fifo_rd)
       rd_out_count <= #1 rd_out_count + 1'b1;

   
   //data phase
   assign               cmd_data_push = cmd_push;
   assign               cmd_data_pop  = WVALID & WREADY & WLAST;

   assign               WSTRB = WSTRB_data & {4{WVALID}};
   
   assign               WID   = WID_data;
   

   
   prgen_fifo #(4+`LEN_BITS+`CMD_BITS+2, 2) 
   cmd_data_fifo(
         .clk(clk),
         .reset(reset),
         .push(cmd_data_push),
         .pop(cmd_data_pop),
         .din({WLEN_pre,
               WSIZE_pre,
               WSTRB_pre,
               WID_pre
               }),
         .dout({WLEN_data,
            WSIZE_data,
            WSTRB_data,
            WID_data
            }),
         .empty(cmd_data_empty),
         .full(cmd_data_full)
         );
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_in_count <= #1 {`LEN_BITS{1'b0}};
     else if (cmd_data_pop)
       rd_in_count <= #1 {`LEN_BITS{1'b0}};
     else if (wr_transfer_pre)
       rd_in_count <= #1 rd_in_count + 1'b1;


   
   //data fifo
   assign               data_push = ch_fifo_rd_valid;
   assign               data_pop  = wr_transfer_pre;

      
   //depth is set by maximum fifo read data latency
   prgen_fifo #(32, 5+2)
   data_fifo(
         .clk(clk),
         .reset(reset),
         .push(data_push),
         .pop(data_pop),
         .din(ch_fifo_rdata),
         .dout(WDATA),
         .empty(data_empty),
         .full(data_full)
         );
   
   assign               WVALID = ~data_empty;

   assign               WLAST  = WVALID & (rd_in_count == WLEN_data) & (~cmd_data_empty);


   
   dma_axi32_core0_axim_timeout  dma_axi32_axim_timeout (
                         .clk(clk),
                         .reset(reset),
                         .VALID(WVALID),
                         .READY(WREADY),
                         .ID(WID),
                         .axim_timeout_num(axim_timeout_num),
                         .axim_timeout(axim_timeout)
                         );
   
endmodule

   



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: dma_core_axim_wr.v
//---------------------------------------------------------



module dma_axi32_core0_axim_wr(clk,reset,wr_cmd_port,wr_last_cmd,wr_line_cmd,wr_ch_num,wr_burst_start,wr_burst_addr,wr_burst_size,wr_cmd_pending,wr_cmd_split,wr_cmd_num,rd_transfer,rd_transfer_size,ch_fifo_rd,ch_fifo_rdata,ch_fifo_rd_valid,ch_fifo_rsize,ch_fifo_wr_ready,ch_fifo_rd_num,wr_transfer_num,wr_transfer,wr_transfer_size,wr_next_size,wr_cmd_full,wr_clr_line,wr_clr_line_num,wr_slverr,wr_decerr,wr_clr,wr_clr_last,wr_ch_num_resp,page_cross,AWADDR,AWPORT,AWLEN,AWSIZE,AWVALID,AWREADY,WDATA,WSTRB,WLAST,WVALID,WREADY,BRESP,BVALID,BREADY,joint_req,joint_stall,axim_timeout_aw,axim_timeout_w,axim_timeout_num_aw,axim_timeout_num_w);

   input               clk;
   input               reset;
   
   //command
   input               wr_cmd_port;
   input               wr_last_cmd;
   input               wr_line_cmd;
   input [2:0]               wr_ch_num;
   input               wr_burst_start;
   input [32-1:0]      wr_burst_addr;
   input [7-1:0]     wr_burst_size;
   output               wr_cmd_pending;
   output               wr_cmd_split;
   output [2:0]           wr_cmd_num;

   //data
   input               rd_transfer;
   input [3-1:0]      rd_transfer_size;              
   output               ch_fifo_rd;
   input [32-1:0]      ch_fifo_rdata;
   input               ch_fifo_rd_valid;
   output [3-1:0]     ch_fifo_rsize;
   input               ch_fifo_wr_ready;
   output [2:0]           ch_fifo_rd_num;
   output [2:0]           wr_transfer_num;
   output               wr_transfer;
   output [3-1:0]     wr_transfer_size;
   output [3-1:0]     wr_next_size;
   output               wr_cmd_full;
   output               wr_clr_line;
   output [2:0]           wr_clr_line_num;
   
   //resp
   output               wr_slverr;
   output               wr_decerr;
   output               wr_clr;
   output               wr_clr_last;
   output [2:0]           wr_ch_num_resp;

   output               page_cross;
   
   output [32-1:0]     AWADDR;
   output               AWPORT;
   output [`LEN_BITS-1:0]     AWLEN;
   output [1:0]           AWSIZE;
   output               AWVALID;
   input               AWREADY;
   output [32-1:0]     WDATA;
   output [4-1:0]     WSTRB;
   output               WLAST;
   output               WVALID;
   input               WREADY;
   input [1:0]               BRESP;
   input               BVALID;
   output               BREADY;
   
   input               joint_req;
   output               joint_stall;
   
   output               axim_timeout_aw;
   output               axim_timeout_w;
   output [2:0]           axim_timeout_num_aw;
   output [2:0]           axim_timeout_num_w;


   
   wire [`CMD_BITS-1:0]       AWID;
   wire               AJOINT;
   wire               BVALID_d;
   wire [`CMD_BITS-1:0]       BID;
   reg [1:0]               BRESP_d;
   wire               wr_resp_full;
   

   assign               BREADY   = 1'b1;
   
   
   prgen_delay #(1) delay_bvalid(.clk(clk), .reset(reset), .din(BVALID), .dout(BVALID_d));

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      BRESP_d <= #1 2'b00;
       end
     else if (BVALID)
       begin
      BRESP_d <= #1 BRESP;
       end

   
   dma_axi32_core0_axim_cmd
   dma_axi32_axim_wcmd (
             .clk(clk),
             .reset(reset),
             .end_line_cmd(wr_line_cmd),
             .extra_bit(wr_last_cmd),
             .cmd_port(wr_cmd_port),
             .joint_req(joint_req),
             .ch_num(wr_ch_num),
             .burst_start(wr_burst_start),
             .burst_addr(wr_burst_addr),
             .burst_size(wr_burst_size),
             .cmd_pending(wr_cmd_pending),
             .cmd_full(wr_cmd_full),
             .cmd_split(wr_cmd_split),
             .cmd_num(wr_cmd_num),
             .cmd_line(),
             .page_cross(page_cross),
             .AID(AWID),
             .AADDR(AWADDR),
             .APORT(AWPORT),
             .ALEN(AWLEN),
             .ASIZE(AWSIZE),
             .AVALID(AWVALID),
             .AREADY(AWREADY),
             .AWVALID(1'b0),
             .AJOINT(AJOINT),
             .axim_timeout_num(axim_timeout_num_aw),
             .axim_timeout(axim_timeout_aw)
             );

   
   dma_axi32_core0_axim_wdata
   dma_axi32_axim_wdata (
              .clk(clk),
              .reset(reset),
              .joint_stall(joint_stall),
              .rd_transfer(rd_transfer),
              .rd_transfer_size(rd_transfer_size),
              .ch_fifo_rd(ch_fifo_rd),
              .ch_fifo_rdata(ch_fifo_rdata),
              .ch_fifo_rd_valid(ch_fifo_rd_valid),
              .ch_fifo_rsize(ch_fifo_rsize),
              .ch_fifo_rd_num(ch_fifo_rd_num),
              .ch_fifo_wr_ready(ch_fifo_wr_ready),
              .wr_transfer_num(wr_transfer_num),
              .wr_transfer(wr_transfer),
              .wr_transfer_size(wr_transfer_size),
              .wr_next_size(wr_next_size),
              .wr_resp_full(wr_resp_full),
              .wr_cmd_full(wr_cmd_full),
              .wr_clr_line(wr_clr_line),
              .wr_clr_line_num(wr_clr_line_num),
              .AWID(AWID),
              .AWADDR(AWADDR),
              .AWLEN(AWLEN),
              .AWSIZE(AWSIZE),
              .AWVALID(AWVALID),
              .AWREADY(AWREADY),
              .AJOINT(AJOINT),
              .WDATA(WDATA),
              .WSTRB(WSTRB),
              .WLAST(WLAST),
              .WVALID(WVALID),
              .WREADY(WREADY),
              .axim_timeout_num(axim_timeout_num_w),
              .axim_timeout(axim_timeout_w)
              );

   
   dma_axi32_core0_axim_resp #(.CMD_DEPTH(2))
   dma_axi32_axim_wresp (
              .clk(clk),
              .reset(reset),
              .slverr(wr_slverr),
              .decerr(wr_decerr),
              .clr(wr_clr),
              .clr_last(wr_clr_last),
              .ch_num_resp(wr_ch_num_resp),
              .resp_full(wr_resp_full),
              .AID(AWID),
              .AVALID(AWVALID),
              .AREADY(AWREADY),
              .ID(BID),
              .RESP(BRESP_d),
              .VALID(BVALID_d),
              .READY(BREADY),
              .LAST(1'b1)
              );

   
endmodule

   



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_channels_apb_mux.v
//---------------------------------------------------------



module  dma_axi32_core0_channels_apb_mux (clk,reset,pclken,psel,penable,paddr,prdata,pslverr,ch_psel,ch_prdata,ch_pslverr);

   input                 clk;
   input                 reset;

   input          pclken;
   input          psel;
   input                 penable;
   input [10:8]          paddr;
   output [31:0]         prdata;
   output          pslverr;

   output [7:0]      ch_psel;
   input [32*8-1:0]      ch_prdata;
   input [7:0]          ch_pslverr;

 
   wire [2:0]          paddr_sel;
   reg [2:0]          paddr_sel_d;


   
   always @(posedge clk or posedge reset)
     if (reset)
       paddr_sel_d <= #1 3'b000;
     else if (psel & (~penable))
       paddr_sel_d <= #1 paddr_sel;
     else if ((~psel) & pclken) //release for empty channels after error
       paddr_sel_d <= #1 3'b000;
   
   
   
   assign          paddr_sel = paddr[10:8];
   
   prgen_demux8 #(1) mux_psel(
                  .sel(paddr_sel),
                  .x(psel),
                  .ch_x(ch_psel)
                  );

   
   prgen_mux8 #(32) mux_prdata(
                   .sel(paddr_sel_d),
                   
                   .ch_x(ch_prdata),
                   .x(prdata)
                   );


   assign                pslverr = ch_pslverr[paddr_sel_d];
   
endmodule







   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_channels_mux.v
//---------------------------------------------------------



module dma_axi32_core0_channels_mux(ch_fifo_rd_valid,fifo_rd_valid,ch_fifo_rdata,fifo_rdata,ch_periph_rx_clr,periph_rx_clr,ch_periph_tx_clr,periph_tx_clr,ch_rd_page_cross,ch_wr_page_cross,rd_page_cross,wr_page_cross,timeout_aw,timeout_w,timeout_ar,timeout_num_aw,timeout_num_w,timeout_num_ar,wdt_timeout,wdt_ch_num,ch_timeout_aw,ch_timeout_w,ch_timeout_ar,ch_wdt_timeout,joint_in_prog,joint_not_in_prog,joint_mux_in_prog,ch_joint_in_prog,ch_joint_not_in_prog,ch_joint_mux_in_prog,wr_cmd_pending,ch_wr_cmd_pending,rd_ch_num,rd_cmd_num,load_req_in_prog,rd_line_cmd,rd_go_next_line,rd_burst_start,rd_burst_addr,rd_burst_size,rd_tokens,rd_cmd_port,rd_periph_delay,rd_clr_valid,rd_cmd_split,rd_cmd_line,rd_clr_stall,ch_load_req_in_prog,ch_rd_line_cmd,ch_rd_go_next_line,ch_rd_burst_start,ch_rd_burst_addr,ch_rd_burst_size,ch_rd_tokens,ch_rd_port_num,ch_rd_periph_delay,ch_rd_clr_valid,ch_rd_cmd_split,ch_rd_cmd_line,ch_rd_clr_stall,load_wr_num,load_wr,ch_load_wr,ch_fifo_wr_num,rd_transfer_num,rd_clr_line_num,rd_transfer,rd_clr_line,fifo_wr,ch_rd_transfer,ch_rd_clr_line,ch_fifo_wr,rd_ch_num_resp,rd_slverr,rd_decerr,rd_clr,rd_clr_load,ch_rd_slverr,ch_rd_decerr,ch_rd_clr,ch_rd_clr_load,wr_ch_num,wr_cmd_num,wr_last_cmd,wr_line_cmd,wr_go_next_line,wr_burst_start,wr_burst_addr,wr_burst_size,wr_tokens,wr_cmd_port,wr_periph_delay,wr_clr_valid,wr_cmd_split,wr_clr_stall,ch_wr_last_cmd,ch_wr_line_cmd,ch_wr_go_next_line,ch_wr_burst_start,ch_wr_burst_addr,ch_wr_burst_size,ch_wr_tokens,ch_wr_port_num,ch_wr_periph_delay,ch_wr_clr_valid,ch_wr_cmd_split,ch_wr_clr_stall,ch_fifo_rd_num,wr_transfer_num,wr_clr_line_num,wr_transfer,wr_clr_line,fifo_rd,ch_fifo_wr_ready,ch_wr_transfer,ch_wr_clr_line,ch_fifo_rd,fifo_wr_ready,wr_ch_num_resp,wr_slverr,wr_decerr,wr_clr,wr_clr_last,ch_wr_slverr,ch_wr_decerr,ch_wr_clr_last,ch_wr_clr);

   //data
   input [7:0]               ch_fifo_rd_valid;
   output               fifo_rd_valid;
   input [8*32-1:0]    ch_fifo_rdata;
   output [32-1:0]     fifo_rdata;
   
   //periph
   input [8*31-1:0]           ch_periph_rx_clr;
   output [30:0]           periph_rx_clr;
   input [8*31-1:0]           ch_periph_tx_clr;
   output [30:0]           periph_tx_clr;

   output [7:0]           ch_rd_page_cross;
   output [7:0]           ch_wr_page_cross;
   input               rd_page_cross;
   input               wr_page_cross;
   
   //axim timeout
   input               timeout_aw;
   input               timeout_w;
   input               timeout_ar;
   input [2:0]               timeout_num_aw;
   input [2:0]               timeout_num_w;
   input [2:0]               timeout_num_ar;
   input               wdt_timeout;
   input [2:0]               wdt_ch_num;

   output [7:0]           ch_timeout_aw;
   output [7:0]           ch_timeout_w;
   output [7:0]           ch_timeout_ar;
   output [7:0]           ch_wdt_timeout;

   output               joint_in_prog;
   output               joint_not_in_prog;
   output               joint_mux_in_prog;
   input [7:0]               ch_joint_in_prog;
   input [7:0]               ch_joint_not_in_prog;
   input [7:0]               ch_joint_mux_in_prog;

   input               wr_cmd_pending;
   output [7:0]           ch_wr_cmd_pending;
   
   //rd cmd
   input [2:0]               rd_ch_num;
   input [2:0]               rd_cmd_num;
   
   output               load_req_in_prog;
   output               rd_line_cmd;
   output               rd_go_next_line;
   input               rd_burst_start;
   output [32-1:0]     rd_burst_addr;
   output [7-1:0]    rd_burst_size;
   output [`TOKEN_BITS-1:0]   rd_tokens;
   output               rd_cmd_port;
   output [`DELAY_BITS-1:0]   rd_periph_delay;    
   output               rd_clr_valid;
   input               rd_cmd_split;
   input               rd_cmd_line;
   output               rd_clr_stall; 
   
   input [7:0]               ch_load_req_in_prog;
   input [7:0]               ch_rd_line_cmd;
   input [7:0]               ch_rd_go_next_line;
   output [7:0]           ch_rd_burst_start;
   input [8*32-1:0]    ch_rd_burst_addr;
   input [8*7-1:0]   ch_rd_burst_size;
   input [8*`TOKEN_BITS-1:0]  ch_rd_tokens;
   input [7:0]               ch_rd_port_num;
   input [8*`DELAY_BITS-1:0]  ch_rd_periph_delay;
   input [7:0]               ch_rd_clr_valid;
   output [7:0]           ch_rd_cmd_split;
   output [7:0]           ch_rd_cmd_line;
   input [7:0]               ch_rd_clr_stall; 
   
   //rd data - load cmd
   input [2:0]               load_wr_num;
   
   input               load_wr;
   
   output [7:0]           ch_load_wr;
   
   //rd data
   input [2:0]               ch_fifo_wr_num;
   input [2:0]               rd_transfer_num;
   input [2:0]               rd_clr_line_num;
   
   input               rd_transfer;
   input               rd_clr_line;
   input               fifo_wr;
   
   output [7:0]           ch_rd_transfer;
   output [7:0]           ch_rd_clr_line;
   output [7:0]           ch_fifo_wr;
   
   //rd resp
   input [2:0]               rd_ch_num_resp;
   
   input               rd_slverr;
   input               rd_decerr;
   input               rd_clr;
   input               rd_clr_load;
   
   output [7:0]           ch_rd_slverr;
   output [7:0]           ch_rd_decerr;
   output [7:0]           ch_rd_clr;
   output [7:0]           ch_rd_clr_load;

   //wr cmd
   input [2:0]               wr_ch_num;
   input [2:0]               wr_cmd_num;
   
   output               wr_last_cmd;
   output               wr_line_cmd;
   output               wr_go_next_line;
   input               wr_burst_start;
   output [32-1:0]     wr_burst_addr;
   output [7-1:0]    wr_burst_size;
   output [`TOKEN_BITS-1:0]   wr_tokens;
   output               wr_cmd_port;    
   output [`DELAY_BITS-1:0]   wr_periph_delay;    
   output               wr_clr_valid;
   input               wr_cmd_split;
   output               wr_clr_stall; 
   
   input [7:0]               ch_wr_last_cmd;
   input [7:0]               ch_wr_line_cmd;
   input [7:0]               ch_wr_go_next_line;
   output [7:0]           ch_wr_burst_start;
   input [8*32-1:0]    ch_wr_burst_addr;
   input [8*7-1:0]   ch_wr_burst_size;
   input [8*`TOKEN_BITS-1:0]  ch_wr_tokens;
   input [7:0]               ch_wr_port_num;
   input [8*`DELAY_BITS-1:0]  ch_wr_periph_delay;
   input [7:0]               ch_wr_clr_valid;
   output [7:0]           ch_wr_cmd_split;
   input [7:0]               ch_wr_clr_stall; 
   
   //wr data
   input [2:0]               ch_fifo_rd_num;
   input [2:0]               wr_transfer_num;
   input [2:0]               wr_clr_line_num;
   
   input               wr_transfer;
   input               wr_clr_line;
   input               fifo_rd;
   input [7:0]               ch_fifo_wr_ready;
   
   output [7:0]           ch_wr_transfer;
   output [7:0]           ch_wr_clr_line;
   output [7:0]           ch_fifo_rd;
   output               fifo_wr_ready;
   
   //wr resp
   input [2:0]               wr_ch_num_resp;
   
   input               wr_slverr;
   input               wr_decerr;
   input               wr_clr;
   input               wr_clr_last;

   output [7:0]           ch_wr_slverr;
   output [7:0]           ch_wr_decerr;
   output [7:0]           ch_wr_clr_last;
   output [7:0]           ch_wr_clr;

   
   
   
   prgen_or8 #(1) 
   mux_2(.ch_x(ch_fifo_rd_valid),
     .x(fifo_rd_valid)
     );
   
   prgen_or8 #(32) 
   mux_3(.ch_x(ch_fifo_rdata),
     .x(fifo_rdata)
     );

   prgen_or8 #(31) 
   mux_4(.ch_x(ch_periph_rx_clr),
     .x(periph_rx_clr)
     );
   
   prgen_or8 #(31) 
   mux_5(.ch_x(ch_periph_tx_clr),
     .x(periph_tx_clr)
     );
   
   prgen_mux8 #(`DELAY_BITS) 
   mux_30(.sel(rd_ch_num),
      .ch_x(ch_rd_periph_delay),
      .x(rd_periph_delay)
      );
   
   prgen_mux8 #(`DELAY_BITS) 
   mux_51(.sel(wr_ch_num),
      .ch_x(ch_wr_periph_delay),
      .x(wr_periph_delay)
      );
   
   
   prgen_demux8 #(1) 
   mux_6(.sel(timeout_num_aw),
     .x(timeout_aw),
     .ch_x(ch_timeout_aw)
     );
   
   prgen_demux8 #(1) 
   mux_7(.sel(timeout_num_w),
     .x(timeout_w),
     .ch_x(ch_timeout_w)
     );
   
   prgen_demux8 #(1) 
   mux_8(.sel(timeout_num_ar),
     .x(timeout_ar),
     .ch_x(ch_timeout_ar)
     );
   
   prgen_demux8 #(1) 
   mux_9(.sel(wdt_ch_num),
     .x(wdt_timeout),
     .ch_x(ch_wdt_timeout)
     );

   prgen_or8 #(1) 
   mux_55(.ch_x(ch_joint_in_prog),
      .x(joint_in_prog)
      );
   
   prgen_or8 #(1) 
   mux_56(.ch_x(ch_joint_not_in_prog),
      .x(joint_not_in_prog)
      );
   
   prgen_or8 #(1) 
   mux_57(.ch_x(ch_joint_mux_in_prog),
      .x(joint_mux_in_prog)
      );
   
   prgen_demux8 #(1) 
   mux_60(.sel(wr_ch_num),
      .x(wr_cmd_pending),
      .ch_x(ch_wr_cmd_pending)
      );

   
   prgen_demux8 #(1) 
   mux_11(.sel(rd_ch_num),
      .x(rd_burst_start),
      .ch_x(ch_rd_burst_start)
      );
  
   prgen_demux8 #(1) 
   mux_13(.sel(load_wr_num),
      .x(load_wr),
      .ch_x(ch_load_wr)
      );
   
   assign               ch_rd_clr_line  = 'd0;
   assign               ch_rd_cmd_line  = 'd0;
   assign               rd_line_cmd     = 'd0;
   assign               rd_go_next_line = 'd0;
   assign               rd_clr_stall    = 'd0;
   assign               wr_clr_stall    = 'd0;
   assign               ch_wr_clr_line  = 'd0;
   assign               wr_line_cmd     = 'd0;
   assign               wr_go_next_line = 'd0;
   
   prgen_mux8 #(1) 
   mux_33(.sel(rd_ch_num),
      .ch_x(ch_rd_clr_valid),
      .x(rd_clr_valid)
      );

   prgen_mux8 #(1) 
   mux_53(.sel(wr_ch_num),
      .ch_x(ch_wr_clr_valid),
      .x(wr_clr_valid)
      );
   
   prgen_demux8 #(1) 
   mux_15(.sel(rd_transfer_num),
      .x(rd_transfer),
      .ch_x(ch_rd_transfer)
      );
   
   prgen_demux8 #(1) 
   mux_16(.sel(rd_ch_num_resp),
      .x(rd_slverr),
      .ch_x(ch_rd_slverr)
      );
   
   prgen_demux8 #(1) 
   mux_17(.sel(rd_ch_num_resp),
      .x(rd_decerr),
      .ch_x(ch_rd_decerr)
      );
   
   prgen_demux8 #(1) 
   mux_39(.sel(wr_ch_num_resp),
      .x(wr_decerr),
      .ch_x(ch_wr_decerr)
      );
   
   prgen_demux8 #(1) 
   mux_20(.sel(rd_cmd_num),
      .x(rd_cmd_split),
      .ch_x(ch_rd_cmd_split)
      );
   
   prgen_demux8 #(1) 
   mux_42(.sel(wr_cmd_num),
      .x(wr_cmd_split),
      .ch_x(ch_wr_cmd_split)
      );
   
   prgen_demux8 #(1) 
   mux_58(.sel(rd_ch_num),
      .x(rd_page_cross),
      .ch_x(ch_rd_page_cross)
      );
   
   prgen_demux8 #(1) 
   mux_59(.sel(wr_ch_num),
      .x(wr_page_cross),
      .ch_x(ch_wr_page_cross)
      );
   
   
   prgen_demux8 #(1) 
   mux_18(.sel(rd_ch_num_resp),
      .x(rd_clr),
      .ch_x(ch_rd_clr)
      );
   
   prgen_demux8 #(1) 
   mux_19(.sel(rd_ch_num_resp),
      .x(rd_clr_load),
      .ch_x(ch_rd_clr_load)
      );
   
   prgen_demux8 #(1) 
   mux_21(.sel(ch_fifo_rd_num),
      .x(fifo_rd),
      .ch_x(ch_fifo_rd)
      );
   
   prgen_mux8 #(1) 
   mux_23(.sel(rd_ch_num),
      .ch_x(ch_load_req_in_prog),
      .x(load_req_in_prog)
      );
   
   prgen_mux8 #(32) 
   mux_26(.sel(rd_ch_num),
      .ch_x(ch_rd_burst_addr),
      .x(rd_burst_addr)
      );
   
   prgen_mux8 #(7) 
   mux_27(.sel(rd_ch_num),
      .ch_x(ch_rd_burst_size),
      .x(rd_burst_size)
      );
   
   prgen_mux8 #(`TOKEN_BITS) 
   mux_28(.sel(rd_ch_num),
      .ch_x(ch_rd_tokens),
      .x(rd_tokens)
      );
   
   prgen_mux8 #(`TOKEN_BITS) 
   mux_49(.sel(wr_ch_num),
      .ch_x(ch_wr_tokens),
      .x(wr_tokens)
      );

   assign               rd_cmd_port = 'd0;
   assign               wr_cmd_port = 'd0;
   
   
   prgen_mux8 #(1) 
   mux_31(.sel(ch_fifo_rd_num),
      .ch_x(ch_fifo_wr_ready),
      .x(fifo_wr_ready)
      );
   
   prgen_demux8 #(1) 
   mux_34(.sel(wr_ch_num),
      .x(wr_burst_start),
      .ch_x(ch_wr_burst_start)
      );
   
   prgen_demux8 #(1) 
   mux_37(.sel(wr_transfer_num),
      .x(wr_transfer),
      .ch_x(ch_wr_transfer)
      );
   
   prgen_demux8 #(1) 
   mux_38(.sel(wr_ch_num_resp),
      .x(wr_slverr),
      .ch_x(ch_wr_slverr)
      );
   
   prgen_demux8 #(1) 
   mux_40(.sel(wr_ch_num_resp),
      .x(wr_clr),
      .ch_x(ch_wr_clr)
      );
   
   prgen_demux8 #(1) 
   mux_41(.sel(wr_ch_num_resp),
      .x(wr_clr_last),
      .ch_x(ch_wr_clr_last)
      );
      
   prgen_demux8 #(1) 
   mux_43(.sel(ch_fifo_wr_num),
      .x(fifo_wr),
      .ch_x(ch_fifo_wr)
      );
   
   prgen_mux8 #(1) 
   mux_44(.sel(wr_ch_num),
      .ch_x(ch_wr_last_cmd),
      .x(wr_last_cmd)
      );
      
   prgen_mux8 #(32) 
   mux_47(.sel(wr_ch_num),
      .ch_x(ch_wr_burst_addr),
      .x(wr_burst_addr)
      );
   
   prgen_mux8 #(7) 
   mux_48(.sel(wr_ch_num),
      .ch_x(ch_wr_burst_size),
      .x(wr_burst_size)
      );
        
   
   
endmodule



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_core_channels.v
//---------------------------------------------------------



module dma_axi32_core0_channels(clk,reset,scan_en,pclk,clken,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,rd_clr_valid,wr_clr_valid,rd_clr,rd_clr_load,wr_clr,rd_cmd_split,rd_cmd_line,rd_cmd_num,wr_cmd_split,wr_cmd_pending,wr_cmd_num,rd_clr_stall,wr_clr_stall,load_wr,load_wr_num,load_wr_cycle,load_wdata,rd_ch_num,load_req_in_prog,wr_ch_num,wr_last_cmd,rd_slverr,rd_decerr,wr_slverr,wr_decerr,rd_ch_num_resp,wr_ch_num_resp,wr_clr_last,ch_int_all_proc,ch_start,ch_idle,ch_active,ch_rd_active,ch_wr_active,rd_line_cmd,wr_line_cmd,rd_go_next_line,wr_go_next_line,timeout_aw,timeout_w,timeout_ar,timeout_num_aw,timeout_num_w,timeout_num_ar,wdt_timeout,wdt_ch_num,ch_fifo_wr_num,rd_transfer_num,rd_burst_start,rd_transfer,rd_transfer_size,rd_clr_line,rd_clr_line_num,fifo_rd,fifo_rsize,fifo_rd_valid,fifo_rdata,fifo_wr_ready,ch_rd_ready,rd_burst_addr,rd_burst_size,rd_tokens,rd_cmd_port,rd_periph_delay,ch_fifo_rd_num,wr_transfer_num,wr_burst_start,wr_transfer,wr_transfer_size,wr_next_size,wr_clr_line,wr_clr_line_num,fifo_wr,fifo_wdata,fifo_wsize,ch_wr_ready,wr_burst_addr,wr_burst_size,wr_tokens,wr_cmd_port,wr_periph_delay,joint_mode,joint_remote,rd_page_cross,wr_page_cross,joint_in_prog,joint_not_in_prog,joint_mux_in_prog,ch_joint_req);

   input             clk;
   input             reset;
   input             scan_en;
   
   input             pclk;
   input             clken;
   input             pclken;
   input             psel;
   input             penable;
   input [10:0]         paddr;
   input             pwrite;
   input [31:0]         pwdata;
   output [31:0]         prdata;
   output             pslverr;
   
   input [31:1]         periph_tx_req;
   output [31:1]         periph_tx_clr;
   input [31:1]         periph_rx_req;
   output [31:1]         periph_rx_clr;
   output             rd_clr_valid;
   output             wr_clr_valid;
   input             rd_clr;
   input             rd_clr_load;
   input             wr_clr;
   input             rd_cmd_split;
   input             rd_cmd_line;
   input [2:0]             rd_cmd_num;
   input             wr_cmd_split;
   input             wr_cmd_pending;
   input [2:0]             wr_cmd_num;
   output             rd_clr_stall;
   output             wr_clr_stall;
   
   input             load_wr;
   input [2:0]             load_wr_num;
   input [1:0]             load_wr_cycle;
   input [32-1:0]    load_wdata;

   input [2:0]             rd_ch_num;
   output             load_req_in_prog;
   
   input [2:0]             wr_ch_num;
   output             wr_last_cmd;
   
   input             rd_slverr;
   input             rd_decerr;
   input             wr_slverr;
   input             wr_decerr;
   input [2:0]             rd_ch_num_resp;
   input [2:0]             wr_ch_num_resp;
   input             wr_clr_last;
   output [8*1-1:0]  ch_int_all_proc;
   input [7:0]                ch_start;
   output [7:0]          ch_idle;
   output [7:0]          ch_active;
   output [7:0]          ch_rd_active;
   output [7:0]          ch_wr_active;
   output              rd_line_cmd;
   output              wr_line_cmd;
   output              rd_go_next_line;
   output              wr_go_next_line;
   
   input              timeout_aw;
   input              timeout_w;
   input              timeout_ar;
   input [2:0]              timeout_num_aw;
   input [2:0]              timeout_num_w;
   input [2:0]              timeout_num_ar;
   input              wdt_timeout;
   input [2:0]              wdt_ch_num;
   
   input [2:0]              ch_fifo_wr_num;
   input [2:0]              rd_transfer_num;
   input              rd_burst_start;
   input              rd_transfer;
   input [3-1:0]     rd_transfer_size;
   input              rd_clr_line;
   input [2:0]              rd_clr_line_num;
   input              fifo_rd;
   input [3-1:0]     fifo_rsize;
   output              fifo_rd_valid;
   output [32-1:0]    fifo_rdata;
   output              fifo_wr_ready;
   output [7:0]          ch_rd_ready;
   output [32-1:0]    rd_burst_addr;
   output [7-1:0]   rd_burst_size;
   output [`TOKEN_BITS-1:0]  rd_tokens;
   output              rd_cmd_port;
   
   output [`DELAY_BITS-1:0]  rd_periph_delay; 

   input [2:0]              ch_fifo_rd_num;
   input [2:0]              wr_transfer_num;
   input              wr_burst_start; 
   input              wr_transfer;
   input [3-1:0]     wr_transfer_size;
   input [3-1:0]     wr_next_size;
   input              wr_clr_line;
   input [2:0]              wr_clr_line_num;
   input              fifo_wr;
   input [32-1:0]     fifo_wdata;
   input [3-1:0]     fifo_wsize;
   output [7:0]          ch_wr_ready;
   output [32-1:0]    wr_burst_addr;
   output [7-1:0]   wr_burst_size;
   output [`TOKEN_BITS-1:0]  wr_tokens;
   output              wr_cmd_port;
   output [`DELAY_BITS-1:0]  wr_periph_delay;
   
   input              joint_mode;
   input              joint_remote;
   input              rd_page_cross;
   input              wr_page_cross;
   output              joint_in_prog;
   output              joint_not_in_prog;
   output              joint_mux_in_prog;
   output [7:0]          ch_joint_req;

   
   
   parameter              CH0 = 0;
   parameter              CH1 = 1;
   parameter              CH2 = 2;
   parameter              CH3 = 3;
   parameter              CH4 = 4;
   parameter              CH5 = 5;
   parameter              CH6 = 6;
   parameter              CH7 = 7;
   

   //apb buses
   wire [7:0]              ch_psel;
   wire [7:0]              ch_pslverr;
   wire [32*8-1:0]          ch_prdata;
   
   wire [7:0]              ch_joint_end;
   wire [7:0]              ch_joint_in_prog;
   wire [7:0]              ch_joint_not_in_prog;
   wire [7:0]              ch_joint_mux_in_prog;
   
   wire [7:0]              ch_rd_page_cross;
   wire [7:0]              ch_wr_page_cross;
   
   //axim signals
   wire [7:0]              ch_load_wr;
   wire [7:0]              ch_rd_clr_line;
   wire [7:0]              ch_rd_slverr;
   wire [7:0]              ch_rd_decerr;
   wire [7:0]              ch_rd_clr;
   wire [7:0]              ch_rd_clr_load;
   wire [7:0]              ch_rd_transfer;
   wire [7:0]              ch_rd_clr_stall;
   wire [7:0]              ch_rd_cmd_split;
   wire [7:0]              ch_rd_cmd_line;
   
   wire [7:0]              ch_wr_clr_line;
   wire [7:0]              ch_wr_slverr;
   wire [7:0]              ch_wr_decerr;
   wire [7:0]              ch_wr_clr_last;
   wire [7:0]              ch_wr_clr;
   wire [7:0]              ch_load_req_in_prog;
   wire [7:0]              ch_wr_last_cmd;
   wire [7:0]              ch_rd_line_cmd;
   wire [7:0]              ch_wr_line_cmd;
   wire [7:0]              ch_rd_go_next_line;
   wire [7:0]              ch_wr_go_next_line;
   wire [7:0]              ch_wr_transfer;
   wire [7:0]              ch_wr_clr_stall;
   wire [7:0]              ch_wr_cmd_split;
   wire [7:0]              ch_timeout_aw;
   wire [7:0]              ch_timeout_w;
   wire [7:0]              ch_timeout_ar;
   wire [7:0]              ch_wdt_timeout;
      
   //rd ctrl signals
   wire [7:0]              ch_rd_burst_start;
   wire [8*32-1:0]    ch_rd_burst_addr;
   wire [8*7-1:0]   ch_rd_burst_size;
   wire [8*`TOKEN_BITS-1:0]  ch_rd_tokens;
   wire [7:0]              ch_rd_port_num;
   wire [8*`DELAY_BITS-1:0]  ch_rd_periph_delay;
   wire [7:0]              ch_rd_clr_valid;
   
   //wr ctrl signals
   wire [7:0]              ch_wr_burst_start;
   wire [8*32-1:0]    ch_wr_burst_addr;
   wire [8*7-1:0]   ch_wr_burst_size;
   wire [8*`TOKEN_BITS-1:0]  ch_wr_tokens;
   wire [7:0]              ch_wr_port_num;
   wire [8*`DELAY_BITS-1:0]  ch_wr_periph_delay;
   wire [7:0]              ch_wr_clr_valid;
   
   //CLR buses
   wire [8*31-1:0]          ch_periph_rx_clr;
   wire [8*31-1:0]          ch_periph_tx_clr;

   //FIFO signals
   wire [7:0]              ch_fifo_wr;
   wire [7:0]              ch_fifo_rd;
   wire [7:0]              ch_fifo_rd_valid;
   wire [8*32-1:0]    ch_fifo_rdata;
   wire [7:0]              ch_fifo_wr_ready;

   wire [7:0]              ch_wr_cmd_pending;


   dma_axi32_core0_channels_apb_mux  dma_axi32_channels_apb_mux (
                               .clk(pclk),
                               .reset(reset),
                               .pclken(pclken),
                               .psel(psel),
                               .penable(penable),
                               .paddr(paddr[10:8]),
                               .prdata(prdata),
                               .pslverr(pslverr),
                               .ch_psel(ch_psel),
                               .ch_prdata(ch_prdata),
                               .ch_pslverr(ch_pslverr)
                               );


   dma_axi32_core0_channels_mux
   dma_axi32_channels_mux (
            .ch_joint_in_prog(ch_joint_in_prog),
            .ch_joint_not_in_prog(ch_joint_not_in_prog),
            .ch_joint_mux_in_prog(ch_joint_mux_in_prog),
            .joint_in_prog(joint_in_prog),
            .joint_not_in_prog(joint_not_in_prog),
            .joint_mux_in_prog(joint_mux_in_prog),

            .ch_rd_page_cross(ch_rd_page_cross),
            .ch_wr_page_cross(ch_wr_page_cross),
            .rd_page_cross(rd_page_cross),
            .wr_page_cross(wr_page_cross),

            .ch_wr_cmd_pending(ch_wr_cmd_pending),
            .wr_cmd_pending(wr_cmd_pending),
            
            //data
            .fifo_rdata(fifo_rdata),
            .ch_fifo_rdata(ch_fifo_rdata),
            .fifo_rd_valid(fifo_rd_valid),
            .ch_fifo_rd_valid(ch_fifo_rd_valid),
            
            //periph
            .periph_rx_clr(periph_rx_clr),
            .ch_periph_rx_clr(ch_periph_rx_clr),
            .periph_tx_clr(periph_tx_clr),
            .ch_periph_tx_clr(ch_periph_tx_clr),
            
            //axim timeout
            .timeout_aw(timeout_aw),
            .timeout_w(timeout_w),
            .timeout_ar(timeout_ar),
            .timeout_num_aw(timeout_num_aw),
            .timeout_num_w(timeout_num_w),
            .timeout_num_ar(timeout_num_ar),
            .wdt_timeout(wdt_timeout),
            .wdt_ch_num(wdt_ch_num),
                     
            .ch_timeout_aw(ch_timeout_aw),
                        .ch_timeout_w(ch_timeout_w),
                        .ch_timeout_ar(ch_timeout_ar),
                        .ch_wdt_timeout(ch_wdt_timeout),
            
            //rd cmd
            .rd_ch_num(rd_ch_num),
            .rd_cmd_num(rd_cmd_num),
      
            .load_req_in_prog(load_req_in_prog),
            .rd_line_cmd(rd_line_cmd),
            .rd_go_next_line(rd_go_next_line),
            .rd_burst_start(rd_burst_start),
            .rd_burst_addr(rd_burst_addr),
            .rd_burst_size(rd_burst_size),
            .rd_tokens(rd_tokens),
            .rd_cmd_port(rd_cmd_port),
            .rd_periph_delay(rd_periph_delay),
            .rd_clr_valid(rd_clr_valid),
            .rd_cmd_split(rd_cmd_split),
            .rd_cmd_line(rd_cmd_line),
            .rd_clr_stall(rd_clr_stall),
      
            .ch_load_req_in_prog(ch_load_req_in_prog),
            .ch_rd_line_cmd(ch_rd_line_cmd),
            .ch_rd_go_next_line(ch_rd_go_next_line),
            .ch_rd_burst_start(ch_rd_burst_start),
            .ch_rd_burst_addr(ch_rd_burst_addr),
            .ch_rd_burst_size(ch_rd_burst_size),
            .ch_rd_tokens(ch_rd_tokens),
            .ch_rd_port_num(ch_rd_port_num),
            .ch_rd_periph_delay(ch_rd_periph_delay),
            .ch_rd_clr_valid(ch_rd_clr_valid),
            .ch_rd_cmd_split(ch_rd_cmd_split),
            .ch_rd_cmd_line(ch_rd_cmd_line),
            .ch_rd_clr_stall(ch_rd_clr_stall),
      
            //rd data - load cmd
            .load_wr_num(load_wr_num),
      
            .load_wr(load_wr),
      
            .ch_load_wr(ch_load_wr),
      
            //rd data
            .ch_fifo_wr_num(ch_fifo_wr_num),
            .rd_transfer_num(rd_transfer_num),
            .rd_clr_line_num(rd_clr_line_num),
      
            .rd_transfer(rd_transfer),
            .rd_clr_line(rd_clr_line),
            .fifo_wr(fifo_wr),
      
            .ch_rd_clr_line(ch_rd_clr_line),
            .ch_rd_transfer(ch_rd_transfer),
            .ch_fifo_wr(ch_fifo_wr),
      
            //rd resp
            .rd_ch_num_resp(rd_ch_num_resp),
      
            .rd_slverr(rd_slverr),
            .rd_decerr(rd_decerr),
            .rd_clr(rd_clr),
            .rd_clr_load(rd_clr_load),
      
            .ch_rd_slverr(ch_rd_slverr),
            .ch_rd_decerr(ch_rd_decerr),
            .ch_rd_clr(ch_rd_clr),
            .ch_rd_clr_load(ch_rd_clr_load),
      
            //wr cmd
            .wr_ch_num(wr_ch_num),
            .wr_cmd_num(wr_cmd_num),
      
            .wr_last_cmd(wr_last_cmd),
            .wr_line_cmd(wr_line_cmd),
            .wr_go_next_line(wr_go_next_line),
            .wr_burst_start(wr_burst_start),
            .wr_burst_addr(wr_burst_addr),
            .wr_burst_size(wr_burst_size),
            .wr_tokens(wr_tokens),
            .wr_cmd_port(wr_cmd_port),
            .wr_periph_delay(wr_periph_delay),
            .wr_clr_valid(wr_clr_valid),
            .wr_cmd_split(wr_cmd_split),
            .wr_clr_stall(wr_clr_stall),
      
            .ch_wr_last_cmd(ch_wr_last_cmd),
            .ch_wr_line_cmd(ch_wr_line_cmd),
            .ch_wr_go_next_line(ch_wr_go_next_line),
            .ch_wr_burst_start(ch_wr_burst_start),
            .ch_wr_burst_addr(ch_wr_burst_addr),
            .ch_wr_burst_size(ch_wr_burst_size),
            .ch_wr_tokens(ch_wr_tokens),
            .ch_wr_port_num(ch_wr_port_num),
            .ch_wr_periph_delay(ch_wr_periph_delay),
            .ch_wr_clr_valid(ch_wr_clr_valid),
            .ch_wr_cmd_split(ch_wr_cmd_split),
            .ch_wr_clr_stall(ch_wr_clr_stall),
      
            //wr data
            .ch_fifo_rd_num(ch_fifo_rd_num),
            .wr_transfer_num(wr_transfer_num),
            .wr_clr_line_num(wr_clr_line_num),
      
            .wr_transfer(wr_transfer),
            .wr_clr_line(wr_clr_line),
            .fifo_rd(fifo_rd),
            .fifo_wr_ready(fifo_wr_ready),
      
            .ch_wr_transfer(ch_wr_transfer),
            .ch_wr_clr_line(ch_wr_clr_line),
            .ch_fifo_rd(ch_fifo_rd),
            .ch_fifo_wr_ready(ch_fifo_wr_ready),
      
            //wr resp
            .wr_ch_num_resp(wr_ch_num_resp),
      
            .wr_slverr(wr_slverr),
            .wr_decerr(wr_decerr),
            .wr_clr(wr_clr),
            .wr_clr_last(wr_clr_last),
      
            .ch_wr_slverr(ch_wr_slverr),
            .ch_wr_decerr(ch_wr_decerr),
            .ch_wr_clr_last(ch_wr_clr_last),
            .ch_wr_clr(ch_wr_clr)
            );


   
dma_axi32_core0_ch dma_axi32_core0_ch0 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[0]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[0]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*0:32*0]),
            .pslverr(ch_pslverr[0]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*0+31-1:31*0]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*0+31-1:31*0]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[0]),
            .rd_cmd_line(ch_rd_cmd_line[0]),
            .rd_clr_line(ch_rd_clr_line[0]),
            .rd_clr(ch_rd_clr[0]),
            .rd_clr_load(ch_rd_clr_load[0]),
            .rd_slverr(ch_rd_slverr[0]),
            .rd_decerr(ch_rd_decerr[0]),
            .rd_line_cmd(ch_rd_line_cmd[0]),
            .rd_go_next_line(ch_rd_go_next_line[0]),
            .rd_transfer(ch_rd_transfer[0]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[0]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[0]),
            .wr_cmd_pending(ch_wr_cmd_pending[0]),
            .wr_clr_line(ch_wr_clr_line[0]),
            .wr_clr(ch_wr_clr[0]),
            .wr_clr_last(ch_wr_clr_last[0]),
            .wr_slverr(ch_wr_slverr[0]),
            .wr_decerr(ch_wr_decerr[0]),
            .wr_last_cmd(ch_wr_last_cmd[0]),
            .wr_line_cmd(ch_wr_line_cmd[0]),
            .wr_go_next_line(ch_wr_go_next_line[0]),
            .wr_transfer(ch_wr_transfer[0]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[0]),

            .timeout_aw(ch_timeout_aw[0]),
            .timeout_w(ch_timeout_w[0]),
            .timeout_ar(ch_timeout_ar[0]),
            .wdt_timeout(ch_wdt_timeout[0]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[0]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[0]),

            //CTRL
            .ch_active(ch_active[0]),
            .ch_rd_active(ch_rd_active[0]),
            .ch_wr_active(ch_wr_active[0]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[0]),
            .rd_ready(ch_rd_ready[0]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*0:32*0]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*0:7*0]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*0:`TOKEN_BITS*0]),
            .rd_port_num(ch_rd_port_num[0]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*0:`DELAY_BITS*0]),
            .rd_clr_valid(ch_rd_clr_valid[0]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[0]),
            .wr_ready(ch_wr_ready[0]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*0:32*0]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*0:7*0]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*0:`TOKEN_BITS*0]),
            .wr_port_num(ch_wr_port_num[0]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*0:`DELAY_BITS*0]),
            .wr_clr_valid(ch_wr_clr_valid[0]),

            //FIFO
            .fifo_wr(ch_fifo_wr[0]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[0]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[0]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*0:32*0]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[0]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[0]),
            .wr_page_cross(ch_wr_page_cross[0]),
            .joint_in_prog(ch_joint_in_prog[0]),
            .joint_not_in_prog(ch_joint_not_in_prog[0]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[0]),
            .joint_req(ch_joint_req[0]),

            .ch_start(ch_start[0]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*0):1*0])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty1 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[1]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[1]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*1:32*1]),
            .pslverr(ch_pslverr[1]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*1+31-1:31*1]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*1+31-1:31*1]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[1]),
            .rd_cmd_line(ch_rd_cmd_line[1]),
            .rd_clr_line(ch_rd_clr_line[1]),
            .rd_clr(ch_rd_clr[1]),
            .rd_clr_load(ch_rd_clr_load[1]),
            .rd_slverr(ch_rd_slverr[1]),
            .rd_decerr(ch_rd_decerr[1]),
            .rd_line_cmd(ch_rd_line_cmd[1]),
            .rd_go_next_line(ch_rd_go_next_line[1]),
            .rd_transfer(ch_rd_transfer[1]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[1]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[1]),
            .wr_cmd_pending(ch_wr_cmd_pending[1]),
            .wr_clr_line(ch_wr_clr_line[1]),
            .wr_clr(ch_wr_clr[1]),
            .wr_clr_last(ch_wr_clr_last[1]),
            .wr_slverr(ch_wr_slverr[1]),
            .wr_decerr(ch_wr_decerr[1]),
            .wr_last_cmd(ch_wr_last_cmd[1]),
            .wr_line_cmd(ch_wr_line_cmd[1]),
            .wr_go_next_line(ch_wr_go_next_line[1]),
            .wr_transfer(ch_wr_transfer[1]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[1]),

            .timeout_aw(ch_timeout_aw[1]),
            .timeout_w(ch_timeout_w[1]),
            .timeout_ar(ch_timeout_ar[1]),
            .wdt_timeout(ch_wdt_timeout[1]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[1]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[1]),

            //CTRL
            .ch_active(ch_active[1]),
            .ch_rd_active(ch_rd_active[1]),
            .ch_wr_active(ch_wr_active[1]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[1]),
            .rd_ready(ch_rd_ready[1]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*1:32*1]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*1:7*1]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*1:`TOKEN_BITS*1]),
            .rd_port_num(ch_rd_port_num[1]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*1:`DELAY_BITS*1]),
            .rd_clr_valid(ch_rd_clr_valid[1]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[1]),
            .wr_ready(ch_wr_ready[1]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*1:32*1]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*1:7*1]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*1:`TOKEN_BITS*1]),
            .wr_port_num(ch_wr_port_num[1]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*1:`DELAY_BITS*1]),
            .wr_clr_valid(ch_wr_clr_valid[1]),

            //FIFO
            .fifo_wr(ch_fifo_wr[1]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[1]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[1]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*1:32*1]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[1]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[1]),
            .wr_page_cross(ch_wr_page_cross[1]),
            .joint_in_prog(ch_joint_in_prog[1]),
            .joint_not_in_prog(ch_joint_not_in_prog[1]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[1]),
            .joint_req(ch_joint_req[1]),

            .ch_start(ch_start[1]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*1):1*1])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty2 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[2]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[2]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*2:32*2]),
            .pslverr(ch_pslverr[2]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*2+31-1:31*2]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*2+31-1:31*2]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[2]),
            .rd_cmd_line(ch_rd_cmd_line[2]),
            .rd_clr_line(ch_rd_clr_line[2]),
            .rd_clr(ch_rd_clr[2]),
            .rd_clr_load(ch_rd_clr_load[2]),
            .rd_slverr(ch_rd_slverr[2]),
            .rd_decerr(ch_rd_decerr[2]),
            .rd_line_cmd(ch_rd_line_cmd[2]),
            .rd_go_next_line(ch_rd_go_next_line[2]),
            .rd_transfer(ch_rd_transfer[2]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[2]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[2]),
            .wr_cmd_pending(ch_wr_cmd_pending[2]),
            .wr_clr_line(ch_wr_clr_line[2]),
            .wr_clr(ch_wr_clr[2]),
            .wr_clr_last(ch_wr_clr_last[2]),
            .wr_slverr(ch_wr_slverr[2]),
            .wr_decerr(ch_wr_decerr[2]),
            .wr_last_cmd(ch_wr_last_cmd[2]),
            .wr_line_cmd(ch_wr_line_cmd[2]),
            .wr_go_next_line(ch_wr_go_next_line[2]),
            .wr_transfer(ch_wr_transfer[2]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[2]),

            .timeout_aw(ch_timeout_aw[2]),
            .timeout_w(ch_timeout_w[2]),
            .timeout_ar(ch_timeout_ar[2]),
            .wdt_timeout(ch_wdt_timeout[2]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[2]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[2]),

            //CTRL
            .ch_active(ch_active[2]),
            .ch_rd_active(ch_rd_active[2]),
            .ch_wr_active(ch_wr_active[2]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[2]),
            .rd_ready(ch_rd_ready[2]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*2:32*2]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*2:7*2]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*2:`TOKEN_BITS*2]),
            .rd_port_num(ch_rd_port_num[2]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*2:`DELAY_BITS*2]),
            .rd_clr_valid(ch_rd_clr_valid[2]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[2]),
            .wr_ready(ch_wr_ready[2]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*2:32*2]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*2:7*2]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*2:`TOKEN_BITS*2]),
            .wr_port_num(ch_wr_port_num[2]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*2:`DELAY_BITS*2]),
            .wr_clr_valid(ch_wr_clr_valid[2]),

            //FIFO
            .fifo_wr(ch_fifo_wr[2]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[2]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[2]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*2:32*2]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[2]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[2]),
            .wr_page_cross(ch_wr_page_cross[2]),
            .joint_in_prog(ch_joint_in_prog[2]),
            .joint_not_in_prog(ch_joint_not_in_prog[2]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[2]),
            .joint_req(ch_joint_req[2]),

            .ch_start(ch_start[2]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*2):1*2])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty3 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[3]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[3]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*3:32*3]),
            .pslverr(ch_pslverr[3]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*3+31-1:31*3]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*3+31-1:31*3]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[3]),
            .rd_cmd_line(ch_rd_cmd_line[3]),
            .rd_clr_line(ch_rd_clr_line[3]),
            .rd_clr(ch_rd_clr[3]),
            .rd_clr_load(ch_rd_clr_load[3]),
            .rd_slverr(ch_rd_slverr[3]),
            .rd_decerr(ch_rd_decerr[3]),
            .rd_line_cmd(ch_rd_line_cmd[3]),
            .rd_go_next_line(ch_rd_go_next_line[3]),
            .rd_transfer(ch_rd_transfer[3]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[3]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[3]),
            .wr_cmd_pending(ch_wr_cmd_pending[3]),
            .wr_clr_line(ch_wr_clr_line[3]),
            .wr_clr(ch_wr_clr[3]),
            .wr_clr_last(ch_wr_clr_last[3]),
            .wr_slverr(ch_wr_slverr[3]),
            .wr_decerr(ch_wr_decerr[3]),
            .wr_last_cmd(ch_wr_last_cmd[3]),
            .wr_line_cmd(ch_wr_line_cmd[3]),
            .wr_go_next_line(ch_wr_go_next_line[3]),
            .wr_transfer(ch_wr_transfer[3]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[3]),

            .timeout_aw(ch_timeout_aw[3]),
            .timeout_w(ch_timeout_w[3]),
            .timeout_ar(ch_timeout_ar[3]),
            .wdt_timeout(ch_wdt_timeout[3]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[3]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[3]),

            //CTRL
            .ch_active(ch_active[3]),
            .ch_rd_active(ch_rd_active[3]),
            .ch_wr_active(ch_wr_active[3]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[3]),
            .rd_ready(ch_rd_ready[3]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*3:32*3]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*3:7*3]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*3:`TOKEN_BITS*3]),
            .rd_port_num(ch_rd_port_num[3]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*3:`DELAY_BITS*3]),
            .rd_clr_valid(ch_rd_clr_valid[3]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[3]),
            .wr_ready(ch_wr_ready[3]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*3:32*3]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*3:7*3]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*3:`TOKEN_BITS*3]),
            .wr_port_num(ch_wr_port_num[3]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*3:`DELAY_BITS*3]),
            .wr_clr_valid(ch_wr_clr_valid[3]),

            //FIFO
            .fifo_wr(ch_fifo_wr[3]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[3]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[3]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*3:32*3]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[3]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[3]),
            .wr_page_cross(ch_wr_page_cross[3]),
            .joint_in_prog(ch_joint_in_prog[3]),
            .joint_not_in_prog(ch_joint_not_in_prog[3]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[3]),
            .joint_req(ch_joint_req[3]),

            .ch_start(ch_start[3]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*3):1*3])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty4 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[4]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[4]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*4:32*4]),
            .pslverr(ch_pslverr[4]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*4+31-1:31*4]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*4+31-1:31*4]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[4]),
            .rd_cmd_line(ch_rd_cmd_line[4]),
            .rd_clr_line(ch_rd_clr_line[4]),
            .rd_clr(ch_rd_clr[4]),
            .rd_clr_load(ch_rd_clr_load[4]),
            .rd_slverr(ch_rd_slverr[4]),
            .rd_decerr(ch_rd_decerr[4]),
            .rd_line_cmd(ch_rd_line_cmd[4]),
            .rd_go_next_line(ch_rd_go_next_line[4]),
            .rd_transfer(ch_rd_transfer[4]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[4]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[4]),
            .wr_cmd_pending(ch_wr_cmd_pending[4]),
            .wr_clr_line(ch_wr_clr_line[4]),
            .wr_clr(ch_wr_clr[4]),
            .wr_clr_last(ch_wr_clr_last[4]),
            .wr_slverr(ch_wr_slverr[4]),
            .wr_decerr(ch_wr_decerr[4]),
            .wr_last_cmd(ch_wr_last_cmd[4]),
            .wr_line_cmd(ch_wr_line_cmd[4]),
            .wr_go_next_line(ch_wr_go_next_line[4]),
            .wr_transfer(ch_wr_transfer[4]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[4]),

            .timeout_aw(ch_timeout_aw[4]),
            .timeout_w(ch_timeout_w[4]),
            .timeout_ar(ch_timeout_ar[4]),
            .wdt_timeout(ch_wdt_timeout[4]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[4]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[4]),

            //CTRL
            .ch_active(ch_active[4]),
            .ch_rd_active(ch_rd_active[4]),
            .ch_wr_active(ch_wr_active[4]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[4]),
            .rd_ready(ch_rd_ready[4]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*4:32*4]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*4:7*4]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*4:`TOKEN_BITS*4]),
            .rd_port_num(ch_rd_port_num[4]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*4:`DELAY_BITS*4]),
            .rd_clr_valid(ch_rd_clr_valid[4]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[4]),
            .wr_ready(ch_wr_ready[4]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*4:32*4]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*4:7*4]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*4:`TOKEN_BITS*4]),
            .wr_port_num(ch_wr_port_num[4]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*4:`DELAY_BITS*4]),
            .wr_clr_valid(ch_wr_clr_valid[4]),

            //FIFO
            .fifo_wr(ch_fifo_wr[4]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[4]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[4]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*4:32*4]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[4]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[4]),
            .wr_page_cross(ch_wr_page_cross[4]),
            .joint_in_prog(ch_joint_in_prog[4]),
            .joint_not_in_prog(ch_joint_not_in_prog[4]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[4]),
            .joint_req(ch_joint_req[4]),

            .ch_start(ch_start[4]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*4):1*4])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty5 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[5]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[5]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*5:32*5]),
            .pslverr(ch_pslverr[5]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*5+31-1:31*5]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*5+31-1:31*5]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[5]),
            .rd_cmd_line(ch_rd_cmd_line[5]),
            .rd_clr_line(ch_rd_clr_line[5]),
            .rd_clr(ch_rd_clr[5]),
            .rd_clr_load(ch_rd_clr_load[5]),
            .rd_slverr(ch_rd_slverr[5]),
            .rd_decerr(ch_rd_decerr[5]),
            .rd_line_cmd(ch_rd_line_cmd[5]),
            .rd_go_next_line(ch_rd_go_next_line[5]),
            .rd_transfer(ch_rd_transfer[5]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[5]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[5]),
            .wr_cmd_pending(ch_wr_cmd_pending[5]),
            .wr_clr_line(ch_wr_clr_line[5]),
            .wr_clr(ch_wr_clr[5]),
            .wr_clr_last(ch_wr_clr_last[5]),
            .wr_slverr(ch_wr_slverr[5]),
            .wr_decerr(ch_wr_decerr[5]),
            .wr_last_cmd(ch_wr_last_cmd[5]),
            .wr_line_cmd(ch_wr_line_cmd[5]),
            .wr_go_next_line(ch_wr_go_next_line[5]),
            .wr_transfer(ch_wr_transfer[5]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[5]),

            .timeout_aw(ch_timeout_aw[5]),
            .timeout_w(ch_timeout_w[5]),
            .timeout_ar(ch_timeout_ar[5]),
            .wdt_timeout(ch_wdt_timeout[5]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[5]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[5]),

            //CTRL
            .ch_active(ch_active[5]),
            .ch_rd_active(ch_rd_active[5]),
            .ch_wr_active(ch_wr_active[5]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[5]),
            .rd_ready(ch_rd_ready[5]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*5:32*5]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*5:7*5]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*5:`TOKEN_BITS*5]),
            .rd_port_num(ch_rd_port_num[5]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*5:`DELAY_BITS*5]),
            .rd_clr_valid(ch_rd_clr_valid[5]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[5]),
            .wr_ready(ch_wr_ready[5]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*5:32*5]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*5:7*5]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*5:`TOKEN_BITS*5]),
            .wr_port_num(ch_wr_port_num[5]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*5:`DELAY_BITS*5]),
            .wr_clr_valid(ch_wr_clr_valid[5]),

            //FIFO
            .fifo_wr(ch_fifo_wr[5]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[5]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[5]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*5:32*5]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[5]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[5]),
            .wr_page_cross(ch_wr_page_cross[5]),
            .joint_in_prog(ch_joint_in_prog[5]),
            .joint_not_in_prog(ch_joint_not_in_prog[5]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[5]),
            .joint_req(ch_joint_req[5]),

            .ch_start(ch_start[5]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*5):1*5])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty6 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[6]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[6]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*6:32*6]),
            .pslverr(ch_pslverr[6]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*6+31-1:31*6]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*6+31-1:31*6]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[6]),
            .rd_cmd_line(ch_rd_cmd_line[6]),
            .rd_clr_line(ch_rd_clr_line[6]),
            .rd_clr(ch_rd_clr[6]),
            .rd_clr_load(ch_rd_clr_load[6]),
            .rd_slverr(ch_rd_slverr[6]),
            .rd_decerr(ch_rd_decerr[6]),
            .rd_line_cmd(ch_rd_line_cmd[6]),
            .rd_go_next_line(ch_rd_go_next_line[6]),
            .rd_transfer(ch_rd_transfer[6]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[6]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[6]),
            .wr_cmd_pending(ch_wr_cmd_pending[6]),
            .wr_clr_line(ch_wr_clr_line[6]),
            .wr_clr(ch_wr_clr[6]),
            .wr_clr_last(ch_wr_clr_last[6]),
            .wr_slverr(ch_wr_slverr[6]),
            .wr_decerr(ch_wr_decerr[6]),
            .wr_last_cmd(ch_wr_last_cmd[6]),
            .wr_line_cmd(ch_wr_line_cmd[6]),
            .wr_go_next_line(ch_wr_go_next_line[6]),
            .wr_transfer(ch_wr_transfer[6]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[6]),

            .timeout_aw(ch_timeout_aw[6]),
            .timeout_w(ch_timeout_w[6]),
            .timeout_ar(ch_timeout_ar[6]),
            .wdt_timeout(ch_wdt_timeout[6]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[6]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[6]),

            //CTRL
            .ch_active(ch_active[6]),
            .ch_rd_active(ch_rd_active[6]),
            .ch_wr_active(ch_wr_active[6]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[6]),
            .rd_ready(ch_rd_ready[6]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*6:32*6]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*6:7*6]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*6:`TOKEN_BITS*6]),
            .rd_port_num(ch_rd_port_num[6]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*6:`DELAY_BITS*6]),
            .rd_clr_valid(ch_rd_clr_valid[6]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[6]),
            .wr_ready(ch_wr_ready[6]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*6:32*6]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*6:7*6]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*6:`TOKEN_BITS*6]),
            .wr_port_num(ch_wr_port_num[6]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*6:`DELAY_BITS*6]),
            .wr_clr_valid(ch_wr_clr_valid[6]),

            //FIFO
            .fifo_wr(ch_fifo_wr[6]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[6]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[6]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*6:32*6]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[6]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[6]),
            .wr_page_cross(ch_wr_page_cross[6]),
            .joint_in_prog(ch_joint_in_prog[6]),
            .joint_not_in_prog(ch_joint_not_in_prog[6]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[6]),
            .joint_req(ch_joint_req[6]),

            .ch_start(ch_start[6]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*6):1*6])
            );
          
dma_axi32_core0_ch_empty dma_axi32_core0_ch_empty7 (
            .clk(clk),
            .reset(reset),
            .scan_en(scan_en),
            .idle(ch_idle[7]),

            //APB
            .pclk(pclk),
            .clken(clken),
            .pclken(pclken),
            .psel(ch_psel[7]),
            .penable(penable),
            .paddr(paddr[7:0]),
            .pwrite(pwrite),
            .pwdata(pwdata),
            .prdata(ch_prdata[31+32*7:32*7]),
            .pslverr(ch_pslverr[7]),

            //PERIPH
            .periph_tx_req(periph_tx_req),
            .periph_tx_clr(ch_periph_tx_clr[31*7+31-1:31*7]),
            .periph_rx_req(periph_rx_req),
            .periph_rx_clr(ch_periph_rx_clr[31*7+31-1:31*7]),

            //RD AXIM
            .rd_cmd_split(ch_rd_cmd_split[7]),
            .rd_cmd_line(ch_rd_cmd_line[7]),
            .rd_clr_line(ch_rd_clr_line[7]),
            .rd_clr(ch_rd_clr[7]),
            .rd_clr_load(ch_rd_clr_load[7]),
            .rd_slverr(ch_rd_slverr[7]),
            .rd_decerr(ch_rd_decerr[7]),
            .rd_line_cmd(ch_rd_line_cmd[7]),
            .rd_go_next_line(ch_rd_go_next_line[7]),
            .rd_transfer(ch_rd_transfer[7]),
            .rd_transfer_size(rd_transfer_size),
                .rd_clr_stall(ch_rd_clr_stall[7]),

            //WR AXIM
            .wr_cmd_split(ch_wr_cmd_split[7]),
            .wr_cmd_pending(ch_wr_cmd_pending[7]),
            .wr_clr_line(ch_wr_clr_line[7]),
            .wr_clr(ch_wr_clr[7]),
            .wr_clr_last(ch_wr_clr_last[7]),
            .wr_slverr(ch_wr_slverr[7]),
            .wr_decerr(ch_wr_decerr[7]),
            .wr_last_cmd(ch_wr_last_cmd[7]),
            .wr_line_cmd(ch_wr_line_cmd[7]),
            .wr_go_next_line(ch_wr_go_next_line[7]),
            .wr_transfer(ch_wr_transfer[7]),
            .wr_transfer_size(wr_transfer_size),
            .wr_next_size(wr_next_size),
                .wr_clr_stall(ch_wr_clr_stall[7]),

            .timeout_aw(ch_timeout_aw[7]),
            .timeout_w(ch_timeout_w[7]),
            .timeout_ar(ch_timeout_ar[7]),
            .wdt_timeout(ch_wdt_timeout[7]),
                               
            //LOAD CMD
            .load_wr(ch_load_wr[7]),
            .load_wr_cycle(load_wr_cycle),
            .load_wdata(load_wdata),
            .load_req_in_prog(ch_load_req_in_prog[7]),

            //CTRL
            .ch_active(ch_active[7]),
            .ch_rd_active(ch_rd_active[7]),
            .ch_wr_active(ch_wr_active[7]),

            //RD CTRL
            .rd_burst_start(ch_rd_burst_start[7]),
            .rd_ready(ch_rd_ready[7]),
            .rd_burst_addr(ch_rd_burst_addr[32-1+32*7:32*7]),
            .rd_burst_size(ch_rd_burst_size[7-1+7*7:7*7]),
            .rd_tokens(ch_rd_tokens[`TOKEN_BITS-1+`TOKEN_BITS*7:`TOKEN_BITS*7]),
            .rd_port_num(ch_rd_port_num[7]),
            .rd_periph_delay(ch_rd_periph_delay[`DELAY_BITS-1+`DELAY_BITS*7:`DELAY_BITS*7]),
            .rd_clr_valid(ch_rd_clr_valid[7]),
            
            //WR CTRL
            .wr_burst_start(ch_wr_burst_start[7]),
            .wr_ready(ch_wr_ready[7]),
            .wr_burst_addr(ch_wr_burst_addr[32-1+32*7:32*7]),
            .wr_burst_size(ch_wr_burst_size[7-1+7*7:7*7]),
            .wr_tokens(ch_wr_tokens[`TOKEN_BITS-1+`TOKEN_BITS*7:`TOKEN_BITS*7]),
            .wr_port_num(ch_wr_port_num[7]),
            .wr_periph_delay(ch_wr_periph_delay[`DELAY_BITS-1+`DELAY_BITS*7:`DELAY_BITS*7]),
            .wr_clr_valid(ch_wr_clr_valid[7]),

            //FIFO
            .fifo_wr(ch_fifo_wr[7]),                        
                    .fifo_wdata(fifo_wdata),                   
                    .fifo_wsize(fifo_wsize),                   
                    .fifo_rd(ch_fifo_rd[7]),                   
                    .fifo_rsize(fifo_rsize),                   
                    .fifo_rd_valid(ch_fifo_rd_valid[7]),                   
                    .fifo_rdata(ch_fifo_rdata[(32-1)+32*7:32*7]),       
                    .fifo_wr_ready(ch_fifo_wr_ready[7]),     

                .joint_mode(joint_mode),
                .joint_remote(joint_remote),
            .rd_page_cross(ch_rd_page_cross[7]),
            .wr_page_cross(ch_wr_page_cross[7]),
            .joint_in_prog(ch_joint_in_prog[7]),
            .joint_not_in_prog(ch_joint_not_in_prog[7]),
            .joint_mux_in_prog(ch_joint_mux_in_prog[7]),
            .joint_req(ch_joint_req[7]),

            .ch_start(ch_start[7]),

            //INT
            .int_all_proc(ch_int_all_proc[1-1+(1*7):1*7])
            );
          

   
endmodule
   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_calc_addr.v
//---------------------------------------------------------



module dma_axi32_core0_ch_calc_addr(clk,reset,ch_update_d,load_in_prog,load_addr,go_next_line,burst_start,incr,start_addr,frame_width,x_size,burst_size,burst_addr);
   

   input             clk;
   input             reset;
   
   input             ch_update_d;
   input             load_in_prog;
   input [32-1:0]    load_addr;
   
   input             go_next_line;
   input             burst_start;
   input             incr;
   input [32-1:0]    start_addr;
   input [`FRAME_BITS-1:0]  frame_width;
   input [`X_BITS-1:0]         x_size;
   input [7-1:0]   burst_size;
   output [32-1:0]   burst_addr;
   
   
   reg [32-1:0]         burst_addr;
   
   wire             go_next_line_d;
   reg [`FRAME_BITS-1:0]    frame_width_diff_reg;
   wire [`FRAME_BITS-1:0]   frame_width_diff;
   

   
   assign             frame_width_diff = {`FRAME_BITS{1'b0}};
   assign             go_next_line_d   = 1'b0;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       burst_addr <= #1 {32{1'b0}};
     else if (load_in_prog)
       burst_addr <= #1 load_addr;
     else if (ch_update_d)
       burst_addr <= #1 start_addr;
     else if (burst_start & incr)
       burst_addr <= #1 burst_addr + burst_size;
     else if (go_next_line_d & incr)
       burst_addr <= #1 burst_addr + frame_width_diff;
   
   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_calc_joint.v
//---------------------------------------------------------



module dma_axi32_core0_ch_calc_joint(clk,reset,joint_update,ch_end,ch_end_flush,joint_line_req_clr,wr_cmd_pending,burst_size_pre2,burst_max_size,fifo_not_ready,outs_empty,x_remain,fifo_wr_ready,fifo_remain,joint,page_cross,joint_cross,joint_ready_in,joint_ready_out,joint_line_req,joint_burst_req,joint_wait,joint_flush,joint_flush_in,joint_buffer_small);


   parameter               READ          = 0;
   parameter            WRITE         = !READ;
   
   input                   clk;
   input            reset;

   input            joint_update;
   input            ch_end;
   input            ch_end_flush;

   input            joint_line_req_clr;
   input            wr_cmd_pending;
   input [7-1:0]  burst_size_pre2;
   input [7-1:0]  burst_max_size;
   input            fifo_not_ready;
   input            outs_empty;
   input [10-1:0]   x_remain;
   input            fifo_wr_ready;
   input [5:0]        fifo_remain;
   
   input            joint;
   input            page_cross;
   input            joint_cross;
   input            joint_ready_in;
   output            joint_ready_out;
   output            joint_line_req;
   output            joint_burst_req;
   output            joint_wait;
   output            joint_flush;
   input            joint_flush_in;
   output            joint_buffer_small;
   
   
   

   parameter            IDLE        = 3'd0;
   parameter            REQ_LINE    = 3'd1;
   parameter            READY_OUT   = 3'd2;
   parameter            READY       = 3'd3;
   parameter            CROSS       = 3'd4;
   parameter            BURST_REQ   = 3'd5;
   parameter            RECHK       = 3'd6;
   parameter            FLUSH       = 3'd7;


   
   reg [2:0]            ps;
   reg [2:0]            ns;

   wire            joint_ready_out_pre;
   reg                joint_ready_out;
   reg                joint_line_req;
   reg                joint_burst_req;
   reg                joint_flush;
   reg                joint_wait;
   wire            joint_buffer_small;
   
   
   
   
   assign            joint_ready_out_pre = joint & (burst_size_pre2 == burst_max_size) & (|burst_max_size) & 
                                                 (~joint_line_req) & (~joint_burst_req);

   assign            joint_buffer_small = (burst_max_size > x_remain) | (x_remain < 'd8);
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_ready_out <= #1 1'b0;
     else if ((page_cross | ch_end_flush | joint_flush | joint_wait) & (~ch_end))
       joint_ready_out <= #1 1'b0;
     else if ((~ch_end) & (~wr_cmd_pending))
       joint_ready_out <= #1 joint_ready_out_pre;
   
   
   always @(/*AUTOSENSE*/ch_end_flush or fifo_not_ready or fifo_remain
        or fifo_wr_ready or joint_buffer_small or joint_cross
        or joint_flush_in or joint_line_req_clr or joint_ready_in
        or joint_ready_out or outs_empty or page_cross or ps)
     begin
    ns              = IDLE;
    joint_line_req  = 1'b0;
    joint_burst_req = 1'b0;
    joint_flush     = 1'b0;
    joint_wait      = 1'b0;
    
    case (ps)
      
      IDLE :
        begin
           if (joint_flush_in | joint_buffer_small)
         ns = FLUSH;
           else if (joint_ready_out & joint_ready_in & outs_empty)
         ns = READY;
           else if (joint_ready_out)
         begin
            joint_wait = 1'b1;
            ns = READY_OUT;
         end
           else if (fifo_not_ready & joint_ready_in & outs_empty)
         if (WRITE)
           begin
              joint_line_req = 1'b1; //from write to read - fill fifo at begining
              ns = REQ_LINE;
           end
         else
           begin
              joint_burst_req = 1'b1; //from read to write - empty fifo after cross
              ns = REQ_LINE; //1 cycle pulse
           end
           else
         ns = IDLE;
        end
      
      REQ_LINE :
        begin
           if (joint_flush_in)
         ns = FLUSH;
           else if (joint_line_req_clr)
         begin
            ns = IDLE;
            joint_wait = 1'b0;
         end
           else
         begin
            ns = REQ_LINE;
            joint_wait = 1'b1;
         end
        end

      READY_OUT :
        begin
           joint_wait = 1'b1;

           if (joint_cross | page_cross)
         ns = CROSS;
           else if ((~joint_ready_out) | joint_flush_in | joint_buffer_small)
         ns = FLUSH;
           else if (joint_ready_in & outs_empty)
         begin
            joint_wait = 1'b0;
            ns = RECHK;
         end
           else
         ns = READY_OUT;
        end

      RECHK :
        begin
           if (joint_flush_in | joint_buffer_small)
         ns = FLUSH;
           else if (joint_ready_in & joint_ready_out)
         ns = READY;
           else if (WRITE)
         begin
            joint_line_req = 1'b1; //from write to read - read more data when AHB gets out of align address
            ns = REQ_LINE;
         end
           else if (READ)
         ns = RECHK;
        end
      
      READY :
        begin
           if (joint_cross)
         begin
            joint_wait = 1'b1;
            ns = READY_OUT;
         end
           else if ((~joint_ready_out) | (~joint_ready_in) | ch_end_flush)
           ns = FLUSH;
           else
         ns = READY;
        end

      CROSS :
        begin
           if (joint_buffer_small)
         ns = FLUSH;
           else if (joint_ready_out & (~joint_cross) & outs_empty)
         begin
            if (fifo_wr_ready & (fifo_remain <= 'd16)) //rd_gap
              begin
             joint_burst_req = 1'b1; //from read to write - empty fifo after cross
             
             if (fifo_remain == 'd0)
               ns = BURST_REQ; //2 cycles pulse
             else
               ns = REQ_LINE; //1 cycle pulse
              end
            else
              ns = IDLE;
         end
           else
         ns = CROSS;
        end

      BURST_REQ :
        begin
           joint_burst_req = 1'b1; //from read to write - empty fifo after cross
           ns = REQ_LINE;
        end
      
      FLUSH :
        begin
           joint_flush = 1'b1;
           ns = FLUSH;
        end

      default :
        ns = IDLE;
      
    endcase
     end
   
        
   
   always @(posedge clk or posedge reset)
     if (reset)
       ps <= #1 IDLE;
     else if (joint_update)
       ps <= #1 IDLE;
     else
       ps <= #1 ns;

   
endmodule

   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_calc_size.v
//---------------------------------------------------------



module  dma_axi32_core0_ch_calc_size (clk,reset,ch_update,ch_update_d,ch_update_d2,ch_update_d3,ch_end,ch_end_flush,load_in_prog,load_req_in_prog,joint_line_req_clr,wr_cmd_pending,outs_empty,burst_start,burst_addr,burst_max_size,x_remain,fifo_wr_ready,fifo_remain,burst_last,burst_size,burst_ready,joint_ready_in,joint_ready_out,joint,joint_line_req_in,joint_line_req_out,joint_burst_req_in,joint_burst_req_out,page_cross,joint_cross,joint_flush,joint_flush_in);

   parameter               READ          = 0;
   
   input                   clk;
   input            reset;
   
   input            ch_update;
   input            ch_update_d;
   input            ch_update_d2;
   input            ch_update_d3;
   input            ch_end;
   input            ch_end_flush;
   
   input            load_in_prog;
   input            load_req_in_prog;

   input            joint_line_req_clr;
   input            wr_cmd_pending;
   input            outs_empty;
   input            burst_start;
   input [32-1:0]   burst_addr;
   input [7-1:0]  burst_max_size;
   input [10-1:0]   x_remain;
   input            fifo_wr_ready;
   input [5:0]        fifo_remain;

   output            burst_last;
   output [7-1:0] burst_size;
   output            burst_ready;
   input            joint_ready_in;
   output            joint_ready_out;
   input            joint;
   input            joint_line_req_in;
   output            joint_line_req_out;
   input            joint_burst_req_in;
   output            joint_burst_req_out;
   input            page_cross;
   input            joint_cross;
   output            joint_flush;
   input            joint_flush_in;
   

   parameter            CMD_SIZE       = 16; //4*32 bit
   
   
   wire [7-1:0]   burst_size_pre;
   wire [7-1:0]   x_remain_fifo;    
   wire [7-1:0]   max_burst_align;
   wire [7-1:0]   burst_size_pre2;
   reg [7-1:0]    burst_size;
   reg                burst_ready;
   wire            fifo_not_ready_pre;
   wire            fifo_not_ready;
   
   wire            joint_update;
   wire            joint_ready_out;
   wire            joint_line_req_out;
   wire            joint_burst_req_out;
   wire            joint_wait;
   reg [1:0]            joint_burst_req_reg;
   wire [1:0]            joint_burst_req;
   wire [7-1:0]   joint_burst_req_size;
   reg                joint_line_req_reg;
   wire            joint_line_req;
   wire [7-1:0]   joint_line_req_size;
   wire            joint_buffer_small;
   wire            release_fifo;
   
   
   
   assign            x_remain_fifo = |x_remain[10-1:7] ? {1'b1, {7-1{1'b0}}} : x_remain[7-1:0];
      
   
   prgen_min3 #(7) min3(
                   .clk(clk),
                   .reset(reset),
                   .a(max_burst_align), //address constraint
                   .b(burst_max_size),  //sw constraint
                   .c(x_remain_fifo),   //buffer constraint
                   .min(burst_size_pre)
                );
   
   //   
   //address align, do not cross 16 bit or 32 bit boundary
   assign            max_burst_align =  
                          burst_addr[0] ? 'd1 : // byte
                          burst_addr[1] ? 'd2 : // 16 bit
                          {1'b1, {7-1{1'b0}}}; //no restriction
   
   
   assign            burst_size_pre2 =
               |burst_size_pre[7-1:2] ? {burst_size_pre[7-1:2], 2'b00} : //burst
               
               burst_size_pre[1]               ? 'd2 :
               burst_size_pre[0]               ? 'd1 : 'd0;

   

   
   assign            fifo_not_ready_pre = (fifo_remain < burst_size_pre2) & (~release_fifo);

   prgen_delay #(1) delay_fifo_not_ready (.clk(clk), .reset(reset), .din(fifo_not_ready_pre), .dout(fifo_not_ready));

   assign            burst_last = burst_size == x_remain;
  
   always @(posedge clk or posedge reset)
     if (reset)
       burst_ready <= #1 1'b0;
     else if (ch_update | ch_update_d | ch_update_d2 | ch_update_d3)
       burst_ready <= #1 1'b0;
     else if (load_req_in_prog)
       burst_ready <= #1 1'b1;
     else if (|joint_burst_req)
       burst_ready <= #1 1'b1;
     else if (joint_line_req & (~joint_buffer_small))
       burst_ready <= #1 1'b1;
     else if (load_in_prog | fifo_not_ready_pre | joint_wait | (page_cross & (burst_size != burst_size_pre2)))
       burst_ready <= #1 1'b0;
     else
       burst_ready <= #1 |burst_size_pre2;

   always @(posedge clk or posedge reset)
     if (reset)
       burst_size  <= #1 {7{1'b0}};
     else if (load_req_in_prog)
       burst_size  <= #1 CMD_SIZE;
     else if (|joint_burst_req)
       burst_size  <= #1 joint_burst_req_size;
     else if (joint_line_req & (~joint_buffer_small))
       burst_size  <= #1 joint_line_req_size;
     else
       burst_size  <= #1 burst_size_pre2;

   

   assign            joint_update = ch_update | ch_update_d | ch_update_d2;
   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_burst_req_reg <= #1 2'b00;
     else if (joint_update | joint_flush | joint_flush_in)
       joint_burst_req_reg <= #1 2'b00;
     else if (joint_burst_req_reg & burst_start)
       joint_burst_req_reg <= #1 2'b00;
     else if (joint_burst_req_in)
       joint_burst_req_reg <= #1 joint_burst_req_reg[0] ? 2'b11 : 2'b01;

   assign            joint_burst_req = joint_burst_req_reg;
   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_line_req_reg <= #1 1'b0;
     else if (joint_update | joint_flush | joint_flush_in)
       joint_line_req_reg <= #1 1'b0;
     else if (joint_line_req_reg & burst_start)
       joint_line_req_reg <= #1 1'b0;
     else if (joint_line_req_in)
       joint_line_req_reg <= #1 1'b1;

   assign            joint_line_req = joint_line_req_reg;
   
   assign            joint_line_req_size = 
               burst_addr[2:0] == 3'd0 ? 3'd4 :
               burst_addr[1:0] == 2'd0 ? 'd4 : 
               burst_addr[0]   == 1'd0 ? 'd2 : 'd1;
   
   assign            joint_burst_req_size = 
                          burst_addr[0]             ? 'd1  :
                          burst_addr[1]             ? 'd2  :
                          burst_addr[2] & (!1) ? 'd4  :
                          joint_burst_req[1]        ? 'd32 : 'd16;
   
   dma_axi32_core0_ch_calc_joint #(READ)
   dma_axi32_core0_ch_calc_joint (
                   .clk(clk),
                   .reset(reset),
                   .joint_update(joint_update),
                   .ch_end(ch_end),
                   .ch_end_flush(ch_end_flush),
                   .joint_line_req_clr(joint_line_req_clr),
                   .burst_size_pre2(burst_size_pre2),
                   .burst_max_size(burst_max_size),
                   .fifo_not_ready(fifo_not_ready),
                   .wr_cmd_pending(wr_cmd_pending),
                   .outs_empty(outs_empty),
                   .x_remain(x_remain),
                   .fifo_wr_ready(fifo_wr_ready),
                   .fifo_remain(fifo_remain),
                   .joint(joint),
                   .joint_ready_in(joint_ready_in),
                   .joint_ready_out(joint_ready_out),
                   .joint_line_req(joint_line_req_out),
                   .joint_burst_req(joint_burst_req_out),
                   .joint_wait(joint_wait),
                   .page_cross(page_cross),
                   .joint_cross(joint_cross),
                   .joint_flush(joint_flush),
                   .joint_flush_in(joint_flush_in),
                   .joint_buffer_small(joint_buffer_small)
                   );
   
   assign            release_fifo         =  joint_ready_in & joint_ready_out & (~joint_cross);

   
   
   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_calc.v
//---------------------------------------------------------


 
module dma_axi32_core0_ch_calc(clk,reset,load_in_prog,load_req_in_prog,load_addr,ch_update,ch_end,ch_end_flush,go_next_line,burst_start,incr,wr_cmd_pending,outs_empty,burst_max_size,start_addr,frame_width,x_size,x_remain,fifo_wr_ready,fifo_remain,burst_last,burst_addr,burst_size,burst_ready,single,joint_ready_out,joint_ready_in,joint_line_req_in,joint_line_req_out,joint_burst_req_in,joint_burst_req_out,joint_line_req_clr,joint,page_cross,joint_cross,joint_flush,joint_flush_in);

   parameter                READ = 0;
      
   parameter             SINGLE_SIZE   = 4;
   
   
   input             clk;
   input             reset;

   input             load_in_prog;
   input             load_req_in_prog;
   input [32-1:0]    load_addr;
   
   input             ch_update;
   input             ch_end;
   input             ch_end_flush;
   input             go_next_line;
   input             burst_start;
   input             incr;

   input             wr_cmd_pending;
   input             outs_empty;
   input [7-1:0]   burst_max_size;
   input [32-1:0]    start_addr;
   input [`FRAME_BITS-1:0]  frame_width;
   input [`X_BITS-1:0]         x_size;
   input [10-1:0]    x_remain;
   input             fifo_wr_ready;
   input [5:0]         fifo_remain;

   output             burst_last;
   output [32-1:0]   burst_addr;
   output [7-1:0]  burst_size;
   output             burst_ready;
   output             single;

   output             joint_ready_out;
   input             joint_ready_in;
   input             joint_line_req_in;
   output             joint_line_req_out;
   input             joint_burst_req_in;
   output             joint_burst_req_out;
   input             joint_line_req_clr;
   input             joint;
   input             page_cross;
   input             joint_cross;
   output             joint_flush;
   input             joint_flush_in;
   


   wire             ch_update_d;
   wire             ch_update_d2;
   wire             ch_update_d3;
   
   //outputs of calc_addr
   wire [32-1:0]     burst_addr;
   
   //outputs of calc_size
   wire [7-1:0]    burst_size;
   
   reg                 single;
   

   
   prgen_delay #(1) delay_calc0(.clk(clk), .reset(reset), .din(ch_update), .dout(ch_update_d));
   prgen_delay #(1) delay_calc1(.clk(clk), .reset(reset), .din(ch_update_d), .dout(ch_update_d2));
   prgen_delay #(1) delay_calc2(.clk(clk), .reset(reset), .din(ch_update_d2), .dout(ch_update_d3));

   
   always @(posedge clk or posedge reset)
     if (reset)
       single <= #1 1'b0;
     else if (burst_start)
       single <= #1 (burst_size <= SINGLE_SIZE);

           
   dma_axi32_core0_ch_calc_addr
   dma_axi32_ch_calc_addr (
            .clk(clk),
            .reset(reset),
            .ch_update_d(ch_update_d),
            .load_in_prog(load_in_prog),
            .load_addr(load_addr),
            .go_next_line(go_next_line),
            .burst_start(burst_start),
            .incr(incr),
            .start_addr(start_addr),
            .frame_width(frame_width),
            .x_size(x_size),
            .burst_size(burst_size),
            .burst_addr(burst_addr)
            );

   
   dma_axi32_core0_ch_calc_size #(.READ(READ))
   dma_axi32_ch_calc_size (
            .clk(clk),
            .reset(reset),
            .ch_update(ch_update),
            .ch_update_d(ch_update_d),
            .ch_update_d2(ch_update_d2),
            .ch_update_d3(ch_update_d3),
            .ch_end(ch_end),
            .ch_end_flush(ch_end_flush),
            .joint_line_req_clr(joint_line_req_clr),
            .wr_cmd_pending(wr_cmd_pending),
            .outs_empty(outs_empty),
            .load_in_prog(load_in_prog),
            .load_req_in_prog(load_req_in_prog),
            .burst_start(burst_start),
            .burst_addr(burst_addr),
            .burst_max_size(burst_max_size),
            .x_remain(x_remain),
            .fifo_wr_ready(fifo_wr_ready),
            .fifo_remain(fifo_remain),
            .burst_size(burst_size),
            .burst_ready(burst_ready),
            .burst_last(burst_last),
            .joint_ready_out(joint_ready_out),
            .joint_ready_in(joint_ready_in),
            .joint_line_req_in(joint_line_req_in),
            .joint_line_req_out(joint_line_req_out),
            .joint_burst_req_in(joint_burst_req_in),
            .joint_burst_req_out(joint_burst_req_out),
            .joint(joint),
            .page_cross(page_cross),
            .joint_cross(joint_cross),
            .joint_flush(joint_flush),
            .joint_flush_in(joint_flush_in)
            );

   
   

endmodule


  



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch.v
//---------------------------------------------------------


    

module dma_axi32_core0_ch_empty (clk,reset,scan_en,pclk,clken,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,rd_cmd_split,rd_cmd_line,rd_clr_line,rd_clr,rd_clr_load,rd_slverr,rd_decerr,wr_cmd_split,wr_cmd_pending,wr_clr_line,wr_clr,wr_clr_last,wr_slverr,wr_decerr,load_wr,load_wr_cycle,load_wdata,load_req_in_prog,int_all_proc,ch_start,idle,ch_active,ch_rd_active,ch_wr_active,wr_last_cmd,rd_line_cmd,wr_line_cmd,rd_go_next_line,wr_go_next_line,rd_ready,rd_burst_start,rd_burst_addr,rd_burst_size,rd_tokens,rd_port_num,rd_periph_delay,rd_clr_valid,rd_transfer,rd_transfer_size,rd_clr_stall,wr_ready,wr_burst_start,wr_burst_addr,wr_burst_size,wr_tokens,wr_port_num,wr_periph_delay,wr_clr_valid,wr_transfer,wr_transfer_size,wr_next_size,wr_clr_stall,wr_incr,timeout_aw,timeout_w,timeout_ar,wdt_timeout,fifo_wr,fifo_wdata,fifo_wsize,fifo_rd,fifo_rsize,fifo_rd_valid,fifo_rdata,fifo_wr_ready,joint_mode,joint_remote,rd_page_cross,wr_page_cross,joint_in_prog,joint_not_in_prog,joint_mux_in_prog,joint_req);

   input             clk;
   input             reset;
   input             scan_en;
   
   input             pclk;
   input             clken;
   input             pclken;
   input             psel;
   input             penable;
   input [7:0]             paddr;
   input             pwrite;
   input [31:0]         pwdata;
   output [31:0]         prdata;
   output             pslverr;
   
   input [31:1]         periph_tx_req;
   output [31:1]         periph_tx_clr;
   input [31:1]         periph_rx_req;
   output [31:1]         periph_rx_clr;

   input             rd_cmd_split;
   input             rd_cmd_line;
   input             rd_clr_line;
   input             rd_clr;
   input             rd_clr_load;
   input             rd_slverr;
   input             rd_decerr;

   input             wr_cmd_split;
   input             wr_cmd_pending;
   input             wr_clr_line;
   input             wr_clr;
   input             wr_clr_last;
   input             wr_slverr;
   input             wr_decerr;
   
   input             load_wr;
   input [1:0]             load_wr_cycle;
   input [32-1:0]    load_wdata;
   output             load_req_in_prog;
   
   output [1-1:0]    int_all_proc;
   input              ch_start;
   output             idle;
   output             ch_active;
   output             ch_rd_active;
   output             ch_wr_active;
   output             wr_last_cmd;
   output             rd_line_cmd;
   output             wr_line_cmd;
   output             rd_go_next_line;
   output             wr_go_next_line;
   
   output             rd_ready;
   input             rd_burst_start;
   output [32-1:0]   rd_burst_addr;
   output [7-1:0]  rd_burst_size;
   output [`TOKEN_BITS-1:0] rd_tokens;
   output             rd_port_num;
   output [`DELAY_BITS-1:0] rd_periph_delay;
   output             rd_clr_valid;
   input             rd_transfer;
   input [3-1:0]    rd_transfer_size;
   output             rd_clr_stall;
   
   output             wr_ready;
   input             wr_burst_start;
   output [32-1:0]   wr_burst_addr;
   output [7-1:0]  wr_burst_size;
   output [`TOKEN_BITS-1:0] wr_tokens;
   output             wr_port_num;
   output [`DELAY_BITS-1:0] wr_periph_delay; 
   output             wr_clr_valid;
   input             wr_transfer;
   input [3-1:0]    wr_transfer_size;
   input [3-1:0]    wr_next_size;
   output             wr_clr_stall;
   output             wr_incr;
   
   input              timeout_aw;
   input              timeout_w;
   input              timeout_ar;
   input             wdt_timeout;

   input             fifo_wr;
   input [32-1:0]    fifo_wdata;
   input [3-1:0]    fifo_wsize;
   
   input             fifo_rd;
   input [3-1:0]    fifo_rsize;
   
   output             fifo_rd_valid;
   output [32-1:0]   fifo_rdata;
   output             fifo_wr_ready;
   
   input             joint_mode;
   input             joint_remote;
   input             rd_page_cross;
   input             wr_page_cross;
   output             joint_in_prog;
   output             joint_not_in_prog;
   output             joint_mux_in_prog;
   output             joint_req;

   
   assign             prdata            = 'd0;
   assign             pslverr           = 'd1; //return error
   assign             periph_tx_clr     = 'd0;
   assign             periph_rx_clr     = 'd0;
   assign             load_req_in_prog  = 'd0;
   assign             int_all_proc      = 'd0;
   assign             idle              = 'd1;
   assign             ch_active         = 'd0;
   assign             ch_rd_active      = 'd0;
   assign             ch_wr_active      = 'd0;
   assign             wr_last_cmd       = 'd0;
   assign             rd_line_cmd       = 'd0;
   assign             wr_line_cmd       = 'd0;
   assign             rd_go_next_line   = 'd0;
   assign             wr_go_next_line   = 'd0;
   assign             rd_ready          = 'd0;
   assign             rd_burst_addr     = 'd0;
   assign             rd_burst_size     = 'd0;
   assign             rd_tokens         = 'd0;
   assign             rd_port_num       = 'd0;
   assign             rd_periph_delay   = 'd0;
   assign             rd_clr_valid      = 'd0;
   assign             rd_clr_stall      = 'd0;
   assign             wr_ready          = 'd0;
   assign             wr_burst_addr     = 'd0;
   assign             wr_burst_size     = 'd0;
   assign             wr_tokens         = 'd0;
   assign             wr_port_num       = 'd0;
   assign             wr_periph_delay   = 'd0;
   assign             wr_clr_valid      = 'd0;
   assign             wr_clr_stall      = 'd0;
   assign             wr_incr           = 'd0;
   assign             fifo_rd_valid     = 'd0;
   assign             fifo_rdata        = 'd0;
   assign             fifo_wr_ready     = 'd0;
   assign             joint_in_prog     = 'd0;
   assign             joint_not_in_prog = 'd0;
   assign             joint_mux_in_prog = 'd0;
   assign             joint_req         = 'd0;


   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_fifo_ctrl.v
//---------------------------------------------------------


  
module dma_axi32_core0_ch_fifo_ctrl (clk,reset,end_swap,joint_in_prog,wr_outstanding,ch_update,fifo_wr,fifo_wdata,fifo_wsize,wr_align,rd_incr,fifo_rd,fifo_rsize,rd_align,wr_incr,wr_single,wr_burst_size,rd_clr_line,wr_clr_line,wr_next_size,fifo_rd_valid,fifo_rdata,fifo_wr_ready,fifo_overflow,fifo_underflow);

   input               clk;
   input               reset;
   
   input [1:0]               end_swap;
   
   input               joint_in_prog;
   input               wr_outstanding;
   input               ch_update;

   input               fifo_wr;
   input [32-1:0]      fifo_wdata;
   input [3-1:0]      fifo_wsize;
   input [2-1:0]      wr_align;
   input               rd_incr;
   
   input               fifo_rd;
   input [3-1:0]      fifo_rsize;
   input [2-1:0]      rd_align;
   input               wr_incr;
   input               wr_single;
   input [7-1:0]     wr_burst_size;

   input               rd_clr_line;
   input               wr_clr_line;
   input [3-1:0]      wr_next_size;

   output               fifo_rd_valid;
   output [32-1:0]     fifo_rdata;
   output               fifo_wr_ready;
   output               fifo_overflow;
   output               fifo_underflow;
   

   
   //outputs of wr slicer
   wire               slice_wr;
   wire               slice_wr_fifo;
   wire [5-1:0]       slice_wr_ptr;
   wire [4-1:0]       slice_bsel;
   wire [32-1:0]       slice_wdata;
   wire [3-1:0]       slice_wsize;

   //outputs of rd slicer
   wire               slice_rd;
   wire [32-1:0]       slice_rdata;
   wire [3-1:0]       slice_rsize;
   wire [5-1:0]       slice_rd_ptr;
   wire               slice_rd_valid;

   //outputs of fifo ptr
   wire [5-1:0]       rd_ptr;
   wire [5-1:0]       wr_ptr;
   wire [3-1:0]       rd_line_remain;
   wire               joint_delay;
   wire               fifo_wr_ready;
   wire               fifo_overflow;
   wire               fifo_underflow;
   
   //outputs of fifo
   wire [32-1:0]       DOUT;

   wire               fifo_wr_d;
   reg [32-1:0]           fifo_wdata_d;
   wire               fifo_wr_valid;
   wire [32-1:0]       fifo_wdata_valid;
   

   assign               fifo_wr_valid    = fifo_wr;
   assign               fifo_wdata_valid = fifo_wdata;

   
   assign               fifo_rdata    = slice_rdata & {32{slice_rd_valid}};
   assign               fifo_rd_valid = slice_rd_valid;

   
   dma_axi32_core0_ch_wr_slicer
   dma_axi32_ch_wr_slicer (
            .clk(clk),
            .reset(reset),
            .ch_update(ch_update),
            .rd_clr_line(rd_clr_line),
            .fifo_wr(fifo_wr_valid),
            .fifo_wdata(fifo_wdata_valid),
            .fifo_wsize(fifo_wsize),
            .wr_align(wr_align),
            .wr_ptr(wr_ptr),
            .rd_incr(rd_incr),
            .end_swap(end_swap),
            .slice_wr(slice_wr),
            .slice_wr_fifo(slice_wr_fifo),
            .slice_wr_ptr(slice_wr_ptr),
            .slice_bsel(slice_bsel),
            .slice_wdata(slice_wdata),
            .slice_wsize(slice_wsize)
            );
   
   
   dma_axi32_core0_ch_rd_slicer
   dma_axi32_ch_rd_slicer (
            .clk(clk),
            .reset(reset),
            .fifo_rd(fifo_rd),
            .fifo_rdata(DOUT),
            .fifo_rsize(fifo_rsize),
            .rd_align(rd_align),
            .rd_ptr(rd_ptr),
            .rd_line_remain(rd_line_remain),
            .wr_incr(wr_incr),
            .wr_single(wr_single),
            .slice_rd(slice_rd),
            .slice_rdata(slice_rdata),
            .slice_rd_valid(slice_rd_valid),
            .slice_rsize(slice_rsize),
            .slice_rd_ptr(slice_rd_ptr)
            );
   
   
   dma_axi32_core0_ch_fifo_ptr
   dma_axi32_ch_fifo_ptr (
               .clk(clk),
               .reset(reset),
               .joint_in_prog(joint_in_prog),
               .wr_outstanding(wr_outstanding),
               .ch_update(ch_update),
               .fifo_rd(fifo_rd),
               .fifo_rsize(fifo_rsize),
               .slice_wr(slice_wr),
               .slice_wr_fifo(slice_wr_fifo),
               .slice_wsize(slice_wsize),
               .slice_rd(slice_rd),
               .slice_rsize(slice_rsize),
               .rd_clr_line(rd_clr_line),
               .wr_clr_line(wr_clr_line),
               .rd_ptr(rd_ptr),
               .wr_ptr(wr_ptr),
               .rd_line_remain(rd_line_remain),
               .joint_delay(joint_delay),
               .wr_next_size(wr_next_size),
               .wr_burst_size(wr_burst_size),
               .fifo_wr_ready(fifo_wr_ready),
               .fifo_overflow(fifo_overflow),
               .fifo_underflow(fifo_underflow)
               );

   
   dma_axi32_core0_ch_fifo
   dma_axi32_ch_fifo (
           .CLK(clk),
           .WR(slice_wr_fifo),
           .RD(slice_rd),
           .WR_ADDR(slice_wr_ptr[5-1:2] ),
           .RD_ADDR(slice_rd_ptr[5-1:2]),
           .DIN(slice_wdata),
           .BSEL(slice_bsel),
           .DOUT(DOUT)
           );

   
endmodule






/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_fifo_ptr.v
//---------------------------------------------------------


  
module dma_axi32_core0_ch_fifo_ptr(clk,reset,joint_in_prog,wr_outstanding,ch_update,fifo_rd,fifo_rsize,slice_wr,slice_wr_fifo,slice_wsize,slice_rd,slice_rsize,rd_clr_line,wr_clr_line,wr_next_size,wr_burst_size,rd_ptr,wr_ptr,rd_line_remain,joint_delay,fifo_wr_ready,fifo_overflow,fifo_underflow);
   
   input               clk;
   input               reset;

   input               joint_in_prog;
   input               wr_outstanding;
   input               ch_update;
   input               fifo_rd;
   input [3-1:0]      fifo_rsize;
   input               slice_wr;
   input               slice_wr_fifo;
   input [3-1:0]      slice_wsize;
   input               slice_rd;
   input [3-1:0]      slice_rsize;
   input               rd_clr_line;
   input               wr_clr_line;
   input [3-1:0]      wr_next_size;
   input [7-1:0]     wr_burst_size;

   output [5-1:0]     rd_ptr;
   output [5-1:0]     wr_ptr;
   output [3-1:0]     rd_line_remain;
   output               joint_delay;
   output               fifo_wr_ready;
   output               fifo_overflow;
   output               fifo_underflow;
   

   wire [5-1:0]       rd_ptr_pre;
   wire [5-1:0]       wr_ptr_pre;
   reg [5-1:0]           rd_ptr;
   reg [5-1:0]           wr_ptr;
   wire [5+1:0]       fullness_pre; //signed
   reg [5+1:0]           fullness; //signed
   reg [3-1:0]           rd_line_remain;
   wire               joint_in_prog_d;
   reg                   joint_delay_reg;
   reg                   fifo_wr_ready;
   wire               fifo_overflow_pre;
   wire               fifo_underflow_pre;
   reg                   fifo_overflow;
   reg                   fifo_underflow;
   
   
   
   assign               wr_ptr_pre    = wr_ptr + ({3{slice_wr}} & slice_wsize);
   assign               rd_ptr_pre    = rd_ptr + ({3{slice_rd}} & slice_rsize);

   always @(posedge clk or posedge reset)
     if (reset)
       wr_ptr <= #1 {5{1'b0}};
     else if (ch_update)
       wr_ptr <= #1 {5{1'b0}};
     else if (slice_wr)
       wr_ptr <= #1 wr_ptr_pre;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_ptr <= #1 {5{1'b0}};
     else if (ch_update)
       rd_ptr <= #1 {5{1'b0}};
     else if (slice_rd)
       rd_ptr <= #1 rd_ptr_pre;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_line_remain <= #1 3'd4;
     else if (ch_update | wr_clr_line)
       rd_line_remain <= #1 3'd4;
     else if (slice_rd & (rd_line_remain == slice_rsize))
       rd_line_remain <= #1 3'd4;
     else if (slice_rd)
       rd_line_remain <= #1 rd_line_remain - slice_rsize;
       
     
   assign               fullness_pre = fullness + 
                  ({3{slice_wr}} & slice_wsize) - 
                ({3{fifo_rd}} & fifo_rsize);

   
   always @(posedge clk or posedge reset)
     if (reset)
       fullness <= #1 {5+2{1'b0}};
     else if (ch_update)
       fullness <= #1 {5+2{1'b0}};
     else if (fifo_rd | slice_wr)
       fullness <= #1 fullness_pre;

   
   
   prgen_delay #(1) delay_joint_in_prog (.clk(clk), .reset(reset), .din(joint_in_prog), .dout(joint_in_prog_d));
   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_delay_reg <= #1 1'b0;
     else if (joint_in_prog & (~joint_in_prog_d))
       joint_delay_reg <= #1 fullness > 32 - 3'd4;
     else if (~joint_in_prog)
       joint_delay_reg <= #1 1'b0;

   assign               joint_delay = joint_delay_reg;
   
   always @(posedge clk or posedge reset)
     if (reset)
       fifo_wr_ready <= #1 1'b0;
     else if (joint_in_prog)
       fifo_wr_ready <= #1 1'b0;
     else if (|wr_next_size)
       fifo_wr_ready <= #1 fullness_pre >= wr_next_size;

   assign               fifo_underflow_pre = 
                              fullness[5+1];
   
   assign               fifo_overflow_pre  = (~fullness[5+1]) & (fullness[5:0] > 32);

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      fifo_overflow  <= #1 1'b0;
      fifo_underflow <= #1 1'b0;
       end
     else if (ch_update)
       begin
      fifo_overflow  <= #1 1'b0;
      fifo_underflow <= #1 1'b0;
       end
     else if ((!fifo_overflow) & (!fifo_underflow))
       begin
      fifo_overflow  <= #1 fifo_overflow_pre;
      fifo_underflow <= #1 fifo_underflow_pre;
       end

          
endmodule
   






/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_fifo.v
//---------------------------------------------------------


  
module dma_axi32_core0_ch_fifo (CLK,WR,RD,WR_ADDR,RD_ADDR,DIN,BSEL,DOUT);

   
   input                      CLK;
   
   input               WR;
   input               RD;
   input [5-2-1:0] WR_ADDR;
   input [5-2-1:0] RD_ADDR;
   input [32-1:0]      DIN;
   input [4-1:0]      BSEL;
   output [32-1:0]     DOUT;
   
   
   reg [32-1:0]           Mem [8-1:0];
   wire [32-1:0]       BitSEL;
   wire [32-1:0]       DIN_BitSEL;
   reg [32-1:0]           DOUT;
   
     assign               BitSEL = {{8{BSEL[3]}} , {8{BSEL[2]}} , {8{BSEL[1]}} , {8{BSEL[0]}}};

   
   assign               DIN_BitSEL = (Mem[WR_ADDR] & ~BitSEL) | (DIN & BitSEL);
   
   always @(posedge CLK)
     if (WR)
       Mem[WR_ADDR] <= #1 DIN_BitSEL;

   
   always @(posedge CLK)
     if (RD)
       DOUT <= #1 Mem[RD_ADDR];

   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_offsets.v
//---------------------------------------------------------


  
module dma_axi32_core0_ch_offsets(clk,reset,ch_update,burst_start,burst_last,burst_size,load_req_in_prog,x_size,y_size,x_offset,y_offset,x_remain,clr_remain,ch_end,go_next_line,incr,clr_line,line_empty,empty,start_align,width_align,align);

   input             clk;
   input             reset;

   input             ch_update;
   input             burst_start; 
   input             burst_last; 
   input [7-1:0]   burst_size;
   input             load_req_in_prog;
   
   input [10-1:0]    x_size;
   input [10-`X_BITS-1:0]         y_size;

   output [10-1:0]   x_offset;
   output [10-`X_BITS-1:0]         y_offset;        
   output [10-1:0]   x_remain;
   output [10-`X_BITS-1:0]         clr_remain;
   output             ch_end;
   output             go_next_line;
   input             incr;
   input             clr_line;            
   output             line_empty;
   output             empty;
   
   input [2-1:0]    start_align;
   input [2-1:0]    width_align;
   output [2-1:0]   align;
   
   
   wire             update_line;             
   wire             go_next_line;
   wire             line_end_pre;
   wire             line_empty;
   reg [10-1:0]         x_remain;
   wire             ch_end_pre;
   reg                 ch_end;
   wire             ch_update_d;
   


   assign             ch_end_pre   = burst_start & burst_last;
   assign             go_next_line = 1'b0;
   assign             line_empty   = 1'b0;
   assign             empty        = ch_end_pre | ch_end;

   
   always @(posedge clk or posedge reset)
     if (reset)
       ch_end <= #1 1'b0;
     else if (ch_update)
       ch_end <= #1 1'b0;
     else if (ch_end_pre)
       ch_end <= #1 1'b1;

   always @(posedge clk or posedge reset)
     if (reset)
       x_remain <= #1 {10{1'b0}};
     else if (ch_update | go_next_line)
       x_remain <= #1 x_size;
     else if (burst_start & (~load_req_in_prog))
       x_remain <= #1 x_remain - burst_size;
       
   
   assign             x_offset   = {10{1'b0}};
   assign             y_offset   = {10-`X_BITS{1'b0}};
   assign             clr_remain = {10-`X_BITS{1'b0}};
   assign             align      = start_align;
   
   
   
endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_outs.v
//---------------------------------------------------------



module dma_axi32_core0_ch_outs(clk,reset,cmd,clr,outs_max,outs,outs_empty,stall,timeout);
   
   input                    clk;
   input             reset;

   input             cmd;
   input             clr;
   input [`OUT_BITS-1:0]    outs_max;
   output [`OUT_BITS-1:0]   outs;
   output             outs_empty;
   output             stall;
   output             timeout;
   

   reg [`OUT_BITS-1:0]         outs;
   wire [`OUT_BITS-1:0]     outs_pre;
   reg                 stall;
   reg [`TIMEOUT_BITS-1:0]  counter;


   
   assign             outs_empty = outs == 'd0;
   
   assign             outs_pre = outs + cmd - clr;
   
   always @(posedge clk or posedge reset)
     if (reset)
       outs <= #1 'd0;
     else if (cmd | clr)
       outs <= #1 outs_pre;

   
   always @(posedge clk or posedge reset)
     if (reset)
       stall <= #1 1'b0;
     else if (|outs_max)
       stall <= #1 outs >= outs_max;
   

   
   assign             timeout = (counter == 'd0);
   
   always @(posedge clk or posedge reset)
     if (reset)
       counter <= #1 {`TIMEOUT_BITS{1'b1}};
     else if (clr)
       counter <= #1 {`TIMEOUT_BITS{1'b1}};
     else if (|outs)
       counter <= #1 counter - 1'b1;
   
             
endmodule
   










/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_periph_mux.v
//---------------------------------------------------------



  
module dma_axi32_core0_ch_periph_mux(clk,reset,clken,periph_req,periph_clr,periph_ready,periph_num,clr_valid,clr);

   input                    clk;
   input             reset;
   input             clken;
   
   input [31:1]         periph_req;
   output [31:1]         periph_clr;
   output             periph_ready;
   input [4:0]              periph_num;
   input             clr_valid;
   input             clr;

   
   reg [31:1]             periph_clr;
   wire [31:0]             periph_req_full;
   wire             periph_ready_pre;
   

   always @(/*AUTOSENSE*/clken or clr or clr_valid or periph_num)
     begin
    periph_clr = {31{1'b0}};

    periph_clr[periph_num] = clr & clr_valid & clken;
     end


   assign periph_req_full  = {periph_req, 1'b1}; //bit 0 is memory
   assign periph_ready_pre = periph_req_full[periph_num];

   prgen_delay #(1) delay_ready  (.clk(clk), .reset(reset), .din(periph_ready_pre), .dout(periph_ready));

   
endmodule






/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_rd_slicer.v
//---------------------------------------------------------


  

module  dma_axi32_core0_ch_rd_slicer (clk,reset,fifo_rd,fifo_rdata,fifo_rsize,rd_align,rd_ptr,rd_line_remain,wr_incr,wr_single,slice_rd,slice_rdata,slice_rsize,slice_rd_ptr,slice_rd_valid);

   input               clk;
   input               reset;

   input               fifo_rd;
   input [32-1:0]      fifo_rdata;
   input [3-1:0]      fifo_rsize;
   input [2-1:0]      rd_align;
   input [5-1:0]      rd_ptr;
   input [3-1:0]      rd_line_remain;
   input               wr_incr;
   input               wr_single;
   
   output               slice_rd;
   output [32-1:0]     slice_rdata;
   output [3-1:0]     slice_rsize;
   output [5-1:0]     slice_rd_ptr;
   output               slice_rd_valid;
   
   
   
   wire               slice_rd_pre;
   wire               slice_rd;
   wire [5-1:0]       slice_rd_ptr;
   reg [32-1:0]           slice_rdata;
   wire [3-1:0]       slice_rsize;

   wire               fifo_rd_d;
   wire               slice_rd_d;
   wire [2-1:0]       rd_align_valid_pre;
   reg [2-1:0]           rd_align_valid;
   reg [2-1:0]           rd_align_d;
   
   reg [32-1:0]           next_rdata_pre;
   reg [32-1:0]           next_rdata;
   
   reg [3-1:0]           actual_rsize;
   wire [3-1:0]       actual_rsize_pre;
   reg [3-1:0]           next_rsize_reg;
   wire [3-1:0]       next_rsize;
   wire               next_rd;
   
   
   //RDATA
   prgen_delay #(1) delay_fifo_rd0    (.clk(clk), .reset(reset), .din(fifo_rd), .dout(fifo_rd_d));
   prgen_delay #(2) delay_fifo_rd_valid (.clk(clk), .reset(reset), .din(fifo_rd_d), .dout(slice_rd_valid));
   prgen_delay #(1) delay_fifo_rd1    (.clk(clk), .reset(reset), .din(slice_rd_pre), .dout(slice_rd));
   prgen_delay #(1) delay_fifo_rd2    (.clk(clk), .reset(reset), .din(slice_rd), .dout(slice_rd_d));
   

   assign               rd_align_valid_pre = 
                  (~wr_incr) & wr_single ? rd_align - rd_ptr[2-1:0] :
                  rd_align;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      rd_align_valid <= #1 {2{1'b0}};
      rd_align_d     <= #1 {2{1'b0}};
       end
     else
       begin
      rd_align_valid <= #1 rd_align_valid_pre;
      rd_align_d     <= #1 rd_align_valid;
       end
   
   always @(/*AUTOSENSE*/fifo_rdata or next_rdata or rd_align_d)
     begin
    case(rd_align_d[2-1:0])
      2'd0 : slice_rdata = next_rdata[31:0];
      2'd1 : slice_rdata = {fifo_rdata[23:0], next_rdata[7:0]};
      2'd2 : slice_rdata = {fifo_rdata[15:0], next_rdata[15:0]};
      2'd3 : slice_rdata = {fifo_rdata[7:0], next_rdata[23:0]};
    endcase
     end
   

   always @(/*AUTOSENSE*/fifo_rdata or rd_align_valid)
     begin
    case(rd_align_valid[2-1:0])
      2'd0 : next_rdata_pre = fifo_rdata[31:0];
      2'd1 : next_rdata_pre = {{24{1'b0}}, fifo_rdata[31:24]};
      2'd2 : next_rdata_pre = {{16{1'b0}}, fifo_rdata[31:16]};
      2'd3 : next_rdata_pre = {{8{1'b0}}, fifo_rdata[31:8]};
    endcase
     end

   
   
   always @(posedge clk or posedge reset)
     if (reset)
       next_rdata <= #1 {32{1'b0}};
     else if (slice_rd_d)
       next_rdata <= #1 next_rdata_pre;
   
   
   //RSIZE
   assign actual_rsize_pre    = next_rsize + ({3{fifo_rd}} & fifo_rsize);

   always @(posedge clk or posedge reset)
     if (reset)
       actual_rsize <= #1 {3{1'b0}};
     else if (fifo_rd | (|next_rsize))
       actual_rsize <= #1 actual_rsize_pre;
   
   prgen_min2 #(3) min_rsize(
                   .a(rd_line_remain),
                   .b(actual_rsize),
                   .min(slice_rsize)
                   );
   

   always @(posedge clk or posedge reset)
     if (reset)
       next_rsize_reg <= #1 {3{1'b0}};
     else if (next_rd)
       next_rsize_reg <= #1 {3{1'b0}};
     else if (fifo_rd | slice_rd)
       next_rsize_reg <= #1 next_rsize + ({3{fifo_rd}} & fifo_rsize);

   assign next_rsize = next_rsize_reg - ({3{fifo_rd_d}} & slice_rsize);
   
   //CMD
   assign next_rd         = (~fifo_rd) & (|next_rsize);  
   
   assign slice_rd_pre    = fifo_rd | next_rd;

   assign slice_rd_ptr    = rd_ptr;
   
 
endmodule



   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_reg_size.v
//---------------------------------------------------------


  
module dma_axi32_core0_ch_reg_size(clk,reset,update,start_addr,burst_max_size_reg,burst_max_size_other,allow_full_burst,allow_full_fifo,joint_flush,burst_max_size);

   parameter              MAX_BURST     = 1 ? 64 : 128; //16 strobes
   parameter              HALF_BYTES    = 32/2;
   parameter              LARGE_FIFO    = 32 > MAX_BURST;
   parameter              SMALL_FIFO    = 32 == 16;
   
   input                  clk;
   input              reset;

   input              update;

   input [32-1:0]      start_addr;
   input [7-1:0]      burst_max_size_reg;
   input [7-1:0]      burst_max_size_other;

   input              allow_full_burst;
   input              allow_full_fifo;
   input              joint_flush;
   output [7-1:0]      burst_max_size;

   
   
   wire [7-1:0]      burst_max_size_fifo;
   wire [7-1:0]      burst_max_size_pre;
   reg [7-1:0]      burst_max_size;

   
  
   
   assign              burst_max_size_fifo = 
                 allow_full_burst | LARGE_FIFO ? MAX_BURST  :
                 joint_flush & SMALL_FIFO      ? HALF_BYTES :
                 (burst_max_size_other > HALF_BYTES) & (burst_max_size_reg > HALF_BYTES) & (burst_max_size_other != burst_max_size_reg) 
                                                               ? HALF_BYTES :
                 allow_full_fifo               ? 32 : HALF_BYTES;
   
   
   prgen_min2 #(7) min2_max(
                   .a(burst_max_size_reg),
                   .b(burst_max_size_fifo),
                   .min(burst_max_size_pre)
                   );
   
   always @(posedge clk or posedge reset)
     if (reset)
       burst_max_size <= #1 {7{1'b0}};
     else if (update)
       burst_max_size <= #1 burst_max_size_pre > MAX_BURST ? MAX_BURST : burst_max_size_pre;

   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_reg.v
//---------------------------------------------------------



  
module dma_axi32_core0_ch_reg(clk,clken,pclken,reset,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,timeout_bus,wdt_timeout,ch_start,load_addr,load_in_prog,load_req_in_prog,load_wr,load_wr_cycle,load_wdata,load_cmd,rd_ch_end,wr_ch_end,wr_clr_last,rd_slverr,rd_decerr,wr_slverr,wr_decerr,int_all_proc,ch_rd_active,ch_wr_active,ch_in_prog,rd_x_offset,rd_y_offset,wr_x_offset,wr_y_offset,wr_fullness,rd_gap,fifo_overflow,fifo_underflow,ch_update,rd_start_addr,wr_start_addr,x_size,y_size,rd_burst_max_size,wr_burst_max_size,block,allow_line_cmd,frame_width,width_align,rd_periph_delay,rd_periph_block,wr_periph_delay,wr_periph_block,rd_tokens,wr_tokens,rd_port_num,wr_port_num,rd_outs_max,wr_outs_max,rd_outs,wr_outs,outs_empty,rd_wait_limit,wr_wait_limit,rd_incr,wr_incr,rd_periph_num,wr_periph_num,wr_outstanding,rd_outstanding,ch_retry_wait,joint_mode,joint_remote,joint_cross,page_cross,joint,joint_flush,end_swap);

   parameter              DATA_SHIFT    = 1 ? 32 : 0;
   
   
   input                  clk;
   input              clken;
   input              pclken;
   input              reset;
   
   input              psel;
   input              penable;
   input [7:0]              paddr;
   input              pwrite;
   input [31:0]          pwdata;
   output [31:0]          prdata;
   output              pslverr;

   input [4:0]              timeout_bus;
   input              wdt_timeout;

   input              ch_start;
   
   output [32-1:0]      load_addr;
   output              load_in_prog;
   output              load_req_in_prog;
   input              load_wr;
   input [1:0]              load_wr_cycle;
   input [32-1:0]      load_wdata;
   input              load_cmd;
   
   input              rd_ch_end;
   input              wr_ch_end;
   input              wr_clr_last;
   input              rd_slverr;
   input              rd_decerr;
   input              wr_slverr;
   input              wr_decerr;
   output [1-1:0]         int_all_proc;
   
   output              ch_rd_active;
   output              ch_wr_active;
   output              ch_in_prog;

   input [10-1:0]      rd_x_offset;
   input [10-`X_BITS-1:0]          rd_y_offset;    
   input [10-1:0]      wr_x_offset;
   input [10-`X_BITS-1:0]          wr_y_offset;    
   input [5:0]          wr_fullness;
   input [5:0]          rd_gap;
   input              fifo_overflow;
   input              fifo_underflow;
   
   output              ch_update;
   output [32-1:0]      rd_start_addr;
   output [32-1:0]      wr_start_addr;
   output [10-1:0]      x_size;
   output [10-`X_BITS-1:0]          y_size;
   
   output [7-1:0]      rd_burst_max_size;
   output [7-1:0]      wr_burst_max_size;
   output              block;
   input              allow_line_cmd;
   output [`FRAME_BITS-1:0]      frame_width;
   output [2-1:0]      width_align;
   output [`DELAY_BITS-1:0]      rd_periph_delay;
   output              rd_periph_block;
   output [`DELAY_BITS-1:0]      wr_periph_delay;
   output              wr_periph_block;
   output [`TOKEN_BITS-1:0]      rd_tokens;
   output [`TOKEN_BITS-1:0]      wr_tokens;
   output              rd_port_num;
   output              wr_port_num;
   output [`OUT_BITS-1:0]      rd_outs_max;
   output [`OUT_BITS-1:0]      wr_outs_max;
   input [`OUT_BITS-1:0]      rd_outs;
   input [`OUT_BITS-1:0]      wr_outs;
   input              outs_empty;
   output [`WAIT_BITS-1:0]      rd_wait_limit;
   output [`WAIT_BITS-1:0]      wr_wait_limit;
   output              rd_incr;
   output              wr_incr;
   output [4:0]          rd_periph_num;
   output [4:0]          wr_periph_num;
   output              wr_outstanding;
   output              rd_outstanding;
   output              ch_retry_wait;
   input              joint_mode;
   input              joint_remote;
   input              joint_cross;
   input              page_cross;
   output              joint;
   input              joint_flush;
   output [1:0]          end_swap;
      
   
// `include "dma_axi32_ch_reg_params.v"

   
  parameter     INT_NUM = 13; 
   
   
   wire [7:0]              gpaddr;
   wire              gpwrite;
   wire              gpread;
   reg [31:0]              prdata_pre;
   reg                  pslverr_pre;
   reg [31:0]              prdata;
   reg                  pslverr;
   
   reg                  ch_enable;
   reg                  ch_in_prog;
   reg                  rd_ch_in_prog;
   reg                  wr_ch_in_prog;
   reg                  load_in_prog_reg;
   reg                  load_req_in_prog_reg;
   
   //current cmd
   reg [32-1:0]          rd_start_addr;
   reg [32-1:0]          wr_start_addr;
   reg [10-1:0]          buff_size;
   wire [10-1:0]      x_size;
   wire [10-`X_BITS-1:0]          y_size;

   reg [`FRAME_BITS-1:0]      frame_width_reg;  
   reg                  block_reg;
   reg                  joint_reg;
   reg                  simple_mem;
   wire              joint;
   wire              joint_mux;
   reg                  auto_retry_reg;
   wire              auto_retry;
   reg [1:0]              end_swap_reg;
   
   //static
   wire [7-1:0]      rd_burst_max_size_rd;
   wire [7-1:0]      rd_burst_max_size_pre;
   reg [7-1:0]      rd_burst_max_size_reg;
   reg [`DELAY_BITS-1:0]      rd_periph_delay_reg;
   reg                  rd_periph_block_reg;
   reg [`TOKEN_BITS-1:0]      rd_tokens_reg;
   reg [`OUT_BITS-1:0]          rd_outs_max_reg;
   reg                  rd_port_num_reg;
   reg                  cmd_port_num_reg;
   wire              rd_port_num_cfg;
   wire              cmd_port_num;
   reg                  rd_outstanding_reg;
   wire              rd_outstanding_cfg;
   reg                  rd_incr_reg;
   reg [4:0]              rd_periph_num_reg;
   reg [`WAIT_BITS-1:4]      rd_wait_limit_reg;
   
   wire [7-1:0]      wr_burst_max_size_rd;
   wire [7-1:0]      wr_burst_max_size_pre;
   reg [7-1:0]      wr_burst_max_size_reg;
   reg [`DELAY_BITS-1:0]      wr_periph_delay_reg;
   reg                  wr_periph_block_reg;
   reg [`TOKEN_BITS-1:0]      wr_tokens_reg;
   reg [`OUT_BITS-1:0]          wr_outs_max_reg;
   reg                  wr_port_num_reg;
   reg                  wr_outstanding_reg;
   wire              wr_outstanding_cfg;
   reg                  wr_incr_reg;
   reg [4:0]              wr_periph_num_reg;
   reg [`WAIT_BITS-1:4]      wr_wait_limit_reg;

   wire              rd_allow_full_fifo;
   wire              wr_allow_full_fifo;
   wire              allow_full_fifo;
   wire              allow_full_burst;
   wire              allow_joint_burst;
   wire              burst_max_size_update_pre;
   wire              burst_max_size_update;
      
   reg                  cmd_set_int_reg;
   reg                  cmd_last_reg;
   reg [32-1:2]          cmd_next_addr_reg;
   reg [`CMD_CNT_BITS-1:0]      cmd_counter_reg;    
   reg [`INT_CNT_BITS-1:0]      int_counter_reg;
   wire              cmd_set_int;
   wire              cmd_last;
   wire [32-1:2]      cmd_next_addr;
   wire [`CMD_CNT_BITS-1:0]      cmd_counter;
   wire [`INT_CNT_BITS-1:0]      int_counter;
   
   //interrupt
   wire              ch_end;
   wire              ch_end_set;
   wire              ch_end_clear;
   wire              ch_end_int;
   wire [2:0]              int_proc_num;              
   reg [2:0]              int_proc_num_reg;    
   wire [INT_NUM-1:0]          int_bus;    
   wire [INT_NUM-1:0]          int_rawstat;
   reg [INT_NUM-1:0]          int_enable;         
   wire [INT_NUM-1:0]          int_status;
   wire [7:0]                    int_all_proc_bus;
   
   wire              wr_cmd_line0;
   wire              wr_cmd_line1;
   wire              wr_cmd_line2;
   wire              wr_cmd_line3;
   wire              wr_static_line0;
   wire              wr_static_line1;
   wire              wr_static_line2;
   wire              wr_static_line3;
   wire              wr_static_line4;
   wire              wr_ch_enable;
   wire              wr_ch_start;
   wire              wr_int_rawstat;
   wire              wr_int_clear;
   wire              wr_int_enable;
   wire              wr_frame_width;
   
   reg [31:0]              rd_cmd_line0;
   reg [31:0]              rd_cmd_line1;
   reg [31:0]              rd_cmd_line2;
   reg [31:0]              rd_cmd_line3;
   reg [31:0]              rd_static_line0;
   reg [31:0]              rd_static_line1;
   reg [31:0]              rd_static_line2;
   reg [31:0]              rd_static_line3;
   reg [31:0]              rd_static_line4;
   reg [31:0]              rd_restrict;
   reg [31:0]              rd_rd_offsets;
   reg [31:0]              rd_wr_offsets;
   reg [31:0]              rd_fifo_fullness;
   reg [31:0]              rd_cmd_outs;
   reg [31:0]              rd_ch_enable;
   reg [31:0]              rd_ch_active;
   reg [31:0]              rd_cmd_counter;
   reg [31:0]              rd_int_rawstat;
   reg [31:0]              rd_int_enable;
   reg [31:0]              rd_int_status;
   
   wire              load_wr_cycle0;
   wire              load_wr_cycle1;
   wire              load_wr_cycle2;
   wire              load_wr_cycle3;
   wire              load_wr0;
   wire              load_wr1;
   wire              load_wr2;
   wire              load_wr3;
   wire              load_wr_last;
   wire              load_req;

   wire              timeout_aw;
   wire              timeout_w;
   wire              timeout_b;
   wire              timeout_ar;
   wire              timeout_r;
   
   wire              ch_retry_wait_pre;
   reg                  ch_retry_wait_reg;
   wire              ch_retry_wait;
   wire              ch_retry;
   wire              ch_update_pre;
   reg                  ch_update;
   wire              ch_update_d;
   
   wire              ch_int;
   
   
   //---------------------- gating -------------------------------------
   
   
   //assign             gpaddr      = {8{psel}} & paddr;
   assign             gpaddr      = paddr; //removed for timing
   assign             gpwrite     = psel & (~penable) & pwrite;
   assign             gpread      = psel & (~penable) & (~pwrite);

   
   //---------------------- Write Operations ----------------------------------
   assign             wr_cmd_line0      = gpwrite & gpaddr == CMD_LINE0;
   assign             wr_cmd_line1      = gpwrite & gpaddr == CMD_LINE1;
   assign             wr_cmd_line2      = gpwrite & gpaddr == CMD_LINE2;
   assign             wr_cmd_line3      = gpwrite & gpaddr == CMD_LINE3;
   assign             wr_static_line0   = gpwrite & gpaddr == STATIC_LINE0;
   assign             wr_static_line1   = gpwrite & gpaddr == STATIC_LINE1;
   assign             wr_static_line2   = gpwrite & gpaddr == STATIC_LINE2;
   assign             wr_static_line3   = gpwrite & gpaddr == STATIC_LINE3;
   assign             wr_static_line4   = gpwrite & gpaddr == STATIC_LINE4;
   assign             wr_ch_enable      = gpwrite & gpaddr == CH_ENABLE;
   assign             wr_ch_start       = (gpwrite & gpaddr == CH_START) | ch_start;
   assign             wr_int_rawstat    = gpwrite & gpaddr == INT_RAWSTAT;
   assign             wr_int_clear      = gpwrite & gpaddr == INT_CLEAR;
   assign             wr_int_enable     = gpwrite & gpaddr == INT_ENABLE;
   
   assign             load_wr_cycle0 = load_wr & load_wr_cycle == 2'd0;
   assign             load_wr_cycle1 = load_wr & load_wr_cycle == 2'd1;
   assign             load_wr_cycle2 = load_wr & load_wr_cycle == 2'd2;
   assign             load_wr_cycle3 = load_wr & load_wr_cycle == 2'd3;

   assign             load_wr0 = 1 ? load_wr_cycle0 : load_wr_cycle0;
   assign             load_wr1 = 1 ? load_wr_cycle1 : load_wr_cycle0;
   assign             load_wr2 = 1 ? load_wr_cycle2 : load_wr_cycle1;
   assign             load_wr3 = 1 ? load_wr_cycle3 : load_wr_cycle1;
   
   assign             load_wr_last       = load_wr3; 

   
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      rd_start_addr <= #1 {32{1'b0}};
       end
     else if (wr_cmd_line0)
       begin
      rd_start_addr <= #1 pwdata[32-1:0];
       end
     else if (load_wr0)
       begin
      rd_start_addr <= #1 load_wdata[32-1:0];
       end
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      wr_start_addr <= #1 {32{1'b0}};
       end
     else if (wr_cmd_line1)
       begin
      wr_start_addr <= #1 pwdata[32-1:0];
       end
     else if (load_wr1)
       begin
      wr_start_addr <= #1 load_wdata[32+32-DATA_SHIFT-1:32-DATA_SHIFT];
       end

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      buff_size <= #1 {10{1'b0}};
       end
     else if (wr_cmd_line2)
       begin
      buff_size <= #1 pwdata[10-1:0];
       end
     else if (load_wr2)
       begin
      buff_size <= #1 load_wdata[10-1:0];
       end

   always @(posedge clk or posedge reset)
     if (reset)
       begin
     cmd_set_int_reg   <= #1 1'b0;
     cmd_last_reg      <= #1 1'b0;
     cmd_next_addr_reg <= #1 {30{1'b0}};
       end
     else if (wr_cmd_line3)
       begin
      cmd_set_int_reg   <= #1 pwdata[0];
      cmd_last_reg      <= #1 pwdata[1];
      cmd_next_addr_reg <= #1 pwdata[32-1:2];
       end
     else if (load_wr3)
       begin
      cmd_set_int_reg   <= #1 load_wdata[32-DATA_SHIFT];
      cmd_last_reg      <= #1 load_wdata[33-DATA_SHIFT];
      cmd_next_addr_reg <= #1 load_wdata[32+32-DATA_SHIFT-1:34-DATA_SHIFT];
       end

   always @(posedge clk or posedge reset)
     if (reset)
       cmd_counter_reg <= #1 {`CMD_CNT_BITS{1'b0}};
     else if (wr_ch_start)
       cmd_counter_reg <= #1 {`CMD_CNT_BITS{1'b0}};
     else if (ch_end & clken)
       cmd_counter_reg <= #1 cmd_counter_reg + 1'b1;
  
   
   always @(posedge clk or posedge reset)
     if (reset)
       int_counter_reg <= #1 {`INT_CNT_BITS{1'b0}};
     else if (wr_ch_start)
       int_counter_reg <= #1 {`INT_CNT_BITS{1'b0}};
     else if ((ch_end_int & clken) | ch_end_clear)
       int_counter_reg <= #1 int_counter_reg + (ch_end_int & clken) - ch_end_clear;

   assign cmd_set_int   = cmd_set_int_reg;
   assign cmd_last      = cmd_last_reg;
   assign cmd_next_addr = cmd_next_addr_reg;
      
   assign cmd_counter   = cmd_counter_reg;
   assign int_counter   = int_counter_reg;
   
   
   assign x_size = block ? {{10-`X_BITS{1'b0}}, buff_size[`X_BITS-1:0]} : buff_size;
   assign y_size = block ? buff_size[10-1:`X_BITS] : 'd1;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
            rd_burst_max_size_reg <= #1 'd0;
   rd_tokens_reg         <= #1 'd1; 
    rd_outs_max_reg       <= #1 {`OUT_BITS{1'b0}}; 
            rd_incr_reg           <= #1 'd1;
       end
     else if (wr_static_line0)
       begin
            rd_burst_max_size_reg <= #1 pwdata[7-1:0];
  rd_tokens_reg         <= #1 pwdata[`TOKEN_BITS+16-1:16]; 
     rd_outs_max_reg       <= #1 pwdata[`OUT_BITS+24-1:24]; 
            rd_incr_reg           <= #1 pwdata[31];
       end
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
            wr_burst_max_size_reg <= #1 'd0;
  wr_tokens_reg         <= #1 'd1; 
     wr_outs_max_reg       <= #1 {`OUT_BITS{1'b0}}; 
      wr_incr_reg           <= #1 'd1;
       end
     else if (wr_static_line1)
       begin
      wr_burst_max_size_reg <= #1 pwdata[7-1:0];
  wr_tokens_reg         <= #1 pwdata[`TOKEN_BITS+16-1:16]; 
     wr_outs_max_reg       <= #1 pwdata[`OUT_BITS+24-1:24]; 
      wr_incr_reg           <= #1 pwdata[31];
       end

   assign rd_incr = rd_incr_reg;
   assign wr_incr = wr_incr_reg;
   
   assign rd_outstanding_cfg = 1'b0;
   assign wr_outstanding_cfg = 1'b0;
   assign rd_outstanding     = 1'b0;
   assign wr_outstanding     = 1'b0;

   assign rd_tokens = rd_tokens_reg;
   assign wr_tokens = joint_mux ? rd_tokens_reg : wr_tokens_reg;

   assign rd_outs_max = rd_outs_max_reg;
   assign wr_outs_max = joint_mux ? rd_outs_max_reg : wr_outs_max_reg;
   

   assign rd_allow_full_fifo = rd_start_addr[5-1:0] == 'd0;
   assign wr_allow_full_fifo = wr_start_addr[5-1:0] == 'd0;
   
   assign allow_full_fifo    = rd_allow_full_fifo & wr_allow_full_fifo;

   assign rd_burst_max_size  = rd_burst_max_size_pre;
   assign wr_burst_max_size  = joint_mux ? rd_burst_max_size_pre : wr_burst_max_size_pre;
   
   assign allow_joint_burst  = joint & (~joint_flush) & (~page_cross) & (~joint_cross);

  assign allow_full_burst   = allow_joint_burst; 
   
   assign burst_max_size_update_pre = ch_update | ch_update_d | joint;

   prgen_delay #(1) delay_max_size_update (.clk(clk), .reset(reset), .din(burst_max_size_update_pre), .dout(burst_max_size_update));

   dma_axi32_core0_ch_reg_size
   dma_axi32_core0_ch_reg_size_rd (
                .clk(clk),
                .reset(reset),
                .update(burst_max_size_update),
                .start_addr(rd_start_addr),
                .burst_max_size_reg(rd_burst_max_size_reg),
                .burst_max_size_other(wr_burst_max_size_rd),
                .allow_full_burst(allow_full_burst),
                .allow_full_fifo(allow_full_fifo),
                .joint_flush(joint_flush),
                .burst_max_size(rd_burst_max_size_pre)
                );


   dma_axi32_core0_ch_reg_size
   dma_axi32_core0_ch_reg_size_wr (
                .clk(clk),
                .reset(reset),
                .update(burst_max_size_update),
                .start_addr(wr_start_addr),
                .burst_max_size_reg(wr_burst_max_size_reg),
                .burst_max_size_other(rd_burst_max_size_reg),
                .allow_full_burst(1'b0),
                .allow_full_fifo(allow_full_fifo),
                .joint_flush(joint_flush),
                .burst_max_size(wr_burst_max_size_pre)
                );
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
                 joint_reg        <= #1 1'b1;
         end_swap_reg     <= #1 2'b00; 
       end
     else if (wr_static_line2)
       begin
                 joint_reg        <= #1 pwdata[16];
         end_swap_reg     <= #1 pwdata[29:28]; 
       end

   
   always @(posedge clk or posedge reset)
     if (reset)
       simple_mem <= #1 1'b0;
     else if (ch_update)
       simple_mem <= #1 (rd_periph_num == 'd0) & (wr_periph_num == 'd0) & (~allow_line_cmd);

   assign joint     = joint_mode & joint_reg & simple_mem & 1'b1;
   
   assign joint_mux = joint;
   


   assign cmd_port_num     = 1'b0;
   assign rd_port_num_cfg  = 1'b0;
   assign wr_port_num      = 1'b0;
   assign rd_port_num      = 1'b0;
   
   
   assign frame_width = {`FRAME_BITS{1'b0}};
   assign block       = 1'b0;
   
   assign width_align = frame_width[2-1:0];
   

   assign rd_wait_limit = {`WAIT_BITS-4{1'b0}};
   assign wr_wait_limit = {`WAIT_BITS-4{1'b0}};
   
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
          rd_periph_num_reg   <= #1 'd0; //0 is memory
          rd_periph_delay_reg <= #1 'd0; //0 is memory
            wr_periph_num_reg   <= #1 'd0; //0 is memory
          wr_periph_delay_reg <= #1 'd0; //0 is memory
       end
     else if (wr_static_line4)
       begin
          rd_periph_num_reg   <= #1 pwdata[4:0];
          rd_periph_delay_reg <= #1 pwdata[`DELAY_BITS+8-1:8];
          wr_periph_num_reg   <= #1 pwdata[20:16];
          wr_periph_delay_reg <= #1 pwdata[`DELAY_BITS+24-1:24];
       end

   assign rd_periph_num   = rd_periph_num_reg;
   assign wr_periph_num   = wr_periph_num_reg;
   assign rd_periph_delay = rd_periph_delay_reg;
   assign wr_periph_delay = wr_periph_delay_reg;
   
   assign rd_periph_block = 1'b0;
   assign wr_periph_block = 1'b0;

   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      ch_enable <= #1 1'b1;
       end
     else if (wr_ch_enable)
       begin
      ch_enable <= #1 pwdata[0];
       end
   
   always @(posedge clk or posedge reset)
     if (reset)
       ch_in_prog <= #1 1'b0;
     else if (ch_update)
       ch_in_prog <= #1 1'b1;
     else if (ch_end & clken)
       ch_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_ch_in_prog <= #1 1'b0;
     else if (ch_update)
       rd_ch_in_prog <= #1 1'b1;
     else if (fifo_underflow | fifo_overflow)
       rd_ch_in_prog <= #1 1'b0;
     else if (rd_ch_end & clken)
       rd_ch_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_ch_in_prog <= #1 1'b0;
     else if (ch_update)
       wr_ch_in_prog <= #1 1'b1;
     else if (fifo_underflow | fifo_overflow)
       wr_ch_in_prog <= #1 1'b0;
     else if (wr_ch_end & clken)
       wr_ch_in_prog <= #1 1'b0;

   always @(posedge clk or posedge reset)
     if (reset)
       load_in_prog_reg <= #1 1'b0;
     else if (load_req & clken)
       load_in_prog_reg <= #1 1'b1;
     else if (ch_update & clken)
       load_in_prog_reg <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       load_req_in_prog_reg <= #1 1'b0;
     else if (load_req & clken)
       load_req_in_prog_reg <= #1 1'b1;
     else if (load_cmd & clken)
       load_req_in_prog_reg <= #1 1'b0;

   assign load_in_prog     = load_in_prog_reg;
   assign load_req_in_prog = load_req_in_prog_reg;

   assign auto_retry    = 1'b0;
   assign ch_retry_wait = 1'b0;
   assign ch_retry      = 1'b0;
   
   assign ch_update_pre = wr_ch_start | load_wr_last | ch_retry;

   always @(posedge clk or posedge reset)
     if (reset)
       ch_update <= #1 1'b0;
     else if (ch_update_pre)
       ch_update <= #1 1'b1;
     else if (clken)
       ch_update <= #1 1'b0;
   
   prgen_delay #(1) delay_ch_update (.clk(clk), .reset(reset), .din(ch_update), .dout(ch_update_d));

   assign load_req       = (ch_enable & ch_end & (~cmd_last)) | (ch_update & (x_size == 'd0));
   assign load_addr      = {cmd_next_addr[32-1:2], 2'b00};

   assign ch_end         = rd_ch_end & wr_ch_end & wr_clr_last & (~ch_retry_wait);

   assign ch_end_int     = ch_enable & ch_end & cmd_set_int;
   assign ch_rd_active   = ch_enable & (rd_ch_in_prog | load_req_in_prog);
   assign ch_wr_active   = ch_enable & wr_ch_in_prog;
   
   assign ch_end_set     = |int_counter;
   assign ch_end_clear   = wr_int_clear & pwdata[0];

   assign {timeout_aw,
           timeout_w,
           timeout_b,
           timeout_ar,
           timeout_r} = timeout_bus[4:0];
   
   
   
   assign int_bus        = {INT_NUM{clken}} & {
                           wdt_timeout,
                           timeout_aw,
                           timeout_w,
                           timeout_b,
                           timeout_ar,
                           timeout_r,
                           fifo_underflow,
                           fifo_overflow,
                           wr_decerr,
                           rd_decerr,
                           wr_slverr,
                           rd_slverr,
                           ch_end_set
                           };

   prgen_rawstat #(INT_NUM) rawstat(
                    .clk(clk),
                    .reset(reset),
                    .clear(wr_int_clear),
                    .write(wr_int_rawstat),
                    .pwdata(pwdata[INT_NUM-1:0]),
                    .int_bus(int_bus),
                    .rawstat(int_rawstat)
                    );
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       int_enable <= #1 {INT_NUM{1'b1}};
     else if (wr_int_enable)
       int_enable <= #1 pwdata[INT_NUM-1:0];

   assign int_status = int_rawstat & int_enable;

   assign ch_int     = |int_status;

   assign int_proc_num = 3'd0;
   assign int_all_proc = ch_int;

   assign end_swap = end_swap_reg;
   
   //---------------------- Read Operations -----------------------------------  
   assign rd_burst_max_size_rd = rd_burst_max_size_reg;
   assign wr_burst_max_size_rd = wr_burst_max_size_reg;

   
   //always @(/*AUTOSENSE*/) - no AUTOSENSE because of include file  
   always @(allow_full_burst or allow_full_fifo
        or allow_joint_burst or allow_line_cmd or auto_retry
        or block or buff_size or ch_enable or ch_rd_active
        or ch_wr_active or cmd_counter or cmd_last
        or cmd_next_addr or cmd_port_num or cmd_set_int
        or end_swap or frame_width or int_counter or int_enable
        or int_proc_num or int_rawstat or int_status or joint_reg
        or rd_allow_full_fifo or rd_burst_max_size_rd or rd_gap
        or rd_incr or rd_outs or rd_outs_max or rd_outstanding
        or rd_outstanding_cfg or rd_periph_block_reg
        or rd_periph_delay or rd_periph_num or rd_port_num_cfg
        or rd_start_addr or rd_tokens or rd_wait_limit
        or rd_x_offset or rd_y_offset or simple_mem
        or wr_allow_full_fifo or wr_burst_max_size_rd
        or wr_fullness or wr_incr or wr_outs or wr_outs_max
        or wr_outstanding or wr_outstanding_cfg
        or wr_periph_block_reg or wr_periph_delay or wr_periph_num
        or wr_port_num or wr_start_addr or wr_tokens
        or wr_wait_limit or wr_x_offset or wr_y_offset)
     begin
    rd_cmd_line0     = {32{1'b0}};
    rd_cmd_line1     = {32{1'b0}};
    rd_cmd_line2     = {32{1'b0}};
    rd_cmd_line3     = {32{1'b0}};
    rd_static_line0  = {32{1'b0}};
    rd_static_line1  = {32{1'b0}};
    rd_static_line2  = {32{1'b0}};
    rd_static_line3  = {32{1'b0}};
    rd_static_line4  = {32{1'b0}};
    rd_restrict      = {32{1'b0}};
     rd_rd_offsets    = {32{1'b0}};
     rd_wr_offsets    = {32{1'b0}};
      rd_fifo_fullness = {32{1'b0}};
      rd_cmd_outs      = {32{1'b0}};
    rd_ch_enable     = {32{1'b0}};
    rd_ch_active     = {32{1'b0}};
    rd_cmd_counter   = {32{1'b0}};
    rd_int_rawstat   = {32{1'b0}};
    rd_int_enable    = {32{1'b0}};
    rd_int_status    = {32{1'b0}};

    
    rd_cmd_line0[32-1:0]           = rd_start_addr;
    
    rd_cmd_line1[32-1:0]           = wr_start_addr;
    
    rd_cmd_line2[10-1:0]           = buff_size;
    
    rd_cmd_line3[0]                       = cmd_set_int;
    rd_cmd_line3[1]                       = cmd_last;
    rd_cmd_line3[32-1:2]           = cmd_next_addr;
    
    rd_static_line0[7-1:0]       = rd_burst_max_size_rd;
    rd_static_line0[`TOKEN_BITS+16-1:16]  = rd_tokens;
    rd_static_line0[`OUT_BITS+24-1:24]    = rd_outs_max;
    rd_static_line0[30]                   = rd_outstanding_cfg;
    rd_static_line0[31]                   = rd_incr;
    
    rd_static_line1[7-1:0]       = wr_burst_max_size_rd;
    rd_static_line1[`TOKEN_BITS+16-1:16]  = wr_tokens;
    rd_static_line1[`OUT_BITS+24-1:24]    = wr_outs_max;
    rd_static_line1[30]                   = wr_outstanding_cfg;
    rd_static_line1[31]                   = wr_incr;
    
    rd_static_line2[`FRAME_BITS-1:0]      = frame_width;
    rd_static_line2[15]                   = block;
    rd_static_line2[16]                   = joint_reg;
    rd_static_line2[17]                   = auto_retry;
    rd_static_line2[20]                   = cmd_port_num;
    rd_static_line2[21]                   = rd_port_num_cfg;
    rd_static_line2[22]                   = wr_port_num;
    rd_static_line2[26:24]                = int_proc_num;
    rd_static_line2[29:28]                = end_swap;
    
    
    rd_static_line4[4:0]                  = rd_periph_num;
    rd_static_line4[`DELAY_BITS+8-1:8]    = rd_periph_delay;
    rd_static_line4[20:16]                = wr_periph_num;
    rd_static_line4[`DELAY_BITS+24-1:24]  = wr_periph_delay;
    
    rd_restrict[0]                        = rd_allow_full_fifo;
    rd_restrict[1]                        = wr_allow_full_fifo;
    rd_restrict[2]                        = allow_full_fifo;
    rd_restrict[3]                        = allow_full_burst;
    rd_restrict[4]                        = allow_joint_burst;
    rd_restrict[5]                        = rd_outstanding;
    rd_restrict[6]                        = wr_outstanding;
    rd_restrict[7]                        = allow_line_cmd;
    rd_restrict[8]                        = simple_mem;
        
    rd_rd_offsets[10-1:0]          = rd_x_offset;
    rd_rd_offsets[10-`X_BITS+16-1:16]     = rd_y_offset;

    rd_wr_offsets[10-1:0]          = wr_x_offset;
    rd_wr_offsets[10-`X_BITS+16-1:16]     = wr_y_offset;

    rd_fifo_fullness[5:0]           = rd_gap;
    rd_fifo_fullness[5+16:16]     = wr_fullness;

    rd_cmd_outs[`OUT_BITS-1:0]            = rd_outs;
    rd_cmd_outs[`OUT_BITS-1+8:8]          = wr_outs;
    
    rd_ch_enable[0]                       = ch_enable;
    
    rd_ch_active[0]                       = ch_rd_active;
    rd_ch_active[1]                       = ch_wr_active;
    
    rd_cmd_counter[`CMD_CNT_BITS-1:0]     = cmd_counter;
    rd_cmd_counter[`INT_CNT_BITS-1+16:16] = int_counter;
        
    rd_int_rawstat[INT_NUM-1:0]           = int_rawstat;
    
    rd_int_enable[INT_NUM-1:0]            = int_enable;
    
    rd_int_status[INT_NUM-1:0]            = int_status;
     end
   
               
   //always @(/*AUTOSENSE*/) - no AUTOSENSE because of include file
   always @(gpaddr or rd_ch_active or rd_ch_enable
        or rd_cmd_counter or rd_cmd_line0 or rd_cmd_line1
        or rd_cmd_line2 or rd_cmd_line3 or rd_cmd_outs
        or rd_fifo_fullness or rd_int_enable or rd_int_rawstat
        or rd_int_status or rd_rd_offsets or rd_restrict
        or rd_static_line0 or rd_static_line1 or rd_static_line2
        or rd_static_line3 or rd_static_line4 or rd_wr_offsets)
     begin
    prdata_pre  = {32{1'b0}};
      
    case (gpaddr)
      CMD_LINE0                 : prdata_pre  = rd_cmd_line0;
      CMD_LINE1                 : prdata_pre  = rd_cmd_line1;
      CMD_LINE2                 : prdata_pre  = rd_cmd_line2;
      CMD_LINE3                 : prdata_pre  = rd_cmd_line3;
      
      STATIC_LINE0              : prdata_pre  = rd_static_line0;
      STATIC_LINE1              : prdata_pre  = rd_static_line1;
      STATIC_LINE2              : prdata_pre  = rd_static_line2;
      STATIC_LINE3              : prdata_pre  = rd_static_line3;
      STATIC_LINE4              : prdata_pre  = rd_static_line4;

      RESTRICT                  : prdata_pre  = rd_restrict;
      RD_OFFSETS                : prdata_pre  = rd_rd_offsets;
      WR_OFFSETS                : prdata_pre  = rd_wr_offsets;
      FIFO_FULLNESS             : prdata_pre  = rd_fifo_fullness;
      CMD_OUTS                  : prdata_pre  = rd_cmd_outs;
      
      CH_ENABLE                 : prdata_pre  = rd_ch_enable;
      CH_START                  : prdata_pre  = {32{1'b0}};
      CH_ACTIVE                 : prdata_pre  = rd_ch_active;
      CH_CMD_COUNTER            : prdata_pre  = rd_cmd_counter;
      
      INT_RAWSTAT               : prdata_pre  = rd_int_rawstat;
      INT_CLEAR                 : prdata_pre  = {32{1'b0}};
      INT_ENABLE                : prdata_pre  = rd_int_enable;
      INT_STATUS                : prdata_pre  = rd_int_status;
      
      default                   : prdata_pre  = {32{1'b0}};
    endcase
     end

               
   //always @(/*AUTOSENSE*/) - no AUTOSENSE because of include file
   always @(gpaddr or gpread or gpwrite or psel)
     begin
    pslverr_pre = 1'b0;
      
    case (gpaddr)
      CMD_LINE0                 : pslverr_pre = 1'b0;    //read and write  
      CMD_LINE1                 : pslverr_pre = 1'b0;    //read and write  
      CMD_LINE2                 : pslverr_pre = 1'b0;    //read and write  
      CMD_LINE3                 : pslverr_pre = 1'b0;    //read and write  
      
      STATIC_LINE0              : pslverr_pre = 1'b0;    //read and write  
      STATIC_LINE1              : pslverr_pre = 1'b0;    //read and write  
      STATIC_LINE2              : pslverr_pre = 1'b0;    //read and write   
      STATIC_LINE3              : pslverr_pre = 1'b0;    //read and write   
      STATIC_LINE4              : pslverr_pre = 1'b0;    //read and write  
      
      RESTRICT                  : pslverr_pre = gpwrite; //read only
      RD_OFFSETS                : pslverr_pre = gpwrite; //read only
      WR_OFFSETS                : pslverr_pre = gpwrite; //read only
      FIFO_FULLNESS             : pslverr_pre = gpwrite; //read only
      CMD_OUTS                  : pslverr_pre = gpwrite; //read only
      
      CH_ENABLE                 : pslverr_pre = 1'b0;    //read and write  
      CH_START                  : pslverr_pre = gpread;  //write only
      CH_ACTIVE                 : pslverr_pre = gpwrite; //read only
      CH_CMD_COUNTER            : pslverr_pre = gpwrite; //read only
      
      INT_RAWSTAT               : pslverr_pre = 1'b0;    //read and write  
      INT_CLEAR                 : pslverr_pre = gpread;  //write only
      INT_ENABLE                : pslverr_pre = 1'b0;    //read and write  
      INT_STATUS                : pslverr_pre = gpwrite; //read only
      
      default                   : pslverr_pre = psel;    //decode error
    endcase
     end

   always @(posedge clk or posedge reset)
     if (reset)
       prdata <= #1 {32{1'b0}};
     else if (gpread & pclken)
       prdata <= #1 prdata_pre;
     else if (pclken)
       prdata <= #1 {32{1'b0}};
   
   always @(posedge clk or posedge reset)
     if (reset)
       pslverr <= #1 1'b0;
     else if ((gpread | gpwrite) & pclken)
       pslverr <= #1 pslverr_pre;
     else if (pclken)
       pslverr <= #1 1'b0;


   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: dma_ch_remain.v
//---------------------------------------------------------



module dma_axi32_core0_ch_remain(clk,reset,ch_update,wr_outstanding,rd_outstanding,load_req_in_prog,rd_line_cmd,rd_burst_start,rd_burst_size,rd_transfer,rd_transfer_size,wr_clr_line,wr_burst_start,wr_burst_size,wr_transfer,wr_transfer_size,rd_gap,wr_fullness);

   input                    clk;
   input             reset;

   input             ch_update;
   input             wr_outstanding;
   input             rd_outstanding;
   input             load_req_in_prog;
   
   input             rd_line_cmd;
   input             rd_burst_start; 
   input [7-1:0]   rd_burst_size; 
   input             rd_transfer;
   input [3-1:0]    rd_transfer_size;
   
   input             wr_clr_line;
   input             wr_burst_start;
   input [7-1:0]   wr_burst_size;  
   input             wr_transfer;
   input [3-1:0]    wr_transfer_size;
   
   output [5:0]     rd_gap;
   output [5:0]     wr_fullness; 
   


   wire             rd_line_cmd_valid;
   reg [5+1:0]         rd_gap_reg; //signed
   reg [5+1:0]         wr_fullness_reg; //signed

   wire             rd_burst_qual;
   wire             wr_burst_qual;
   reg [7-1:0]     rd_burst_size_valid; 
   wire [3-1:0]     rd_transfer_size_valid;
   wire [3-1:0]     wr_transfer_size_valid;
   reg [7-1:0]     wr_burst_size_valid; 



   
   assign             rd_line_cmd_valid = rd_line_cmd & rd_burst_start;
   
   assign             rd_burst_qual = rd_burst_start & (~load_req_in_prog);
   assign             wr_burst_qual = wr_burst_start;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_burst_size_valid <= #1 {7{1'b0}};
     else if (rd_burst_qual)
       rd_burst_size_valid <= #1 rd_burst_size;
     else
       rd_burst_size_valid <= #1 {7{1'b0}};
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_burst_size_valid <= #1 {7{1'b0}};
     else if (wr_burst_qual)
       wr_burst_size_valid <= #1 wr_burst_size;
     else
       wr_burst_size_valid <= #1 {7{1'b0}};
   
   assign             rd_transfer_size_valid = {3{rd_transfer}} & rd_transfer_size;
   assign             wr_transfer_size_valid = {3{wr_transfer}} & wr_transfer_size;
   
   
   //for rd bursts
   always @(posedge clk or posedge reset)
     if (reset)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else if (ch_update)
       rd_gap_reg <= #1 {1'b0, 1'b1, {5{1'b0}}};
     else
       rd_gap_reg <= #1 rd_gap_reg - 
             rd_burst_size_valid +
             wr_transfer_size_valid;
   
   
   assign rd_gap = rd_gap_reg[5+1] ? 'd0 : rd_gap_reg[5:0];

   
   //for wr bursts
   always @(posedge clk or posedge reset)
     if (reset)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else if (ch_update)
       wr_fullness_reg <= #1 {5+1{1'b0}};
     else
       wr_fullness_reg <= #1 wr_fullness_reg -
              wr_burst_size_valid +
              rd_transfer_size_valid; 

   
   assign wr_fullness = wr_fullness_reg[5+1] ? 'd0 : wr_fullness_reg[5:0];
   
endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: dma_ch.v
//---------------------------------------------------------


    

module dma_axi32_core0_ch (clk,reset,scan_en,pclk,clken,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,rd_cmd_split,rd_cmd_line,rd_clr_line,rd_clr,rd_clr_load,rd_slverr,rd_decerr,wr_cmd_split,wr_cmd_pending,wr_clr_line,wr_clr,wr_clr_last,wr_slverr,wr_decerr,load_wr,load_wr_cycle,load_wdata,load_req_in_prog,int_all_proc,ch_start,idle,ch_active,ch_rd_active,ch_wr_active,wr_last_cmd,rd_line_cmd,wr_line_cmd,rd_go_next_line,wr_go_next_line,rd_ready,rd_burst_start,rd_burst_addr,rd_burst_size,rd_tokens,rd_port_num,rd_periph_delay,rd_clr_valid,rd_transfer,rd_transfer_size,rd_clr_stall,wr_ready,wr_burst_start,wr_burst_addr,wr_burst_size,wr_tokens,wr_port_num,wr_periph_delay,wr_clr_valid,wr_transfer,wr_transfer_size,wr_next_size,wr_clr_stall,wr_incr,timeout_aw,timeout_w,timeout_ar,wdt_timeout,fifo_wr,fifo_wdata,fifo_wsize,fifo_rd,fifo_rsize,fifo_rd_valid,fifo_rdata,fifo_wr_ready,joint_mode,joint_remote,rd_page_cross,wr_page_cross,joint_in_prog,joint_not_in_prog,joint_mux_in_prog,joint_req);

   input             clk;
   input             reset;
   input             scan_en;
   
   input             pclk;
   input             clken;
   input             pclken;
   input             psel;
   input             penable;
   input [7:0]             paddr;
   input             pwrite;
   input [31:0]         pwdata;
   output [31:0]         prdata;
   output             pslverr;
   
   input [31:1]         periph_tx_req;
   output [31:1]         periph_tx_clr;
   input [31:1]         periph_rx_req;
   output [31:1]         periph_rx_clr;

   input             rd_cmd_split;
   input             rd_cmd_line;
   input             rd_clr_line;
   input             rd_clr;
   input             rd_clr_load;
   input             rd_slverr;
   input             rd_decerr;

   input             wr_cmd_split;
   input             wr_cmd_pending;
   input             wr_clr_line;
   input             wr_clr;
   input             wr_clr_last;
   input             wr_slverr;
   input             wr_decerr;
   
   input             load_wr;
   input [1:0]             load_wr_cycle;
   input [32-1:0]    load_wdata;
   output             load_req_in_prog;
   
   output [1-1:0]    int_all_proc;
   input              ch_start;
   output             idle;
   output             ch_active;
   output             ch_rd_active;
   output             ch_wr_active;
   output             wr_last_cmd;
   output             rd_line_cmd;
   output             wr_line_cmd;
   output             rd_go_next_line;
   output             wr_go_next_line;
   
   output             rd_ready;
   input             rd_burst_start;
   output [32-1:0]   rd_burst_addr;
   output [7-1:0]  rd_burst_size;
   output [`TOKEN_BITS-1:0] rd_tokens;
   output             rd_port_num;
   output [`DELAY_BITS-1:0] rd_periph_delay;
   output             rd_clr_valid;
   input             rd_transfer;
   input [3-1:0]    rd_transfer_size;
   output             rd_clr_stall;
   
   output             wr_ready;
   input             wr_burst_start;
   output [32-1:0]   wr_burst_addr;
   output [7-1:0]  wr_burst_size;
   output [`TOKEN_BITS-1:0] wr_tokens;
   output             wr_port_num;
   output [`DELAY_BITS-1:0] wr_periph_delay; 
   output             wr_clr_valid;
   input             wr_transfer;
   input [3-1:0]    wr_transfer_size;
   input [3-1:0]    wr_next_size;
   output             wr_clr_stall;
   output             wr_incr;
   
   input              timeout_aw;
   input              timeout_w;
   input              timeout_ar;
   input             wdt_timeout;

   input             fifo_wr;
   input [32-1:0]    fifo_wdata;
   input [3-1:0]    fifo_wsize;
   
   input             fifo_rd;
   input [3-1:0]    fifo_rsize;
   
   output             fifo_rd_valid;
   output [32-1:0]   fifo_rdata;
   output             fifo_wr_ready;
   
   input             joint_mode;
   input             joint_remote;
   input             rd_page_cross;
   input             wr_page_cross;
   output             joint_in_prog;
   output             joint_not_in_prog;
   output             joint_mux_in_prog;
   output             joint_req;

   

   
   //outputs of reg
   wire [32-1:0]     load_addr;
   wire             load_in_prog;
   wire             load_req_in_prog;
   wire             ch_update;
   wire [32-1:0]     rd_start_addr;
   wire [32-1:0]     wr_start_addr;
   wire [10-1:0]     x_size;
   wire [10-`X_BITS-1:0]         y_size;
   wire             block;
   wire             joint;
   wire [`FRAME_BITS-1:0]   frame_width;
   wire [2-1:0]     width_align;
   wire [`DELAY_BITS-1:0]   rd_periph_delay; 
   wire [`DELAY_BITS-1:0]   wr_periph_delay;
   wire             rd_periph_block;
   wire             wr_periph_block;
   wire [`TOKEN_BITS-1:0]   rd_tokens;
   wire [`TOKEN_BITS-1:0]   wr_tokens;
   wire             rd_port_num;
   wire             wr_port_num;
   wire [`OUT_BITS-1:0]     rd_outs_max;
   wire [`OUT_BITS-1:0]     wr_outs_max;    
   wire [`WAIT_BITS-1:0]    rd_wait_limit;
   wire [`WAIT_BITS-1:0]    wr_wait_limit;
   wire             rd_incr;
   wire             wr_incr;
   wire [7-1:0]    rd_burst_max_size;
   wire [7-1:0]    wr_burst_max_size;
   wire [4:0]             rd_periph_num;
   wire [4:0]             wr_periph_num;
   wire             wr_outstanding;
   wire             rd_outstanding;
   wire             ch_retry_wait;
   wire             ch_rd_active;
   wire             ch_wr_active;
   wire             ch_in_prog;
   wire [1:0]             end_swap;
   
   //outputs of rd offsets
   wire [10-1:0]     rd_x_offset;
   wire [10-`X_BITS-1:0]    rd_y_offset;        
   wire [10-1:0]     rd_x_remain;
   wire [10-`X_BITS-1:0]    rd_clr_remain;
   wire             rd_ch_end;
   wire             rd_go_next_line;
   wire             rd_line_empty;
   wire             rd_empty;
   wire [2-1:0]     rd_align;
   
   //outputs of wr offsets
   wire [10-1:0]     wr_x_offset;
   wire [10-`X_BITS-1:0]    wr_y_offset;        
   wire [10-1:0]     wr_x_remain;
   wire [10-`X_BITS-1:0]    wr_clr_remain;
   wire             wr_ch_end;
   wire             wr_go_next_line;
   wire             wr_line_empty;
   wire             wr_empty;
   wire [2-1:0]     wr_align;
   wire             wr_ch_end_pre;
   reg                 wr_ch_end_reg;

   //outputs of remain
   wire [5:0]         rd_gap;
   wire [5:0]         wr_fullness; 

   //outputs of outs rd
   wire             rd_cmd_outs;
   wire             rd_clr_outs;
   wire [`OUT_BITS-1:0]     rd_outs;
   wire             rd_outs_empty;
   wire             outs_empty;
   wire             rd_stall;
   wire             timeout_rresp;
   
   //outputs of outs wr
   wire             wr_cmd_outs;
   wire             wr_clr_outs;
   wire [`OUT_BITS-1:0]     wr_outs;
   wire             wr_outs_empty;
   wire             wr_stall;
   wire             wr_stall_pre;
   wire             timeout_wresp;
   
   //outputs of calc rd
   wire             rd_burst_last;
   wire [32-1:0]     rd_burst_addr;
   wire [7-1:0]    rd_burst_size;
   wire             rd_burst_ready;
   wire             rd_joint_ready;
   wire             rd_joint_flush;
   wire             joint_burst_req;
   
   //outputs of calc wr
   wire             wr_burst_last;             
   wire [32-1:0]     wr_burst_addr;
   wire [7-1:0]    wr_burst_size;
   wire             wr_burst_ready;
   wire             wr_single; 
   wire             wr_joint_ready;
   wire             wr_joint_flush;
   wire             joint_line_req;
   
   //outputs of rd periph mux
   wire [31:1]             periph_rx_clr;
   wire             rd_periph_ready;
   
   //outputs of wr periph mux
   wire [31:1]             periph_tx_clr;
   wire             wr_periph_ready;

   //outputs of rd wait
   wire             rd_wait_ready;

   //outputs of wr wait
   wire             wr_wait_ready;
   
   //outputs of fifo_ctrl
   wire             fifo_wr_ready;
   wire             fifo_overflow;
   wire             fifo_underflow;
      
   wire             rd_clr_block_pre;
   wire             rd_clr_block;
   wire             rd_clr_valid;
   wire             wr_clr_block_pre;
   wire             wr_clr_block;
   wire             wr_clr_valid;
   wire             wr_clr_mux;
   
   wire             rd_cmd_line_d;
   wire             rd_clr_stall;
   wire             wr_clr_stall;
   wire             allow_line_cmd;
      
   wire             load_cmd;

   wire [4:0]             timeout_bus;            

   wire             joint_flush;
   wire             page_cross;
   reg                 joint_cross_reg;
   wire             joint_cross;
   reg                 rd_joint_not_in_prog;
   reg                 wr_joint_not_in_prog;
   wire             joint_not_in_prog;
   reg                 rd_joint_in_prog;
   reg                 wr_joint_in_prog;
   wire             joint_in_prog;
   wire             rd_clr_outs_d_pre;
   wire             rd_clr_outs_d;
   wire             wr_clr_outs_d_pre;
   wire             wr_clr_outs_d;
   wire             rd_clr_d;
   wire             wr_clr_d;
   wire             access_port0_mux;
   wire             access_port1_mux;

   wire             idle_pre;
   wire             clk_en;
   wire             gclk;
   
   
   assign             ch_active         = ch_in_prog | load_in_prog;

   assign             outs_empty        = rd_outs_empty & wr_outs_empty;
   
   

   assign             rd_clr_outs_d_pre = rd_clr_outs & (~rd_burst_start);
   assign             wr_clr_outs_d_pre = wr_clr_outs & (~wr_burst_start);

   prgen_delay #(1) delay_rd_clr_outs (.clk(clk), .reset(reset), .din(rd_clr_outs_d_pre), .dout(rd_clr_outs_d));
   prgen_delay #(1) delay_wr_clr_outs (.clk(clk), .reset(reset), .din(wr_clr_outs_d_pre), .dout(wr_clr_outs_d));
   
   prgen_delay #(1) delay_rd_clr (.clk(clk), .reset(reset), .din(rd_clr), .dout(rd_clr_d));
   prgen_delay #(1) delay_wr_clr (.clk(clk), .reset(reset), .din(wr_clr), .dout(wr_clr_d));
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_joint_not_in_prog <= #1 1'b0;
     else if (ch_update)
       rd_joint_not_in_prog <= #1 1'b0;
     else if (rd_burst_start)
       rd_joint_not_in_prog <= #1 (~joint_req);
     else if (rd_outs_empty & rd_clr_outs_d)
       rd_joint_not_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_joint_not_in_prog <= #1 1'b0;
     else if (ch_update)
       wr_joint_not_in_prog <= #1 1'b0;
     else if (wr_burst_start)
       wr_joint_not_in_prog <= #1 (~joint_req);
     else if (wr_outs_empty & wr_clr_outs_d)
       wr_joint_not_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       rd_joint_in_prog <= #1 1'b0;
     else if (ch_update)
       rd_joint_in_prog <= #1 1'b0;
     else if (rd_burst_start)
       rd_joint_in_prog <= #1 joint_req;
     else if (rd_outs_empty & rd_clr_outs_d)
       rd_joint_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       wr_joint_in_prog <= #1 1'b0;
     else if (ch_update)
       wr_joint_in_prog <= #1 1'b0;
     else if (wr_burst_start)
       wr_joint_in_prog <= #1 joint_req;
     else if (wr_outs_empty & wr_clr_outs_d)
       wr_joint_in_prog <= #1 1'b0;
   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_cross_reg <= #1 1'b0;
     else if (ch_update)
       joint_cross_reg <= #1 1'b0;
     else if (page_cross & joint)
       joint_cross_reg <= #1 1'b1;
     else if (joint_not_in_prog & outs_empty)
       joint_cross_reg <= #1 1'b0;

   assign             joint_cross       = joint_cross_reg;
   assign             page_cross        = rd_page_cross | wr_page_cross;
   assign             joint_in_prog     = rd_joint_in_prog | wr_joint_in_prog;
   assign             joint_not_in_prog = rd_joint_not_in_prog | wr_joint_not_in_prog;

   assign             access_port0_mux  = ((rd_port_num == 1'b0) | ((wr_port_num == 1'b0))) & 0;
   assign             access_port1_mux  = ((rd_port_num == 1'b1) | ((wr_port_num == 1'b1))) & 0;
   assign             joint_mux_in_prog = joint_in_prog & (access_port0_mux | access_port1_mux);
   
   assign             joint_req         = joint & rd_joint_ready & wr_joint_ready & (~joint_cross) & (~load_req_in_prog);
   assign             joint_flush       = rd_joint_flush | wr_joint_flush;

   
   assign             rd_clr_block      = 1'b1;
   assign             wr_clr_block      = 1'b1;
   assign             wr_clr_mux        = wr_clr;
   assign             rd_clr_stall      = 1'b0;
   assign             wr_clr_stall      = 1'b0;
   assign             allow_line_cmd    = 1'b0;
   assign             rd_line_cmd       = 1'b0;
   assign             wr_line_cmd       = 1'b0;

   assign             rd_clr_valid   = rd_clr_block & (~ch_retry_wait);
   assign             wr_clr_valid   = wr_clr_block & (~ch_retry_wait);
      
   assign             rd_ready       = (~rd_stall) & (~rd_clr_stall) &
                                 ch_rd_active & (rd_periph_ready | load_req_in_prog) &
                rd_wait_ready & rd_burst_ready;

  
   assign             wr_ready       = (~wr_stall) & (~wr_clr_stall) &
                                 ch_wr_active & wr_periph_ready &
                wr_wait_ready & wr_burst_ready;
   
   assign             wr_last_cmd    = wr_empty;
   
   assign             load_cmd       = load_req_in_prog & rd_burst_start;

   assign             rd_cmd_outs    = rd_burst_start | rd_cmd_split;
   assign             wr_cmd_outs    = wr_burst_start | wr_cmd_split;

   assign             rd_clr_outs    = rd_clr | rd_clr_load;
   assign             wr_clr_outs    = wr_clr;
  

   assign             timeout_bus    = {
                          timeout_aw,
                          timeout_w,
                          {timeout_wresp & (~timeout_aw)},
                          timeout_ar,
                          {timeout_rresp & (~timeout_ar)}
                          };
   

   assign             clk_en         = ch_active | ch_update | (~outs_empty) | (~rd_wait_ready) | (~wr_wait_ready);
   
   assign             idle_pre       = !clk_en;
   prgen_delay #(1) delay_idle (.clk(clk), .reset(reset), .din(idle_pre), .dout(idle));

   assign             gclk = clk;
   
   
   dma_axi32_core0_ch_reg
   dma_axi32_ch_reg (
          .clk(pclk),
          .clken(clken),
          .pclken(pclken),
          .reset(reset),
          .psel(psel),
          .penable(penable),
          .paddr(paddr),
          .pwrite(pwrite),
          .pwdata(pwdata),
          .prdata(prdata),
          .pslverr(pslverr),
      
          .timeout_bus(timeout_bus),
          .wdt_timeout(wdt_timeout),

          .ch_start(ch_start),
          .load_wr(load_wr),
          .load_wr_cycle(load_wr_cycle),
          .load_wdata(load_wdata),
          .load_in_prog(load_in_prog),
          .load_req_in_prog(load_req_in_prog),
          .rd_ch_end(rd_ch_end),
          .wr_ch_end(wr_ch_end),
          .wr_clr_last(wr_clr_last),
          .rd_slverr(rd_slverr),
          .rd_decerr(rd_decerr),
          .wr_slverr(wr_slverr),
          .wr_decerr(wr_decerr),
          .int_all_proc(int_all_proc),
          .ch_rd_active(ch_rd_active),
          .ch_wr_active(ch_wr_active),
          .ch_in_prog(ch_in_prog),
          .wr_outstanding(wr_outstanding),
          .rd_outstanding(rd_outstanding),
          .ch_retry_wait(ch_retry_wait),
          
          .joint_mode(joint_mode),
          .joint_remote(joint_remote),
          .joint(joint),
          .joint_cross(joint_cross),
          .page_cross(page_cross),
          .joint_flush(joint_flush),
      
          .rd_x_offset(rd_x_offset),
          .rd_y_offset(rd_y_offset),
          .wr_x_offset(wr_x_offset),
          .wr_y_offset(wr_y_offset),
          .rd_gap(rd_gap),
          .wr_fullness(wr_fullness),
          .fifo_overflow(fifo_overflow),
          .fifo_underflow(fifo_underflow),
      
          .load_cmd(load_cmd),
          .load_addr(load_addr),
      
          .ch_update(ch_update),
          .rd_start_addr(rd_start_addr),
          .wr_start_addr(wr_start_addr),
          .x_size(x_size),
          .y_size(y_size),
      
          .rd_burst_max_size(rd_burst_max_size),
          .wr_burst_max_size(wr_burst_max_size),
          .rd_periph_delay(rd_periph_delay),
          .wr_periph_delay(wr_periph_delay),
          .rd_periph_block(rd_periph_block),
          .wr_periph_block(wr_periph_block),
          .rd_tokens(rd_tokens),
          .wr_tokens(wr_tokens),
          .end_swap(end_swap),
          .rd_port_num(rd_port_num),
          .wr_port_num(wr_port_num),
          .rd_outs_max(rd_outs_max),
          .wr_outs_max(wr_outs_max),
          .rd_outs(rd_outs),
          .wr_outs(wr_outs),
          .outs_empty(outs_empty),
          .rd_wait_limit(rd_wait_limit),
          .wr_wait_limit(wr_wait_limit),
          .rd_periph_num(rd_periph_num),
          .wr_periph_num(wr_periph_num),
          .rd_incr(rd_incr),
          .wr_incr(wr_incr),
          .block(block),
          .allow_line_cmd(allow_line_cmd),
          .frame_width(frame_width),
          .width_align(width_align)
          );

   
   dma_axi32_core0_ch_offsets
   dma_axi32_ch_offsets_rd (
             .clk(gclk),
             .reset(reset),
             .ch_update(ch_update),
             .burst_start(rd_burst_start),
             .burst_last(rd_burst_last),
             .burst_size(rd_burst_size),
             .load_req_in_prog(load_req_in_prog),
             .x_size(x_size),
             .y_size(y_size),
             .x_offset(rd_x_offset),
             .y_offset(rd_y_offset),
             .x_remain(rd_x_remain),
             .clr_remain(rd_clr_remain),
             .ch_end(rd_ch_end),
             .go_next_line(rd_go_next_line),
             .incr(rd_incr),
             .clr_line(rd_clr_line),
             .line_empty(rd_line_empty),
             .empty(rd_empty),
             .start_align(rd_start_addr[2-1:0]),
             .width_align(width_align),
             .align(wr_align) //rd address writes to fifo
             );

   dma_axi32_core0_ch_offsets
   dma_axi32_ch_offsets_wr (
             .clk(gclk),
             .reset(reset),
             .ch_update(ch_update),
             .burst_start(wr_burst_start),
             .burst_last(wr_burst_last),
             .burst_size(wr_burst_size),
             .load_req_in_prog(1'b0),
             .x_size(x_size),
             .y_size(y_size),
             .x_offset(wr_x_offset),
             .y_offset(wr_y_offset),
             .x_remain(wr_x_remain),
             .clr_remain(wr_clr_remain),
             .ch_end(wr_ch_end),
             .go_next_line(wr_go_next_line),
             .incr(wr_incr),
             .clr_line(wr_clr_line),
             .line_empty(wr_line_empty),
             .empty(wr_empty),
             .start_align(wr_start_addr[2-1:0]),
             .width_align(width_align),
             .align(rd_align) //wr address reads from fifo
             );
   
   
   dma_axi32_core0_ch_remain
   dma_axi32_ch_remain (
               .clk(gclk),
               .reset(reset),
               .ch_update(ch_update),
               .wr_outstanding(wr_outstanding),
               .rd_outstanding(rd_outstanding),
               .load_req_in_prog(load_req_in_prog),
               .rd_line_cmd(rd_line_cmd),
               .rd_burst_start(rd_burst_start),
               .rd_burst_size(rd_burst_size),
               .rd_transfer(rd_transfer),
               .rd_transfer_size(rd_transfer_size),
               .wr_clr_line(wr_clr_line),
               .wr_burst_start(wr_burst_start),
               .wr_burst_size(wr_burst_size),
               .wr_transfer(wr_transfer),
               .wr_transfer_size(wr_transfer_size),
               .rd_gap(rd_gap),
               .wr_fullness(wr_fullness)
               );

   
   dma_axi32_core0_ch_outs dma_axi32_ch_outs_rd(
                      .clk(gclk),
                      .reset(reset),
                      .cmd(rd_cmd_outs),
                      .clr(rd_clr_outs),
                      .outs_max(rd_outs_max),
                      .outs(rd_outs),
                      .outs_empty(rd_outs_empty),
                      .stall(rd_stall),
                      .timeout(timeout_rresp)
                      );
   
   dma_axi32_core0_ch_outs dma_axi32_ch_outs_wr(
                      .clk(gclk),
                      .reset(reset),
                      .cmd(wr_cmd_outs),
                      .clr(wr_clr_outs),
                      .outs_max(wr_outs_max),
                      .outs(wr_outs),
                      .outs_empty(wr_outs_empty),
                      .stall(wr_stall_pre),
                      .timeout(timeout_wresp)
                      );

   assign             wr_stall = wr_stall_pre & (~joint_req);
   
   
   
   dma_axi32_core0_ch_calc #(.READ(1))
   dma_axi32_ch_calc_rd (
              .clk(gclk),
              .reset(reset),
              .wr_cmd_pending(1'b0),
              .outs_empty(outs_empty),
              .load_in_prog(load_in_prog),
              .load_req_in_prog(load_req_in_prog),
              .load_addr(load_addr),
              .ch_update(ch_update),
              .ch_end(rd_ch_end),
              .ch_end_flush(1'b0),
              .go_next_line(rd_go_next_line),
              .burst_start(rd_burst_start),
              .burst_last(rd_burst_last),
              .burst_max_size(rd_burst_max_size),
              .start_addr(rd_start_addr),
              .incr(rd_incr),
              .frame_width(frame_width),
              .x_size(x_size[`X_BITS-1:0]),
              .x_remain(rd_x_remain),
              .fifo_remain(rd_gap),
              .fifo_wr_ready(fifo_wr_ready),
              .burst_addr(rd_burst_addr),
              .burst_size(rd_burst_size),
              .burst_ready(rd_burst_ready),
              .single(),
              .joint_ready_out(rd_joint_ready),
              .joint_ready_in(wr_joint_ready),
              .joint_line_req_in(joint_line_req),
              .joint_line_req_out(),
              .joint_burst_req_in(1'b0),
              .joint_burst_req_out(joint_burst_req),
              .joint_line_req_clr(wr_clr_d),
              .joint(joint),
              .page_cross(rd_page_cross),
              .joint_cross(joint_cross),
              .joint_flush(rd_joint_flush),
              .joint_flush_in(joint_flush)
              );

   
   dma_axi32_core0_ch_calc #(.READ(0))
   dma_axi32_ch_calc_wr (
              .clk(gclk),
              .reset(reset),
              .wr_cmd_pending(wr_cmd_pending),
              .outs_empty(outs_empty),
              .load_in_prog(load_in_prog),
              .load_req_in_prog(1'b0),
              .load_addr({32{1'b0}}),
              .ch_update(ch_update),
              .ch_end(wr_ch_end),
              .ch_end_flush(rd_ch_end),
              .go_next_line(wr_go_next_line),
              .burst_start(wr_burst_start),
              .burst_last(wr_burst_last),
              .burst_max_size(wr_burst_max_size),
              .start_addr(wr_start_addr),
              .incr(wr_incr),
              .frame_width(frame_width),
              .x_size(x_size[`X_BITS-1:0]),
              .x_remain(wr_x_remain),
              .fifo_wr_ready(1'b0),
              .fifo_remain(wr_fullness),
              .burst_addr(wr_burst_addr),
              .burst_size(wr_burst_size),
              .burst_ready(wr_burst_ready),
              .single(wr_single),
              .joint_ready_out(wr_joint_ready),
              .joint_ready_in(rd_joint_ready),
              .joint_line_req_in(1'b0),
              .joint_line_req_out(joint_line_req),
              .joint_burst_req_in(joint_burst_req),
              .joint_burst_req_out(),
              .joint_line_req_clr(rd_clr_d),
              .joint(joint),
              .page_cross(wr_page_cross),
              .joint_cross(joint_cross),
              .joint_flush(wr_joint_flush),
              .joint_flush_in(joint_flush)
              );


   assign             rd_wait_ready = 1'b1;
   assign             wr_wait_ready = 1'b1;
   

   
   dma_axi32_core0_ch_periph_mux dma_axi32_ch_periph_mux_rd(
                              .clk(gclk),
                              .reset(reset),
                              .clken(clken),
                              .periph_req(periph_rx_req),
                              .periph_clr(periph_rx_clr),
                              .periph_ready(rd_periph_ready),
                              .periph_num(rd_periph_num),
                              .clr_valid(rd_clr_valid),
                              .clr(rd_clr)
                              );

   
   dma_axi32_core0_ch_periph_mux dma_axi32_ch_periph_mux_wr(
                              .clk(gclk),
                              .reset(reset),
                              .clken(clken),
                              .periph_req(periph_tx_req),
                              .periph_clr(periph_tx_clr),
                              .periph_ready(wr_periph_ready),
                              .periph_num(wr_periph_num),
                              .clr_valid(wr_clr_valid),
                              .clr(wr_clr_mux)
                              );
   


   dma_axi32_core0_ch_fifo_ctrl
   dma_axi32_ch_fifo_ctrl (
            .clk(clk),
            .reset(reset),
            .end_swap(end_swap),
            .joint_in_prog(joint_in_prog),
            .wr_outstanding(wr_outstanding),
            .ch_update(ch_update),
            .fifo_wr(fifo_wr),
            .fifo_wdata(fifo_wdata),
            .fifo_wsize(fifo_wsize),
            .wr_align(wr_align),
            .wr_single(wr_single),
            .rd_incr(rd_incr),
            .fifo_rd(fifo_rd),
            .fifo_rsize(fifo_rsize),
            .rd_align(rd_align),
            .wr_incr(wr_incr),
            .wr_burst_size(wr_burst_size),
            .rd_clr_line(rd_clr_line),
            .wr_clr_line(wr_clr_line),
            .wr_next_size(wr_next_size),
      
            .fifo_rd_valid(fifo_rd_valid),
            .fifo_rdata(fifo_rdata),
            .fifo_wr_ready(fifo_wr_ready),
            .fifo_overflow(fifo_overflow),
            .fifo_underflow(fifo_underflow)
            );




   
endmodule


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: dma_ch_wr_slicer.v
//---------------------------------------------------------


  
module  dma_axi32_core0_ch_wr_slicer (clk,reset,ch_update,rd_clr_line,fifo_wr,fifo_wdata,fifo_wsize,wr_align,wr_ptr,rd_incr,end_swap,slice_wr,slice_wr_fifo,slice_wr_ptr,slice_bsel,slice_wdata,slice_wsize);

   input               clk;
   input               reset;

   input               ch_update;
   input               rd_clr_line;
   
   input               fifo_wr;
   input [32-1:0]      fifo_wdata;
   input [3-1:0]      fifo_wsize;
   input [2-1:0]      wr_align;
   input [5-1:0]      wr_ptr;
   input               rd_incr;
   input [1:0]               end_swap;
   
   output               slice_wr;
   output               slice_wr_fifo;
   output [5-1:0]     slice_wr_ptr;
   output [4-1:0]     slice_bsel;
   output [32-1:0]     slice_wdata;
   output [3-1:0]     slice_wsize;
   

   
   reg [3-1:0]           line_remain;                  
   wire [3-1:0]       join_wsize;
   wire [3-1:0]       append_wsize;
   wire [3-1:0]       direct_wsize;
   reg                   append;
   reg [3-1:0]           next_size;
   
   reg [32-1:0]           align_wdata;
   reg [32-1:0]           align_wdata_d;
   wire [2-1:0]       wr_align_valid;
   reg [32-1:0]           next_wdata;
   wire [4-1:0]       bsel_dec;
   reg [4-1:0]           bsel_shift;

   wire               next_wr;
   
   wire               slice_wr_pre;
   wire [5-1:0]       slice_wr_ptr_pre;
   wire [4-1:0]       slice_bsel_pre;
   wire [4-1:0]       slice_bsel_swap;
   wire [32-1:0]       slice_wdata_pre;
   reg [32-1:0]           slice_wdata_pre_d;
   wire [32-1:0]       slice_wdata_swap;
   wire [3-1:0]       slice_wsize_pre;

   wire               slice_wr;
   wire               slice_wr_fifo;
   reg [5-1:0]           slice_wr_ptr;
   reg [4-1:0]           slice_bsel;
   reg [32-1:0]           slice_wdata;
   reg [3-1:0]           slice_wsize;


   always @(posedge clk or posedge reset)
     if (reset)
       line_remain <= #1 3'd4;
     else if (ch_update |  rd_clr_line)
       line_remain <= #1 3'd4;
     else if (slice_wr_pre & (line_remain == slice_wsize_pre))
       line_remain <= #1 3'd4;
     else if (slice_wr_pre)
       line_remain <= #1 line_remain - slice_wsize_pre;
   
   assign               join_wsize = next_size + fifo_wsize;

   prgen_min2 #(3) min2_append(
                     .a(join_wsize),
                     .b(3'd4),
                     .min(append_wsize)
                     );
   
   prgen_min2 #(3) min2_direct(
                     .a(line_remain),
                     .b(fifo_wsize),
                     .min(direct_wsize)
                     );
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       append  <= #1 1'b0;
     else if (next_wr)
       append  <= #1 1'b0;
     else if (fifo_wr & (slice_wsize_pre == join_wsize))
       append  <= #1 1'b0;
     else if (fifo_wr)
       append  <= #1 1'b1;

   
   always @(posedge clk or posedge reset)
     if (reset)
       next_size  <= #1 {3{1'b0}};
     else if (next_wr)
       next_size  <= #1 {3{1'b0}};
     else if (fifo_wr & append)
       next_size  <= #1 join_wsize - append_wsize;
     else if (fifo_wr)
       next_size  <= #1 join_wsize - direct_wsize;

   
   //WDATA
   always @(posedge clk or posedge reset)
     if (reset)
       align_wdata_d <= #1 {32{1'b0}};
     else if (fifo_wr)
       align_wdata_d <= #1 align_wdata;

   
   assign               wr_align_valid = 
                  rd_incr ? wr_align : 
                  wr_align - wr_ptr[2-1:0];

   //always @(/*AUTOSENSE*/) - no AUTOSENSE because of fifo_wr
   always @(fifo_wdata or wr_align_valid or fifo_wr)
     begin
    case (wr_align_valid[2-1:0])
      2'd0 : align_wdata = fifo_wdata;
      2'd1 : align_wdata = {fifo_wdata[7:0],  fifo_wdata[31:8]};
      2'd2 : align_wdata = {fifo_wdata[15:0], fifo_wdata[31:16]};
      2'd3 : align_wdata = {fifo_wdata[23:0], fifo_wdata[31:24]};
    endcase
     end


   always @(/*AUTOSENSE*/align_wdata or align_wdata_d or next_size)
     begin
    case (next_size[2-1:0])
      2'd0 : next_wdata = align_wdata_d;
      2'd1 : next_wdata = {align_wdata[31:8],  align_wdata_d[7:0]};
      2'd2 : next_wdata = {align_wdata[31:16], align_wdata_d[15:0]};
      2'd3 : next_wdata = {align_wdata[31:24], align_wdata_d[23:0]};
    endcase
     end

   
   //BSEL
   assign bsel_dec = 
      slice_wsize == 4'd1 ? 4'b0001 :
      slice_wsize == 4'd2 ? 4'b0011 :
      slice_wsize == 4'd3 ? 4'b0111 :
      slice_wsize == 4'd4 ? 4'b1111 :
             {4{1'b0}};

   
   always @(/*AUTOSENSE*/bsel_dec or wr_ptr)
     begin
    case (wr_ptr[2-1:0])
      2'd0 : bsel_shift = bsel_dec;
      2'd1 : bsel_shift = {bsel_dec[2:0], 1'b0};
      2'd2 : bsel_shift = {bsel_dec[1:0], 2'b0};
      2'd3 : bsel_shift = {bsel_dec[0],   3'b0};
    endcase
     end


   //CMD
   assign next_wr             = (~fifo_wr) & (|next_size);
   
   assign slice_wr_pre        = fifo_wr | next_wr;
      
   assign slice_wsize_pre     =  
      next_wr ? next_size    : 
      append  ? append_wsize : direct_wsize;
    
   assign slice_wr_ptr_pre    = wr_ptr;

   assign slice_wdata_pre     = append ? next_wdata : align_wdata;

   assign slice_bsel_pre      = bsel_shift;
   

   prgen_delay #(1) delay_wr0(.clk(clk), .reset(reset), .din(slice_wr_pre), .dout(slice_wr));
   prgen_delay #(1) delay_wr(.clk(clk), .reset(reset), .din(slice_wr), .dout(slice_wr_fifo));

   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      slice_wsize       <= #1 {3{1'b0}};
      slice_wdata_pre_d <= #1 {32{1'b0}};
       end
     else if (slice_wr_pre)
       begin
      slice_wsize       <= #1 slice_wsize_pre;
      slice_wdata_pre_d <= #1 slice_wdata_pre;
       end

   
   prgen_swap32 swap32(
               .end_swap(end_swap),
               .data_in(slice_wdata_pre_d),
               .data_out(slice_wdata_swap),
               .bsel_in(slice_bsel_pre),
               .bsel_out(slice_bsel_swap)
               );
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      slice_wdata   <= #1 {32{1'b0}};
      slice_wr_ptr  <= #1 {5{1'b0}};
      slice_bsel    <= #1 {4{1'b0}};
       end
     else if (slice_wr)
       begin
      slice_wdata   <= #1 slice_wdata_swap;
      slice_wr_ptr  <= #1 slice_wr_ptr_pre;
      slice_bsel    <= #1 slice_bsel_swap;
       end
   
endmodule



   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: dma_core_ctrl.v
//---------------------------------------------------------



module dma_axi32_core0_ctrl(clk,reset,ch_go,cmd_full,cmd_pending,joint_req,ch_num,ch_num_resp,go_next_line,periph_clr_valid,periph_clr,periph_clr_last,periph_delay,clr_stall,tokens,ch_ready,ch_last,burst_start,finish,busy,hold);


   input                    clk;
   input             reset;

   input             ch_go;

   input             cmd_full;
   input             cmd_pending;
   input             joint_req;
      
   input [2:0]             ch_num;
   input [2:0]             ch_num_resp;   
   input             go_next_line;
   input             periph_clr_valid;
   input             periph_clr;
   input             periph_clr_last;
   input [`DELAY_BITS-1:0]  periph_delay;

   input             clr_stall;
   input [`TOKEN_BITS-1:0]  tokens;
   
   input             ch_ready;
   input             ch_last;
   output             burst_start;
   output             finish;             
   output             busy;
   input             hold;
   

   reg                 burst_start;
   reg                 finish;
   wire             tokens_remain;
   reg                 tokens_remain_reg;
   reg [`TOKEN_BITS-1:0]    tokens_counter;
   wire             stall;
   reg                 joint_ctrl_reg;
   wire             joint_ctrl;
   
   reg [`DELAY_BITS-1:0]    delay_counter;
   
   wire             periph_clr_ch;
   wire             periph_clr_last_ch;   
   wire             go_next_line_d;
   
  
   
   reg [2:0]             ps;
   reg [2:0]             ns;


   
   parameter                IDLE        = 3'd0;
   parameter             CMD         = 3'd1;
   parameter             WAIT_CLR    = 3'd2;
   parameter             WAIT_DELAY  = 3'd3;
   parameter             STALL       = 3'd4;
   

   assign             busy = ps != IDLE;

   assign             periph_clr_ch      = periph_clr_valid & periph_clr & (ch_num == ch_num_resp);
   assign             periph_clr_last_ch = periph_clr_valid & periph_clr_last & (ch_num == ch_num_resp);

   assign             go_next_line_d = 1'b0;


   always @(posedge clk or posedge reset)
     if (reset)
       joint_ctrl_reg <= #1 1'b0;
     else if (finish)
       joint_ctrl_reg <= #1 1'b0;
     else if (ch_go)
       joint_ctrl_reg <= #1 joint_req;

   assign             joint_ctrl = joint_ctrl_reg;
   
   
   
   assign             tokens_remain = (|tokens_counter) | ch_last;
   
   always @(posedge clk or posedge reset)
     if (reset)
       tokens_counter <= #1 {`TOKEN_BITS{1'b0}};
     else if (ch_go)
       tokens_counter <= #1 tokens;
     else if (burst_start & (|tokens_counter))
       tokens_counter <= #1 tokens_counter - 1'b1;
   
   always @(posedge clk or posedge reset)
     if (reset)
       delay_counter <= #1 {`DELAY_BITS{1'b0}};
     else if (periph_clr_ch)
       delay_counter <= #1 periph_delay;
     else if (|delay_counter)
       delay_counter <= #1 delay_counter - 1'b1;

   
   assign             stall  = cmd_pending | cmd_full | go_next_line_d;
  
   
   always @(/*AUTOSENSE*/ch_go or ch_last or ch_ready or clr_stall
        or delay_counter or go_next_line_d or hold or joint_ctrl
        or joint_req or periph_clr_ch or periph_clr_last_ch
        or periph_clr_valid or periph_delay or ps or stall
        or tokens_remain)
     begin
    ns          = IDLE;
    burst_start = 1'b0;
    finish  = 1'b0;
    
    case (ps)
      IDLE :
        begin
           if (ch_go)
         begin
            if (!ch_ready)
              begin
             ns = IDLE;
             finish = 1'b1;
              end
            else if (stall)
              ns = STALL;
            else
              ns = CMD;
         end
           else
         ns = IDLE;
        end
      
      CMD :
        begin
           if (joint_req ^ joint_ctrl) //change in joint_req
         begin
            ns = IDLE;
            finish = 1'b1;
         end
           else if ((clr_stall | hold) & tokens_remain)
         ns = CMD;
           else if (ch_ready & tokens_remain)
         begin
                    if (stall)
                      ns = STALL;
                    else
                      begin
                         burst_start = 1'b1;
                         ns = WAIT_CLR;
                      end  
         end
           else if (ch_last & (~ch_ready))
         ns = CMD;
           else
         begin
            ns = IDLE;
            finish = 1'b1;
         end
        end 
      
      WAIT_CLR :
        begin
           if ((|periph_delay) & periph_clr_valid) //don't wait for clr if not valid (block clr)
         begin
            if (periph_clr_last_ch) //release if load cmd
              begin
             ns = IDLE;
             finish = 1'b1;
              end
            else if (periph_clr_ch)
              ns = WAIT_DELAY;
            else
              ns = WAIT_CLR;
         end
           //memory - allow command depth
           else if (!tokens_remain)
         begin
            ns = IDLE;
            finish = 1'b1;
         end
           else
         ns = WAIT_DELAY;
        end
      
      WAIT_DELAY :
        begin
           if (go_next_line_d) //delay in case of cmd split (cross page)
         ns = WAIT_DELAY;
           else if (delay_counter == 'd0)
         ns = STALL;
           else
         ns = WAIT_DELAY;
        end

      STALL :
        begin
           if (ch_ready & tokens_remain)
         begin
            if (stall)
              ns = STALL;
            else
              ns = CMD;
         end
           else if (ch_last & (~ch_ready))
         ns = CMD;
           else
         begin
            ns = IDLE;
            finish = 1'b1;
         end 
        end

      default :
        begin
           ns = IDLE;
        end
      
    endcase
     end
   
   always @(posedge clk or posedge reset)
     if (reset)
       ps <= #1 IDLE;
     else
       ps <= #1 ns;
   

endmodule





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_core_top.v
//---------------------------------------------------------



module dma_axi32_core0_top(clk,reset,scan_en,idle,ch_int_all_proc,ch_start,clkdiv,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,pready,rd_port_num,wr_port_num,joint_mode,joint_remote,rd_prio_top,rd_prio_high,rd_prio_top_num,rd_prio_high_num,wr_prio_top,wr_prio_high,wr_prio_top_num,wr_prio_high_num,AWADDR,AWLEN,AWSIZE,AWVALID,AWREADY,WDATA,WSTRB,WLAST,WVALID,WREADY,BRESP,BVALID,BREADY,ARADDR,ARLEN,ARSIZE,ARVALID,ARREADY,RDATA,RRESP,RLAST,RVALID,RREADY);

   input             clk;
   input             reset;
   input             scan_en;

   output             idle;
   output [8*1-1:0]  ch_int_all_proc;
   input [7:0]                 ch_start;
   input [3:0]             clkdiv;    
   
   input [31:1]         periph_tx_req;
   output [31:1]         periph_tx_clr;
   input [31:1]         periph_rx_req;
   output [31:1]         periph_rx_clr;
   
   input                    pclken;
   input                    psel;
   input                    penable;
   input [10:0]             paddr;
   input                    pwrite;
   input [31:0]             pwdata;
   output [31:0]            prdata;
   output                   pslverr;
   output                   pready;

   output             rd_port_num;
   output             wr_port_num;

   input             joint_mode;
   input             joint_remote;
   input              rd_prio_top;
   input              rd_prio_high;
   input [2:0]             rd_prio_top_num;
   input [2:0]             rd_prio_high_num;
   input              wr_prio_top;
   input              wr_prio_high;
   input [2:0]             wr_prio_top_num;
   input [2:0]             wr_prio_high_num;
   
   output [31:0]            AWADDR;
   output [`LEN_BITS-1:0]   AWLEN;
   output [`SIZE_BITS-1:0]                      AWSIZE;
   output                   AWVALID;
   input                    AWREADY;
   output [31:0]            WDATA;
   output [32/8-1:0]        WSTRB;
   output                   WLAST;
   output                   WVALID;
   input                    WREADY;
   input [1:0]              BRESP;
   input                    BVALID;
   output                   BREADY;
   output [31:0]            ARADDR;
   output [`LEN_BITS-1:0]   ARLEN;
   output [`SIZE_BITS-1:0]                      ARSIZE;
   output                   ARVALID;
   input                    ARREADY;
   input [31:0]             RDATA;
   input [1:0]              RRESP;
   input                    RLAST;
   input                    RVALID;
   output                   RREADY;
  
   wire [31:0]              slow_AWADDR;
   wire [`LEN_BITS-1:0]     slow_AWLEN;
   wire [`SIZE_BITS-1:0]                      slow_AWSIZE;
   wire                     slow_AWVALID;
   wire                     slow_AWREADY;
   wire [31:0]              slow_WDATA;
   wire [32/8-1:0]          slow_WSTRB;
   wire                     slow_WLAST;
   wire                     slow_WVALID;
   wire                     slow_WREADY;
   wire [1:0]               slow_BRESP;
   wire                     slow_BVALID;
   wire                     slow_BREADY;
   wire [31:0]              slow_ARADDR;
   wire [`LEN_BITS-1:0]     slow_ARLEN;
   wire [`SIZE_BITS-1:0]                      slow_ARSIZE;
   wire                     slow_ARVALID;
   wire                     slow_ARREADY;
   wire [31:0]              slow_RDATA;
   wire [1:0]               slow_RRESP;
   wire                     slow_RLAST;
   wire                     slow_RVALID;
   wire                     slow_RREADY;
   
   wire             clk_out;
   wire             clken;
   wire             bypass;
   
   
  
   assign             clk_out      = clk;
   assign             clken        = 1'b1;

   assign                   AWADDR = slow_AWADDR;
   assign                   AWLEN = slow_AWLEN;
   assign                   AWSIZE = slow_AWSIZE;
   assign                   AWVALID = slow_AWVALID;
   assign                   WDATA = slow_WDATA;
   assign                   WSTRB = slow_WSTRB;
   assign                   WLAST = slow_WLAST;
   assign                   WVALID = slow_WVALID;
   assign                   BREADY = slow_BREADY;
   assign                   ARADDR = slow_ARADDR;
   assign                   ARLEN = slow_ARLEN;
   assign                   ARSIZE = slow_ARSIZE;
   assign                   ARVALID = slow_ARVALID;
   assign                   RREADY = slow_RREADY;
   assign                   slow_AWREADY = AWREADY;
   assign                   slow_WREADY = WREADY;
   assign                   slow_BRESP = BRESP;
   assign                   slow_BVALID = BVALID;
   assign                   slow_ARREADY = ARREADY;
   assign                   slow_RDATA = RDATA;
   assign                   slow_RRESP = RRESP;
   assign                   slow_RLAST = RLAST;
   assign                   slow_RVALID = RVALID;

   dma_axi32_core0
   dma_axi32_core0 (
         .clk(clk_out),
         .reset(reset),
         .scan_en(scan_en),

         .idle(idle),
         .ch_int_all_proc(ch_int_all_proc),
         .ch_start(ch_start),
      
         .periph_tx_req(periph_tx_req),
         .periph_tx_clr(periph_tx_clr),
         .periph_rx_req(periph_rx_req),
         .periph_rx_clr(periph_rx_clr),

         .pclk(clk),
         .clken(clken),
         .pclken(pclken),
         .psel(psel),
         .penable(penable),
         .paddr(paddr[10:0]),
         .pwrite(pwrite),
         .pwdata(pwdata),
         .prdata(prdata),
         .pslverr(pslverr),

         .joint_mode_in(joint_mode),
         .joint_remote(joint_remote),
         .rd_prio_top(rd_prio_top),
         .rd_prio_high(rd_prio_high),
         .rd_prio_top_num(rd_prio_top_num),
         .rd_prio_high_num(rd_prio_high_num),
         .wr_prio_top(wr_prio_top),
         .wr_prio_high(wr_prio_high),
         .wr_prio_top_num(wr_prio_top_num),
         .wr_prio_high_num(wr_prio_high_num),
         
         .rd_port_num(rd_port_num),
         .wr_port_num(wr_port_num),

                 .AWADDR(slow_AWADDR),
                 .AWLEN(slow_AWLEN),
                 .AWSIZE(slow_AWSIZE),
                 .AWVALID(slow_AWVALID),
                 .AWREADY(slow_AWREADY),
                 .WDATA(slow_WDATA),
                 .WSTRB(slow_WSTRB),
                 .WLAST(slow_WLAST),
                 .WVALID(slow_WVALID),
                 .WREADY(slow_WREADY),
                 .BRESP(slow_BRESP),
                 .BVALID(slow_BVALID),
                 .BREADY(slow_BREADY),
                 .ARADDR(slow_ARADDR),
                 .ARLEN(slow_ARLEN),
                 .ARSIZE(slow_ARSIZE),
                 .ARVALID(slow_ARVALID),
                 .ARREADY(slow_ARREADY),
                 .RDATA(slow_RDATA),
                 .RRESP(slow_RRESP),
                 .RLAST(slow_RLAST),
                 .RVALID(slow_RVALID),
                 .RREADY(slow_RREADY)
         );

   

   
endmodule





   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_core.v
//---------------------------------------------------------



module dma_axi32_core0(clk,reset,scan_en,idle,ch_int_all_proc,ch_start,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,pclk,clken,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,rd_port_num,wr_port_num,joint_mode_in,joint_remote,rd_prio_top,rd_prio_high,rd_prio_top_num,rd_prio_high_num,wr_prio_top,wr_prio_high,wr_prio_top_num,wr_prio_high_num,AWADDR,AWLEN,AWSIZE,AWVALID,AWREADY,WDATA,WSTRB,WLAST,WVALID,WREADY,BRESP,BVALID,BREADY,ARADDR,ARLEN,ARSIZE,ARVALID,ARREADY,RDATA,RRESP,RLAST,RVALID,RREADY);
   
   input              clk;
   input                     reset;
   input                     scan_en;

   output                    idle;
   output [8*1-1:0]   ch_int_all_proc;
   input [7:0]                  ch_start;
   
   input [31:1]          periph_tx_req;
   output [31:1]          periph_tx_clr;
   input [31:1]          periph_rx_req;
   output [31:1]          periph_rx_clr;

   input              pclk;
   input              clken;
   input              pclken;
   input              psel;
   input              penable;
   input [10:0]          paddr;
   input              pwrite;
   input [31:0]          pwdata;
   output [31:0]          prdata;
   output              pslverr;

   output              rd_port_num;
   output              wr_port_num;

   input              joint_mode_in;
   input              joint_remote;
   input               rd_prio_top;
   input               rd_prio_high;
   input [2:0]              rd_prio_top_num;
   input [2:0]              rd_prio_high_num;
   input               wr_prio_top;
   input               wr_prio_high;
   input [2:0]              wr_prio_top_num;
   input [2:0]              wr_prio_high_num;
   
   output [31:0]             AWADDR;
   output [`LEN_BITS-1:0]    AWLEN;
   output [`SIZE_BITS-1:0]                       AWSIZE;
   output                    AWVALID;
   input                     AWREADY;
   output [31:0]             WDATA;
   output [32/8-1:0]         WSTRB;
   output                    WLAST;
   output                    WVALID;
   input                     WREADY;
   input [1:0]               BRESP;
   input                     BVALID;
   output                    BREADY;
   output [31:0]             ARADDR;
   output [`LEN_BITS-1:0]    ARLEN;
   output [`SIZE_BITS-1:0]                       ARSIZE;
   output                    ARVALID;
   input                     ARREADY;
   input [31:0]              RDATA;
   input [1:0]               RRESP;
   input                     RLAST;
   input                     RVALID;
   output                    RREADY;
   

   //outputs of wdt
   wire              wdt_timeout;
   wire [2:0]              wdt_ch_num;
   
   //outputs of rd arbiter
   wire              rd_ch_go_joint;
   wire              rd_ch_go_null;
   wire              rd_ch_go;
   wire [2:0]              rd_ch_num;
   wire              rd_ch_last;
   
   //outputs of wr arbiter
   wire              wr_ch_go_joint;
   wire              wr_ch_go;
   wire [2:0]              wr_ch_num_joint;
   wire [2:0]              wr_ch_num;
   wire              wr_ch_last;
   wire              wr_ch_last_joint;
   
   //outputs of channels
   wire [31:0]              prdata;
   wire              pslverr;
   wire              load_req_in_prog;
   wire [7:0]              ch_idle;
   wire [7:0]              ch_active;
   wire [7:0]              ch_active_joint;
   wire [7:0]              ch_rd_active;
   wire [7:0]              ch_wr_active;
   wire              wr_last_cmd;
   wire              rd_line_cmd;
   wire              wr_line_cmd;
   wire              rd_go_next_line;
   wire              wr_go_next_line;
   
   wire [7:0]              ch_rd_ready_joint;
   wire [7:0]              ch_rd_ready;
   wire              rd_ready;
   wire              rd_ready_joint;
   wire [32-1:0]      rd_burst_addr;
   wire [7-1:0]     rd_burst_size;
   wire [`TOKEN_BITS-1:0]    rd_tokens;
   wire              rd_port_num;
   wire [`DELAY_BITS-1:0]    rd_periph_delay;
   wire              rd_clr_valid;  
   wire [2:0]              rd_transfer_num;  
   wire              rd_transfer;
   wire [3-1:0]      rd_transfer_size;  
   wire              rd_clr_stall;
   
   wire [7:0]              ch_wr_ready;
   wire              wr_ready;
   wire              wr_ready_joint;
   wire [32-1:0]      wr_burst_addr;
   wire [7-1:0]     wr_burst_size;
   wire [`TOKEN_BITS-1:0]    wr_tokens;
   wire              wr_port_num;
   wire [`DELAY_BITS-1:0]    wr_periph_delay;
   wire              wr_clr_valid;    
   wire              wr_clr_stall;
   wire [7:0]              ch_joint_req;
   wire              joint_req;
   wire              joint_mode;
   
   wire              joint_ch_go;
   wire              joint_stall;
   
   //outputs of rd ctrl
   wire              rd_burst_start;
   wire              rd_finish_joint;
   wire              rd_finish;
   wire              rd_ctrl_busy;

   //outputs of wr ctrl
   wire              wr_burst_start_joint;
   wire              wr_burst_start;
   wire              wr_finish;
   wire              wr_ctrl_busy;

   
   //outputs of axim wr
   wire              wr_cmd_split;
   wire [2:0]              wr_cmd_num;
   wire              wr_cmd_pending_joint;
   wire              wr_cmd_pending;
   wire              wr_cmd_full_joint;
   wire              ch_fifo_rd;
   wire [3-1:0]      ch_fifo_rsize;
   wire [2:0]              ch_fifo_rd_num;
   wire [2:0]              wr_transfer_num;
   wire              wr_transfer; 
   wire [3-1:0]      wr_transfer_size;
   wire [3-1:0]      wr_next_size;
   wire              wr_clr_line;
   wire [2:0]              wr_clr_line_num;
   wire              wr_cmd_full;
   wire              wr_slverr;
   wire              wr_decerr;
   wire              wr_clr;
   wire              wr_clr_last;
   wire [2:0]              wr_ch_num_resp;
   wire              timeout_aw;
   wire              timeout_w;
   wire [2:0]              timeout_num_aw;
   wire [2:0]              timeout_num_w;
   wire              wr_hold_ctrl;
   wire              wr_hold;
   wire              joint_in_prog;
   wire              joint_not_in_prog;
   wire              joint_mux_in_prog;
   wire              wr_page_cross;
   
   //outputs of axim rd   
   wire              load_wr;
   wire [2:0]              load_wr_num;
   wire [1:0]              load_wr_cycle;
   wire [32-1:0]      load_wdata;  
   wire              rd_cmd_split; 
   wire              rd_cmd_line;
   wire [2:0]              rd_cmd_num;
   wire              rd_cmd_pending_joint;
   wire              rd_cmd_pending;
   wire              rd_cmd_full_joint;
   wire              ch_fifo_wr;
   wire [32-1:0]      ch_fifo_wdata;
   wire [3-1:0]      ch_fifo_wsize;
   wire [2:0]              ch_fifo_wr_num;
   wire              rd_clr_line;
   wire [2:0]              rd_clr_line_num;
   wire              rd_burst_cmd;
   wire              rd_cmd_full;
   wire              rd_slverr;
   wire              rd_decerr;
   wire              rd_clr;
   wire              rd_clr_last;
   wire              rd_clr_load;
   wire [2:0]              rd_ch_num_resp;
   wire              timeout_ar;
   wire [2:0]              timeout_num_ar;
   wire              rd_hold_joint;
   wire              rd_hold_ctrl;
   wire              rd_hold;
   wire              joint_hold;
   wire              rd_page_cross;

   wire              joint_page_cross;
   wire              rd_arbiter_en;
   wire              wr_arbiter_en;

   wire              rd_cmd_port;
   wire              wr_cmd_port;
   
   //outputs of fifo ctrl
   wire [32-1:0]      ch_fifo_rdata;
   wire              ch_fifo_rd_valid;
   wire              ch_fifo_wr_ready;
   wire              FIFO_WR;
   wire              FIFO_RD;
   wire [3+5-3-1:0]  FIFO_WR_ADDR;
   wire [3+5-3-1:0]  FIFO_RD_ADDR;
   wire [32-1:0]      FIFO_DIN;
   wire [4-1:0]      FIFO_BSEL;

   //outputs of fifo wrap
   wire [32-1:0]      FIFO_DOUT;

   wire              clk_en;
   wire              gclk;


   assign              joint_mode = joint_mode_in & 1'b1;
   
   
   assign              rd_arbiter_en        = 1'b1;
   assign              wr_arbiter_en        = !joint_mode;

   assign              rd_ready             = ch_rd_ready[rd_ch_num];
   assign              wr_ready             = ch_wr_ready[wr_ch_num_joint];
   assign              rd_ready_joint       = joint_mode & joint_req ? rd_ready & wr_ready : rd_ready;
   assign              wr_ready_joint       = joint_mode & joint_req ? rd_ready & wr_ready : wr_ready;
   assign              ch_active_joint      = joint_mode ? ch_rd_active | ch_wr_active : ch_rd_active;
   
   assign              joint_page_cross     = (rd_page_cross & rd_ready) | (wr_page_cross & wr_ready);
   
   assign              joint_req            = ch_joint_req[rd_ch_num];
   
   assign              ch_rd_ready_joint    = joint_mode ?
                 (ch_joint_req & ch_rd_ready & ch_wr_ready) | 
                   ((~ch_joint_req) & (ch_rd_ready | ch_wr_ready)) :
                 ch_rd_ready;

   assign              wr_burst_start_joint = joint_mode & joint_req ? rd_burst_start : wr_burst_start;
   
   assign              joint_hold           = joint_mux_in_prog | (joint_in_prog & (~joint_req)) | (joint_not_in_prog & joint_req) | joint_stall | (joint_req & joint_page_cross);
   
   assign              rd_hold_ctrl         = joint_mode ? rd_hold | joint_hold | (joint_in_prog & wr_hold) : rd_hold;
   assign              rd_hold_joint        = joint_mode & (rd_hold_ctrl | rd_ctrl_busy | wr_ctrl_busy);
   assign              wr_hold_ctrl         = joint_mode & (joint_req | joint_in_prog) ? wr_hold | joint_hold : wr_hold;

   assign              rd_ch_go_joint       = rd_ch_go & ch_rd_ready[rd_ch_num] & (~rd_ctrl_busy);
   assign              wr_ch_go_joint       = joint_mode ? (wr_ready & (~wr_ctrl_busy) & 
                                  (joint_req ? rd_ch_go_joint : rd_ch_go & (~rd_ch_go_joint))) : wr_ch_go;
   assign              rd_ch_go_null        = rd_ch_go & (~rd_ch_go_joint) & (joint_mode ? (~wr_ch_go_joint) : 1'b1);

   assign              wr_ch_num_joint      = joint_mode ? rd_ch_num : wr_ch_num;

   assign              wr_ch_last_joint     = joint_mode ? rd_ch_last : wr_ch_last;
   
   assign              rd_finish_joint      = joint_mode ? rd_finish | wr_finish | rd_ch_go_null : rd_finish | rd_ch_go_null;
   
   assign              rd_cmd_full_joint    = joint_mode & joint_req ? wr_cmd_full | rd_cmd_full : rd_cmd_full;
   assign              wr_cmd_full_joint    = joint_mode & joint_req ? wr_cmd_full | rd_cmd_full : wr_cmd_full;
   assign              rd_cmd_pending_joint = joint_mode ? rd_cmd_pending | wr_cmd_pending : rd_cmd_pending;
   assign              wr_cmd_pending_joint = joint_mode & joint_req ? rd_cmd_pending | wr_cmd_pending : wr_cmd_pending;
   
   assign              idle                 = &ch_idle;
   
   assign             gclk = clk;


   dma_axi32_core0_wdt  dma_axi32_core0_wdt (
                           .clk(gclk),
                           .reset(reset),
                           .ch_active(ch_active),
                           .rd_burst_start(rd_burst_start),
                           .rd_ch_num(rd_ch_num),
                           .wr_burst_start(wr_burst_start_joint),
                           .wr_ch_num(wr_ch_num_joint),
                           .wdt_timeout(wdt_timeout),
                           .wdt_ch_num(wdt_ch_num)
                           );
   
   
   dma_axi32_core0_arbiter
   dma_axi32_core0_arbiter_rd (
                .clk(gclk),
                .reset(reset),
                .enable(rd_arbiter_en),
                .joint_mode(joint_mode),
                .page_cross(joint_page_cross),
                .joint_req(joint_req),
                .prio_top(rd_prio_top),
                .prio_high(rd_prio_high),
                .prio_top_num(rd_prio_top_num),
                .prio_high_num(rd_prio_high_num),
                .hold(rd_hold_joint),
                .ch_ready(ch_rd_ready_joint),
                .ch_active(ch_active_joint),
                .finish(rd_finish_joint),
                .ch_go_out(rd_ch_go),
                .ch_num(rd_ch_num),
                .ch_last(rd_ch_last)
                );
   
   
   dma_axi32_core0_arbiter
   dma_axi32_core0_arbiter_wr (
                .clk(gclk),
                .reset(reset),
                .enable(wr_arbiter_en),
                .joint_mode(joint_mode),
                .page_cross(1'b0),
                .joint_req(joint_req),
                .prio_top(wr_prio_top),
                .prio_high(wr_prio_high),
                .prio_top_num(wr_prio_top_num),
                .prio_high_num(wr_prio_high_num),
                .hold(1'b0),
                .ch_ready(ch_wr_ready),
                .ch_active(ch_wr_active),
                .finish(wr_finish),
                .ch_go_out(wr_ch_go),
                .ch_num(wr_ch_num),
                .ch_last(wr_ch_last)
                );
   
   
   dma_axi32_core0_ctrl  dma_axi32_core0_ctrl_rd (
                        .clk(gclk),
                        .reset(reset),
                        .ch_go(rd_ch_go_joint),
                        .cmd_full(rd_cmd_full_joint),
                        .cmd_pending(rd_cmd_pending_joint),
                        .joint_req(joint_req),
                        .ch_num(rd_ch_num),
                        .ch_num_resp(rd_ch_num_resp),
                        .go_next_line(rd_go_next_line),
                        .periph_clr_valid(rd_clr_valid),
                        .periph_clr(rd_clr),
                        .periph_clr_last(rd_clr_last),
                        .periph_delay(rd_periph_delay),
                        .clr_stall(rd_clr_stall),
                        .tokens(rd_tokens),
                        .ch_ready(rd_ready_joint),
                        .ch_last(rd_ch_last),
                        .burst_start(rd_burst_start),
                        .finish(rd_finish),
                        .busy(rd_ctrl_busy),
                        .hold(rd_hold_ctrl)
                        );

   
   dma_axi32_core0_ctrl  dma_axi32_core0_ctrl_wr (
                        .clk(gclk),
                        .reset(reset),
                        .ch_go(wr_ch_go_joint),
                        .cmd_full(wr_cmd_full_joint),
                        .cmd_pending(wr_cmd_pending_joint),
                        .joint_req(joint_req),
                        .ch_num(wr_ch_num_joint),
                        .ch_num_resp(wr_ch_num_resp),
                        .go_next_line(wr_go_next_line),
                        .periph_clr_valid(wr_clr_valid),
                        .periph_clr(wr_clr),
                        .periph_clr_last(wr_clr_last),
                        .periph_delay(wr_periph_delay),
                        .clr_stall(wr_clr_stall),
                        .tokens(wr_tokens),
                        .ch_ready(wr_ready_joint),
                        .ch_last(wr_ch_last_joint),
                        .burst_start(wr_burst_start),
                        .finish(wr_finish),
                        .busy(wr_ctrl_busy),
                        .hold(wr_hold_ctrl)
                        );


   dma_axi32_core0_axim_wr
   dma_axi32_core0_axim_wr (
             .clk(gclk),
             .reset(reset),        
             .wr_ch_num(wr_ch_num_joint),
             .wr_burst_start(wr_burst_start_joint),
             .wr_burst_addr(wr_burst_addr),
             .wr_burst_size(wr_burst_size),
             .wr_cmd_split(wr_cmd_split),
             .wr_cmd_num(wr_cmd_num),
             .wr_cmd_pending(wr_cmd_pending),
             .joint_req(joint_req),
             .joint_stall(joint_stall),
             .rd_transfer(rd_transfer),
             .rd_transfer_size(rd_transfer_size),
             .ch_fifo_rd(ch_fifo_rd),
             .ch_fifo_rdata(ch_fifo_rdata),
             .ch_fifo_rd_valid(ch_fifo_rd_valid),
             .ch_fifo_rsize(ch_fifo_rsize),
             .ch_fifo_rd_num(ch_fifo_rd_num),
             .ch_fifo_wr_ready(ch_fifo_wr_ready),
             .wr_cmd_port(wr_cmd_port),
             .wr_last_cmd(wr_last_cmd),
             .wr_line_cmd(wr_line_cmd),
             .wr_transfer_num(wr_transfer_num),
             .wr_transfer(wr_transfer),
             .wr_transfer_size(wr_transfer_size),
             .wr_next_size(wr_next_size),
             .wr_clr_line(wr_clr_line),
             .wr_clr_line_num(wr_clr_line_num),
             .wr_cmd_full(wr_cmd_full),
             .wr_slverr(wr_slverr),
             .wr_decerr(wr_decerr),
             .wr_clr(wr_clr),
             .wr_clr_last(wr_clr_last),
             .wr_ch_num_resp(wr_ch_num_resp),
                .page_cross(wr_page_cross),
             .AWADDR(AWADDR),
             .AWPORT(wr_port_num),
             .AWLEN(AWLEN),
             .AWSIZE(AWSIZE),
             .AWVALID(AWVALID),
             .AWREADY(AWREADY),
             .WDATA(WDATA),
             .WSTRB(WSTRB),
             .WLAST(WLAST),
             .WVALID(WVALID),
             .WREADY(WREADY),
             .BRESP(BRESP),
             .BVALID(BVALID),
             .BREADY(BREADY),
             .axim_timeout_aw(timeout_aw),
             .axim_timeout_w(timeout_w),
             .axim_timeout_num_aw(timeout_num_aw),
             .axim_timeout_num_w(timeout_num_w)
             );

   
   dma_axi32_core0_axim_rd
   dma_axi32_core0_axim_rd (
             .clk(gclk),
             .reset(reset),
             .load_wr(load_wr),
             .load_wr_num(load_wr_num),
             .load_wr_cycle(load_wr_cycle),
             .load_wdata(load_wdata),
             .load_req_in_prog(load_req_in_prog),
             .joint_stall(joint_stall),
             .joint_req(joint_req),
             .rd_cmd_port(rd_cmd_port),
             .rd_ch_num(rd_ch_num),
             .rd_burst_start(rd_burst_start),
             .rd_burst_addr(rd_burst_addr),
             .rd_burst_size(rd_burst_size),
             .rd_cmd_split(rd_cmd_split),
             .rd_cmd_line(rd_cmd_line),
             .rd_cmd_num(rd_cmd_num),
             .rd_cmd_pending(rd_cmd_pending),
             .ch_fifo_wr(ch_fifo_wr),
             .ch_fifo_wdata(ch_fifo_wdata),
             .ch_fifo_wsize(ch_fifo_wsize),
             .ch_fifo_wr_num(ch_fifo_wr_num),
             .rd_clr_line(rd_clr_line),
             .rd_clr_line_num(rd_clr_line_num),
             .rd_line_cmd(rd_line_cmd),
             .rd_transfer(rd_transfer),
             .rd_transfer_size(rd_transfer_size),
             .rd_transfer_num(rd_transfer_num),
             .rd_burst_cmd(rd_burst_cmd),
             .rd_cmd_full(rd_cmd_full),
             .rd_slverr(rd_slverr),
             .rd_decerr(rd_decerr),
             .rd_clr(rd_clr),
             .rd_clr_load(rd_clr_load),
             .rd_clr_last(rd_clr_last),
             .rd_ch_num_resp(rd_ch_num_resp),
                .page_cross(rd_page_cross),
             .ARADDR(ARADDR),
             .ARPORT(rd_port_num),
             .ARLEN(ARLEN),
             .ARSIZE(ARSIZE),
             .ARVALID(ARVALID),
             .ARREADY(ARREADY),
             .AWVALID(AWVALID),
             .RDATA(RDATA),
             .RRESP(RRESP),
             .RLAST(RLAST),
             .RVALID(RVALID),
             .RREADY_out(RREADY),
             .axim_timeout_ar(timeout_ar),
             .axim_timeout_num_ar(timeout_num_ar)
             );

   assign             rd_hold     = 1'b0;
   assign             wr_hold     = 1'b0;
   


   
   dma_axi32_core0_channels
   dma_axi32_core0_channels (
              .clk(clk), //non gated
              .reset(reset),
              .scan_en(scan_en),
              .pclk(pclk),
              .clken(clken),
              .pclken(pclken),
              .psel(psel),
              .penable(penable),
              .paddr(paddr[10:0]),
              .pwrite(pwrite),
              .pwdata(pwdata),
              .prdata(prdata),
              .pslverr(pslverr),
              .periph_tx_req(periph_tx_req),
              .periph_tx_clr(periph_tx_clr),
              .periph_rx_req(periph_rx_req),
              .periph_rx_clr(periph_rx_clr),
              .rd_cmd_split(rd_cmd_split),
              .rd_cmd_line(rd_cmd_line),
              .rd_cmd_num(rd_cmd_num),
              .wr_cmd_split(wr_cmd_split),
              .wr_cmd_pending(wr_cmd_pending),
              .wr_cmd_num(wr_cmd_num),
              .rd_clr_valid(rd_clr_valid),
              .wr_clr_valid(wr_clr_valid),
              .rd_clr(rd_clr),
              .rd_clr_load(rd_clr_load),
              .wr_clr(wr_clr),
                  .rd_clr_stall(rd_clr_stall),
                  .wr_clr_stall(wr_clr_stall),
              .load_wr(load_wr),
              .load_wr_num(load_wr_num),
              .load_wr_cycle(load_wr_cycle),
              .rd_ch_num(rd_ch_num),
              .load_req_in_prog(load_req_in_prog),
              .wr_ch_num(wr_ch_num_joint),
              .wr_last_cmd(wr_last_cmd),
              .load_wdata(load_wdata),
              .wr_slverr(wr_slverr),
              .wr_decerr(wr_decerr),
              .wr_ch_num_resp(wr_ch_num_resp),
              .rd_slverr(rd_slverr),
              .rd_decerr(rd_decerr),
              .rd_ch_num_resp(rd_ch_num_resp),
              .wr_clr_last(wr_clr_last),
              .ch_int_all_proc(ch_int_all_proc),
              .ch_start(ch_start),
              .ch_idle(ch_idle),
              .ch_active(ch_active),
              .ch_rd_active(ch_rd_active),
              .ch_wr_active(ch_wr_active),
              .rd_line_cmd(rd_line_cmd),
              .wr_line_cmd(wr_line_cmd),
              .rd_go_next_line(rd_go_next_line),
              .wr_go_next_line(wr_go_next_line),
      
              .timeout_aw(timeout_aw),
              .timeout_w(timeout_w),
              .timeout_ar(timeout_ar),
              .timeout_num_aw(timeout_num_aw),
              .timeout_num_w(timeout_num_w),
              .timeout_num_ar(timeout_num_ar),
              .wdt_timeout(wdt_timeout),
              .wdt_ch_num(wdt_ch_num),
              
              .ch_fifo_wr_num(ch_fifo_wr_num),
              .rd_transfer_num(rd_transfer_num),
              .rd_burst_start(rd_burst_start),
              .ch_rd_ready(ch_rd_ready),
              .rd_burst_addr(rd_burst_addr),
              .rd_burst_size(rd_burst_size),
              .rd_tokens(rd_tokens),
              .rd_cmd_port(rd_cmd_port),
              .rd_periph_delay(rd_periph_delay),
              .rd_transfer(rd_transfer),
              .rd_transfer_size(rd_transfer_size),
              .rd_clr_line(rd_clr_line),
              .rd_clr_line_num(rd_clr_line_num),
              .fifo_rd(ch_fifo_rd),
              .fifo_rsize(ch_fifo_rsize),
              .fifo_rd_valid(ch_fifo_rd_valid),
              .fifo_rdata(ch_fifo_rdata),
              .fifo_wr_ready(ch_fifo_wr_ready),
      
              .ch_fifo_rd_num(ch_fifo_rd_num),
              .wr_burst_start(wr_burst_start_joint),
              .ch_wr_ready(ch_wr_ready),
              .wr_burst_addr(wr_burst_addr),
              .wr_burst_size(wr_burst_size),
              .wr_tokens(wr_tokens),
              .wr_cmd_port(wr_cmd_port),
              .wr_periph_delay(wr_periph_delay),
              .wr_transfer_num(wr_transfer_num),
              .wr_transfer(wr_transfer),
              .wr_transfer_size(wr_transfer_size),
              .wr_next_size(wr_next_size),
              .wr_clr_line(wr_clr_line),
              .wr_clr_line_num(wr_clr_line_num),
              .fifo_wr(ch_fifo_wr),
              .fifo_wdata(ch_fifo_wdata),
              .fifo_wsize(ch_fifo_wsize),

              .joint_mode(joint_mode),
              .joint_remote(joint_remote),
              .rd_page_cross(rd_page_cross),
              .wr_page_cross(wr_page_cross),
              .joint_in_prog(joint_in_prog),
              .joint_not_in_prog(joint_not_in_prog),
              .joint_mux_in_prog(joint_mux_in_prog),
              .ch_joint_req(ch_joint_req)
              );
   
   
   
endmodule




/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_core_wdt.v
//---------------------------------------------------------


  
module dma_axi32_core0_wdt(clk,reset,ch_active,rd_burst_start,rd_ch_num,wr_burst_start,wr_ch_num,wdt_timeout,wdt_ch_num);
   
   
   input               clk;
   input               reset;

   input [7:0]               ch_active;
   input               rd_burst_start;
   input [2:0]               rd_ch_num;
   input               wr_burst_start;
   input [2:0]               wr_ch_num;
   
   output               wdt_timeout;
   output [2:0]           wdt_ch_num;



   reg [`WDT_BITS-1:0]           counter;
   reg [2:0]               wdt_ch_num;
   wire               current_ch_active;
   wire               current_burst_start;
   wire               advance;
   wire               idle;



   assign               idle = ch_active == 8'd0;
   
   assign               current_ch_active = ch_active[wdt_ch_num];

   assign               current_burst_start =
                  (rd_burst_start & (rd_ch_num == wdt_ch_num)) |
                (wr_burst_start & (wr_ch_num == wdt_ch_num));

   assign               advance = (!current_ch_active) | current_burst_start | wdt_timeout;
   

   always @(posedge clk or posedge reset)
     if (reset)
       wdt_ch_num <= #1 3'd0;
     else if (advance)
       wdt_ch_num <= #1 wdt_ch_num + 1'b1;

   

   
   assign               wdt_timeout = (counter == 'd0);

   
   always @(posedge clk or posedge reset)
     if (reset)
       counter <= #1 {`WDT_BITS{1'b1}};
     else if (advance | idle)
       counter <= #1 {`WDT_BITS{1'b1}};
     else
       counter <= #1 counter - 1'b1;

   
endmodule


   
              


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_dual_core.v
//---------------------------------------------------------



module dma_axi32_dual_core(clk,reset,scan_en,idle,INT,periph_tx_req,periph_tx_clr,periph_rx_req,periph_rx_clr,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,pready,rd_port_num0,wr_port_num0,rd_port_num1,wr_port_num1,M0_AWID,M0_AWADDR,M0_AWLEN,M0_AWSIZE,M0_AWVALID,M0_AWREADY,M0_WID,M0_WDATA,M0_WSTRB,M0_WLAST,M0_WVALID,M0_WREADY,M0_BID,M0_BRESP,M0_BVALID,M0_BREADY,M0_ARID,M0_ARADDR,M0_ARLEN,M0_ARSIZE,M0_ARVALID,M0_ARREADY,M0_RID,M0_RDATA,M0_RRESP,M0_RLAST,M0_RVALID,M0_RREADY);
      
   input                   clk;
   input                   reset;
   input                   scan_en;

   output                   idle;
   output [1-1:0]                  INT;
   
   input [31:1]               periph_tx_req;
   output [31:1]               periph_tx_clr;
   input [31:1]               periph_rx_req;
   output [31:1]               periph_rx_clr;
   
   input                                  pclken;
   input                                  psel;
   input                                  penable;
   input [12:0]                           paddr;
   input                                  pwrite;
   input [31:0]                           pwdata;
   output [31:0]                          prdata;
   output                                 pslverr;
   output                                 pready;

   output                   rd_port_num0;
   output                   wr_port_num0;
   output                   rd_port_num1;
   output                   wr_port_num1;
   
   output [`ID_BITS-1:0]                  M0_AWID;
   output [32-1:0]           M0_AWADDR;
   output [`LEN_BITS-1:0]                 M0_AWLEN;
   output [`SIZE_BITS-1:0]         M0_AWSIZE;
   output                                 M0_AWVALID;
   input                                  M0_AWREADY;
   output [`ID_BITS-1:0]                  M0_WID;
   output [32-1:0]           M0_WDATA;
   output [32/8-1:0]         M0_WSTRB;
   output                                 M0_WLAST;
   output                                 M0_WVALID;
   input                                  M0_WREADY;
   input [`ID_BITS-1:0]                   M0_BID;
   input [1:0]                            M0_BRESP;
   input                                  M0_BVALID;
   output                                 M0_BREADY;
   output [`ID_BITS-1:0]                  M0_ARID;
   output [32-1:0]           M0_ARADDR;
   output [`LEN_BITS-1:0]                 M0_ARLEN;
   output [`SIZE_BITS-1:0]         M0_ARSIZE;
   output                                 M0_ARVALID;
   input                                  M0_ARREADY;
   input [`ID_BITS-1:0]                   M0_RID;
   input [32-1:0]            M0_RDATA;
   input [1:0]                            M0_RRESP;
   input                                  M0_RLAST;
   input                                  M0_RVALID;
   output                                 M0_RREADY;
   
   

   wire                   psel0;
   wire [31:0]                   prdata0;
   wire                   pslverr0;
   
   wire                   psel1;
   wire [31:0]                   prdata1;
   wire                   pslverr1;

   wire                   psel_reg;
   wire [31:0]                   prdata_reg;
   wire                   pslverr_reg;

   wire [8*1-1:0]                  ch_int_all_proc0;
   
   //outputs of dma_axi32 reg
   wire [1-1:0]                    int_all_proc;
   wire [3:0]                   core0_clkdiv;
   wire [7:0]                   core0_ch_start;
   wire                   joint_mode0;
   wire                   joint_remote0;
   wire                    rd_prio_top0;
   wire                    rd_prio_high0;
   wire [2:0]                   rd_prio_top_num0;
   wire [2:0]                   rd_prio_high_num0;
   wire                    wr_prio_top0;
   wire                    wr_prio_high0;
   wire [2:0]                   wr_prio_top_num0;
   wire [2:0]                   wr_prio_high_num0;
   wire [31:1]                   periph_rx_req_reg;
   wire [31:1]                   periph_tx_req_reg;
   
   wire [31:1]                   periph_rx_req0;
   wire [31:1]                   periph_tx_req0;
   wire [31:1]                   periph_rx_req1;
   wire [31:1]                   periph_tx_req1;
   wire [31:1]                   periph_rx_clr0;
   wire [31:1]                   periph_tx_clr0;
   wire [31:1]                   periph_rx_clr1;
   wire [31:1]                   periph_tx_clr1;

   wire                   core0_idle;



   assign                   idle = core0_idle;
   
   assign                   INT = int_all_proc;
   

   assign                   periph_rx_req0     = periph_rx_req | periph_rx_req_reg;
   assign                   periph_tx_req0     = periph_tx_req | periph_tx_req_reg;
   assign                   periph_rx_req1     = periph_rx_req0;
   assign                   periph_tx_req1     = periph_tx_req0;
   
   assign                   periph_rx_clr      = periph_rx_clr0 | periph_rx_clr1;
   assign                   periph_tx_clr      = periph_tx_clr0 | periph_tx_clr1;
   

   assign                   joint_remote0 = joint_mode0 & 0 & 0;
   
   
   dma_axi32_apb_mux  dma_axi32_apb_mux (
                   .clk(clk),
                   .reset(reset),
                   .pclken(pclken),
                   .psel(psel),
                   .penable(penable),
                   .pwrite(pwrite),
                   .paddr(paddr[12:11]),
                   .prdata(prdata),
                   .pslverr(pslverr),
                   .pready(pready),
                   .psel0(psel0),
                   .prdata0(prdata0),
                   .pslverr0(pslverr0),
                   .psel1(psel1),
                   .prdata1(prdata1),
                   .pslverr1(pslverr1),
                   .psel_reg(psel_reg),
                   .prdata_reg(prdata_reg),
                   .pslverr_reg(pslverr_reg)
                   );

   
   dma_axi32_reg  dma_axi32_reg (
               .clk(clk),
               .reset(reset),
               .pclken(pclken),
               .psel(psel_reg),
               .penable(penable),
               .paddr(paddr[7:0]),
               .pwrite(pwrite),
               .pwdata(pwdata),
               .prdata(prdata_reg),
               .pslverr(pslverr_reg),
               .core0_idle(core0_idle),
               .ch_int_all_proc0(ch_int_all_proc0),
               .int_all_proc(int_all_proc),
               .core0_clkdiv(core0_clkdiv),
               .core0_ch_start(core0_ch_start),
               .joint_mode0(joint_mode0),
               .rd_prio_top0(rd_prio_top0),
               .rd_prio_high0(rd_prio_high0),
               .rd_prio_top_num0(rd_prio_top_num0),
               .rd_prio_high_num0(rd_prio_high_num0),
               .wr_prio_top0(wr_prio_top0),
               .wr_prio_high0(wr_prio_high0),
               .wr_prio_top_num0(wr_prio_top_num0),
               .wr_prio_high_num0(wr_prio_high_num0),
               .periph_rx_req_reg(periph_rx_req_reg),
               .periph_tx_req_reg(periph_tx_req_reg),
               .periph_rx_clr(periph_rx_clr),
               .periph_tx_clr(periph_tx_clr)
               );
   
   

   dma_axi32_core0_top
   dma_axi32_core0_top (
      
             .clk(clk),
             .reset(reset),
             .scan_en(scan_en),
             
             .idle(core0_idle),
             .ch_int_all_proc(ch_int_all_proc0),
             .ch_start(core0_ch_start),
             .clkdiv(core0_clkdiv),
      
             .periph_tx_req(periph_tx_req0),
             .periph_tx_clr(periph_tx_clr0),
             .periph_rx_req(periph_rx_req0),
             .periph_rx_clr(periph_rx_clr0),
      
             .pclken(pclken),
             .psel(psel0),
             .penable(penable),
             .paddr(paddr[10:0]),
             .pwrite(pwrite),
             .pwdata(pwdata),
             .prdata(prdata0),
             .pslverr(pslverr0),
      
             .rd_port_num(rd_port_num0),
             .wr_port_num(wr_port_num0),

             .joint_mode(joint_mode0),
             .joint_remote(joint_remote0),
             .rd_prio_top(rd_prio_top0),
             .rd_prio_high(rd_prio_high0),
             .rd_prio_top_num(rd_prio_top_num0),
             .rd_prio_high_num(rd_prio_high_num0),
             .wr_prio_top(wr_prio_top0),
             .wr_prio_high(wr_prio_high0),
             .wr_prio_top_num(wr_prio_top_num0),
             .wr_prio_high_num(wr_prio_high_num0),
             
                     .AWADDR(M0_AWADDR),
                     .AWLEN(M0_AWLEN),
                     .AWSIZE(M0_AWSIZE),
                     .AWVALID(M0_AWVALID),
                     .AWREADY(M0_AWREADY),
                     .WDATA(M0_WDATA),
                     .WSTRB(M0_WSTRB),
                     .WLAST(M0_WLAST),
                     .WVALID(M0_WVALID),
                     .WREADY(M0_WREADY),
                     .BRESP(M0_BRESP),
                     .BVALID(M0_BVALID),
                     .BREADY(M0_BREADY),
                     .ARADDR(M0_ARADDR),
                     .ARLEN(M0_ARLEN),
                     .ARSIZE(M0_ARSIZE),
                     .ARVALID(M0_ARVALID),
                     .ARREADY(M0_ARREADY),
                     .RDATA(M0_RDATA),
                     .RRESP(M0_RRESP),
                     .RLAST(M0_RLAST),
                     .RVALID(M0_RVALID),
                     .RREADY(M0_RREADY)
             );

   
   
 
   prgen_delay #(1) delay_pslverr1 (.clk(clk), .reset(reset), .din(psel1), .dout(pslverr1)); //return error
   assign                   prdata1          = {32{1'b0}};
   
   assign                   periph_rx_clr1   = {31{1'b0}};
   assign                   periph_tx_clr1   = {31{1'b0}};

   assign                   rd_port_num1     = 1'b0;
   assign                   wr_port_num1     = 1'b0;


endmodule




/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_reg_core.v
//---------------------------------------------------------



module dma_axi32_reg_core0(clk,reset,wr_joint,wr_clkdiv,wr_start,wr_prio,pwdata,clkdiv,ch_start,joint_mode,rd_prio_top,rd_prio_high,rd_prio_top_num,rd_prio_high_num,wr_prio_top,wr_prio_high,wr_prio_top_num,wr_prio_high_num,user_def_stat0,user_def_stat1,ch_int_all_proc,proc0_int_stat);

   input                       clk;
   input                   reset;

   input                              wr_joint;
   input                              wr_clkdiv;
   input                              wr_start;
   input                              wr_prio;

   input [31:0]                       pwdata;
      
   output [3:0]               clkdiv;
   output [7:0]               ch_start;
   output                   joint_mode;
   output                   rd_prio_top;
   output                   rd_prio_high;
   output [2:0]               rd_prio_top_num;
   output [2:0]               rd_prio_high_num;
   output                   wr_prio_top;
   output                   wr_prio_high;
   output [2:0]               wr_prio_top_num;
   output [2:0]               wr_prio_high_num;

   output [31:0]                      user_def_stat0;
   output [31:0]                      user_def_stat1;
   
   input [8*1-1:0]             ch_int_all_proc;
   output [7:0]                       proc0_int_stat;
   
   

   
   wire                   user_def_clkdiv;
   wire                   user_def_bus_32;
   wire [3:0]                   user_def_ch_num;
   wire [3:0]                   user_def_fifo_size;
   wire [3:0]                   user_def_wcmd_depth;
   wire [3:0]                   user_def_rcmd_depth;
   wire                   user_def_block;
   wire                   user_def_wait;
   wire                   user_def_outs;
   wire                   user_def_prio;
   wire                   user_def_tokens;
   wire                   user_def_timeout;
   wire                   user_def_wdt;
   wire                   user_def_joint;
   wire                   user_def_simul;
   wire                   user_def_periph;
   wire                   user_def_lists;
   wire                   user_def_end;
   wire [5:0]                   user_def_addr_bits; //max 32
   wire [4:0]                   user_def_buff_bits; //max 16
  
   
     reg               joint_mode; 

   
   assign                   user_def_clkdiv     = 0;
   assign                   user_def_bus_32     = 1;
   assign                   user_def_ch_num     = 1;
   assign                   user_def_fifo_size  = 5;
   assign                   user_def_wcmd_depth = 1;
   assign                   user_def_rcmd_depth = 1;
   assign                   user_def_block      = 0;
   assign                   user_def_wait       = 0;
   assign                   user_def_outs       = 0;
   assign                   user_def_prio       = 0;
   assign                   user_def_tokens     = 1;
   assign                   user_def_timeout    = 1;
   assign                   user_def_wdt        = 1;
   assign                   user_def_joint      = 1;
   assign                   user_def_simul      = 1;
   assign                   user_def_periph     = 1;
   assign                   user_def_lists      = 1;
   assign                   user_def_end        = 1;
   assign                   user_def_addr_bits  = 32;
   assign                   user_def_buff_bits  = 10;

   
   assign                   user_def_stat0 =
                      {
                       3'b000,               //[31:29]
                       user_def_buff_bits,   //[28:24]
                       1'b0,                 //[23]
                        user_def_bus_32,      //[22]
                       user_def_addr_bits,   //[21:16]
                        user_def_rcmd_depth,  //[15:12]
                        user_def_wcmd_depth,  //[11:8]
                        user_def_fifo_size,   //[7:4]
                        user_def_ch_num       //[3:0]
                       };

   assign                   user_def_stat1 =
                      {
                       {21{1'b0}},           //[31:13]
                       user_def_clkdiv,      //[12]
                       user_def_end,         //[11]
                       user_def_lists,       //[10]
                       user_def_periph,      //[9]
                       user_def_simul,       //[8]
                       user_def_joint,       //[7]
                           user_def_block,       //[6]
                           user_def_wait,        //[5]
                           user_def_outs,        //[4]
                           user_def_prio,        //[3]
                           user_def_tokens,      //[2]
                           user_def_timeout,     //[1]
                           user_def_wdt          //[0]
                       };

   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      joint_mode <= #1 1'b0;
       end
     else if (wr_joint)
       begin
      joint_mode <= #1 pwdata[0];
       end

   
   assign rd_prio_top      = 'd0;
   assign rd_prio_high     = 'd0;
   assign rd_prio_top_num  = 'd0;
   assign rd_prio_high_num = 'd0;
   assign wr_prio_top      = 'd0;
   assign wr_prio_high     = 'd0;
   assign wr_prio_top_num  = 'd0;
   assign wr_prio_high_num = 'd0;


   assign clkdiv = 4'd0;

  
   assign              ch_start = {8{wr_start}} & pwdata[7:0];
     

   //interrupt
   prgen_scatter8_1 #(0) scatter_proc0(.ch_x(ch_int_all_proc), .x(proc0_int_stat));
   
endmodule

   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: dma_reg.v
//---------------------------------------------------------



module dma_axi32_reg(clk,reset,pclken,psel,penable,paddr,pwrite,pwdata,prdata,pslverr,core0_idle,ch_int_all_proc0,int_all_proc,core0_clkdiv,core0_ch_start,joint_mode0,rd_prio_top0,rd_prio_high0,rd_prio_top_num0,rd_prio_high_num0,wr_prio_top0,wr_prio_high0,wr_prio_top_num0,wr_prio_high_num0,periph_rx_req_reg,periph_tx_req_reg,periph_rx_clr,periph_tx_clr);

   input                       clk;
   input                   reset;
   
   input                   pclken;
   input                   psel;
   input                   penable;
   input [7:0]                   paddr;
   input                   pwrite;
   input [31:0]               pwdata;
   output [31:0]               prdata;
   output                   pslverr;

   input                   core0_idle;
   input [8*1-1:0]             ch_int_all_proc0;
   output [1-1:0]              int_all_proc;
   output [3:0]               core0_clkdiv;
   output [7:0]               core0_ch_start;
   output                   joint_mode0;
   output                   rd_prio_top0;
   output                   rd_prio_high0;
   output [2:0]               rd_prio_top_num0;
   output [2:0]               rd_prio_high_num0;
   output                   wr_prio_top0;
   output                   wr_prio_high0;
   output [2:0]               wr_prio_top_num0;
   output [2:0]               wr_prio_high_num0;
   output [31:1]               periph_rx_req_reg;
   output [31:1]               periph_tx_req_reg;
   input [31:1]               periph_rx_clr;
   input [31:1]               periph_tx_clr;

// `include "dma_axi32_reg_params.v"

   
   wire [31:0]                   user_def_stat;
   wire [31:0]                   user_def0_stat0;
   wire [31:0]                   user_def0_stat1;

   wire                   user_def_proj;
   wire [3:0]                   user_def_proc_num;
   wire                   user_def_dual_core;
   wire                   user_def_ic;
   wire                   user_def_ic_dual_port;
   wire                   user_def_clkgate;
   wire                   user_def_port0_mux;
   wire                   user_def_port1_mux;

   wire                               wr_joint0;
   wire                               wr_clkdiv0;
   wire                               wr_start0;
   wire                               wr_prio0;
   
   wire [7:0]                         proc0_int_stat0;
   wire [15:0]                        proc0_int_stat;
   wire                               proc0_int;
   wire [1-1:0]                int_all_proc_pre;
   reg [1-1:0]                 int_all_proc;
   
   
   wire                   wr_periph_rx;
   wire                   wr_periph_tx;
   reg [31:1]                   periph_rx_req_reg;
   reg [31:1]                   periph_tx_req_reg;
   
   wire [7:0]                   gpaddr;
   wire                   gpwrite;
   wire                   gpread;
   
   reg [31:0]                   prdata_pre;
   reg                       pslverr_pre;
   reg [31:0]                   prdata;
   reg                       pslverr;
   

   assign                              wr_joint0  = gpwrite & gpaddr == CORE0_JOINT;
   assign                              wr_clkdiv0 = gpwrite & gpaddr == CORE0_CLKDIV;
   assign                              wr_start0  = gpwrite & gpaddr == CORE0_START;
   assign                              wr_prio0   = gpwrite & gpaddr == CORE0_PRIO;
   
dma_axi32_reg_core0 dma_axi32_reg_core0(
                               .clk(clk),
                           .reset(reset),
                                   .wr_joint(wr_joint0),
                                   .wr_clkdiv(wr_clkdiv0),
                                   .wr_start(wr_start0),
                                   .wr_prio(wr_prio0),
                                   .pwdata(pwdata),
                                   .clkdiv(core0_clkdiv),
                                .ch_start(core0_ch_start),
                           .joint_mode(joint_mode0),
                           .rd_prio_top(rd_prio_top0),
                           .rd_prio_high(rd_prio_high0),
                                .rd_prio_top_num(rd_prio_top_num0),
                                .rd_prio_high_num(rd_prio_high_num0),
                           .wr_prio_top(wr_prio_top0),
                           .wr_prio_high(wr_prio_high0),
                                .wr_prio_top_num(wr_prio_top_num0),
                                .wr_prio_high_num(wr_prio_high_num0),
                                   .user_def_stat0(user_def0_stat0),
                                   .user_def_stat1(user_def0_stat1),
                                   .ch_int_all_proc(ch_int_all_proc0),
                                   .proc0_int_stat(proc0_int_stat0)
                                   );

     
   assign                   user_def_proj             = 0;
   assign                   user_def_proc_num         = 1;
   assign                   user_def_dual_core        = 0;
   assign                   user_def_ic               = 0;
   assign                   user_def_ic_dual_port     = 0;
   assign                   user_def_clkgate          = 0;
   assign                   user_def_port0_mux        = 0;
   assign                   user_def_port1_mux        = 0;
   
   assign                   user_def_stat =
                             {user_def_proj,              //[31]
                              {20{1'b0}},                 //[30:11]
                              user_def_port1_mux,         //[10]
                              user_def_port0_mux,         //[9]
                              user_def_clkgate,           //[8]
                               user_def_ic_dual_port,      //[7]
                               user_def_ic,                //[6]
                               user_def_dual_core,         //[5]
                               1'b0,                       //[4]
                               user_def_proc_num           //[3:0]
                              };
   

   

   
   assign                   gpaddr      = {8{psel}} & paddr;
   assign                   gpwrite     = psel & (~penable) & pwrite;
   assign                   gpread      = psel & (~penable) & (~pwrite);
   

   
   assign              wr_periph_rx = gpwrite & gpaddr == PERIPH_RX_CTRL;
   assign              wr_periph_tx = gpwrite & gpaddr == PERIPH_TX_CTRL;
   
   always @(posedge clk or posedge reset)
     if (reset)
       periph_rx_req_reg <= #1 {31{1'b0}};
     else if (wr_periph_rx | (|periph_rx_clr))
       periph_rx_req_reg <= #1 ({31{wr_periph_rx}} & pwdata[31:1]) & (~periph_rx_clr);
   
   always @(posedge clk or posedge reset)
     if (reset)
       periph_tx_req_reg <= #1 {31{1'b0}};
     else if (wr_periph_tx | (|periph_tx_clr))
       periph_tx_req_reg <= #1 ({31{wr_periph_tx}} & pwdata[31:1]) & (~periph_tx_clr);

   assign                   proc0_int_stat = {proc0_int_stat0};

   assign                             proc0_int = |proc0_int_stat;
      
   assign                             int_all_proc_pre = {proc0_int};
   
   always @(posedge clk or posedge reset)
     if (reset)
       int_all_proc <= #1 {1{1'b0}};
     else
       int_all_proc <= #1 int_all_proc_pre;

   
   always @(*)
     begin
    prdata_pre  = {32{1'b0}};
    
    case (gpaddr)
      PROC0_STATUS             : prdata_pre  = {{16{1'b0}}, proc0_int_stat0};
      
      CORE0_JOINT              : prdata_pre  = {{31{1'b0}}, joint_mode0};
      
      CORE0_PRIO               : prdata_pre  = {{16{1'b0}}, wr_prio_high0, wr_prio_high_num0, wr_prio_top0, wr_prio_top_num0, rd_prio_high0, rd_prio_high_num0, rd_prio_top0, rd_prio_top_num0};
      
      CORE0_CLKDIV             : prdata_pre  = {{28{1'b0}}, core0_clkdiv};
      
      CORE0_START              : prdata_pre  = {32{1'b0}};
            
      PERIPH_RX_CTRL            : prdata_pre  = {periph_rx_req_reg, 1'b0};
      PERIPH_TX_CTRL            : prdata_pre  = {periph_tx_req_reg, 1'b0};

      IDLE                      : prdata_pre  = {{30{1'b0}}, core0_idle};
      
      USER_DEF_STAT             : prdata_pre  = user_def_stat;
      USER_DEF0_STAT0          : prdata_pre  = user_def0_stat0;
      USER_DEF0_STAT1          : prdata_pre  = user_def0_stat1;
      
      default                   : prdata_pre  = {32{1'b0}};
    endcase
     end

   
   always @(/*AUTOSENSE*/gpaddr or gpread or gpwrite or psel)
     begin
    pslverr_pre = 1'b0;
    
    case (gpaddr)
      PROC0_STATUS             : pslverr_pre = gpwrite; //read only
      
      CORE0_JOINT              : pslverr_pre = 1'b0;    //read and write
      
      CORE0_PRIO               : pslverr_pre = 1'b0;    //read and write  
      
      CORE0_CLKDIV             : pslverr_pre = 1'b0;    //read and write
      
      CORE0_START              : pslverr_pre = gpread;  //write only
            
      PERIPH_RX_CTRL            : pslverr_pre = 1'b0;    //read and write  
      PERIPH_TX_CTRL            : pslverr_pre = 1'b0;    //read and write  
      
      IDLE                      : pslverr_pre = gpwrite; //read only
      
      USER_DEF_STAT             : pslverr_pre = gpwrite; //read only
      USER_DEF0_STAT0          : pslverr_pre = gpwrite; //read only
      USER_DEF0_STAT1          : pslverr_pre = gpwrite; //read only
      
      default                   : pslverr_pre = psel;    //decode error
    endcase
     end

   
   always @(posedge clk or posedge reset)
     if (reset)
       prdata <= #1 {32{1'b0}};
     else if (gpread & pclken)
       prdata <= #1 prdata_pre; 
     else if (pclken) //zero to allow or in apb_mux
       prdata <= #1 {32{1'b0}};

   always @(posedge clk or posedge reset)
     if (reset)
       pslverr <= #1 1'b0;
     else if ((gpread | gpwrite) & pclken)
       pslverr <= #1 pslverr_pre;
     else if (pclken)
       pslverr <= #1 1'b0;
   
   
endmodule

   



/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: prgen_delay.v
//---------------------------------------------------------



module prgen_delay(clk,reset,din,dout);
   
   
   input               clk;
   input               reset;
   
   input               din;
   output               dout;
   
   parameter               DELAY = 2;


   reg [DELAY:0]           shift_reg;
   
   always @(posedge clk or posedge reset)
     if (reset)
       shift_reg <= #1 {DELAY+1{1'b0}};
     else
       shift_reg <= #1 {shift_reg[DELAY-1:0], din};

   assign               dout = shift_reg[DELAY-1];
   
   
endmodule


   





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: prgen_demux.v
//---------------------------------------------------------


  

module prgen_demux8(sel,x,ch_x);

   parameter                  WIDTH      = 8;
   
   
   input [3-1:0]     sel;
   input [WIDTH-1:0]           x;
   output [8*WIDTH-1:0]    ch_x;

   
   reg [8*WIDTH-1:0]       ch_x;

   

   always @(/*AUTOSENSE*/sel or x)
     begin
    ch_x = {8*WIDTH{1'b0}};
    
    case (sel)                                  
      3'd0 : ch_x[WIDTH-1+WIDTH*0:WIDTH*0] = x;
      3'd1 : ch_x[WIDTH-1+WIDTH*1:WIDTH*1] = x;
      3'd2 : ch_x[WIDTH-1+WIDTH*2:WIDTH*2] = x;
      3'd3 : ch_x[WIDTH-1+WIDTH*3:WIDTH*3] = x;
      3'd4 : ch_x[WIDTH-1+WIDTH*4:WIDTH*4] = x;
      3'd5 : ch_x[WIDTH-1+WIDTH*5:WIDTH*5] = x;
      3'd6 : ch_x[WIDTH-1+WIDTH*6:WIDTH*6] = x;
      3'd7 : ch_x[WIDTH-1+WIDTH*7:WIDTH*7] = x;

      default :                                 
        ch_x[WIDTH-1:0] = x;      
    endcase                                     
     end

   
endmodule
   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: prgen_fifo.v
//---------------------------------------------------------



module prgen_fifo(clk,reset,push,pop,din,dout,empty,full);

   parameter                  WIDTH      = 8;
   parameter                  DEPTH_FULL = 8;

   parameter               SINGLE     = DEPTH_FULL == 1;
   parameter               DEPTH      = SINGLE ? 1 : DEPTH_FULL -1;
   parameter               DEPTH_BITS = 
                  (DEPTH <= 2)   ? 1 :
                  (DEPTH <= 4)   ? 2 :
                  (DEPTH <= 8)   ? 3 :
                  (DEPTH <= 16)  ? 4 :
                  (DEPTH <= 32)  ? 5 :
                  (DEPTH <= 64)  ? 6 :
                  (DEPTH <= 128) ? 7 : 
                  (DEPTH <= 256) ? 8 : 0; //0 is ilegal

   parameter               LAST_LINE  = DEPTH-1;
   
   

   input                      clk;
   input                      reset;

   input               push;
   input               pop;
   input [WIDTH-1:0]           din;
   output [WIDTH-1:0]           dout;
   //output               next;
   output               empty;
   output               full;
   

   wire               reg_push;
   wire               reg_pop;
   wire               fifo_push;
   wire               fifo_pop;
   
   reg [DEPTH-1:0]           fullness_in;
   reg [DEPTH-1:0]           fullness_out;
   reg [DEPTH-1:0]           fullness;
   reg [WIDTH-1:0]           fifo [DEPTH-1:0];
   wire               fifo_empty;
   wire               next;
   reg [WIDTH-1:0]           dout;
   reg                   dout_empty;
   reg [DEPTH_BITS-1:0]       ptr_in;
   reg [DEPTH_BITS-1:0]       ptr_out;
   
   


   assign               reg_push  = push & fifo_empty & (dout_empty | pop);
   assign               reg_pop   = pop & fifo_empty;
   assign               fifo_push = !SINGLE & push & (~reg_push);
   assign               fifo_pop  = !SINGLE & pop & (~reg_pop);
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       begin
      dout       <= #1 {WIDTH{1'b0}};
      dout_empty <= #1 1'b1;
       end
     else if (reg_push)
       begin
      dout       <= #1 din;
      dout_empty <= #1 1'b0;
       end
     else if (reg_pop)
       begin
      dout       <= #1 {WIDTH{1'b0}};
      dout_empty <= #1 1'b1;
       end
     else if (fifo_pop)
       begin
      dout       <= #1 fifo[ptr_out];
      dout_empty <= #1 1'b0;
       end
   
   always @(posedge clk or posedge reset)
     if (reset)
       ptr_in <= #1 {DEPTH_BITS{1'b0}};
     else if (fifo_push)
       ptr_in <= #1 ptr_in == LAST_LINE ? 0 : ptr_in + 1'b1;

   always @(posedge clk or posedge reset)
     if (reset)
       ptr_out <= #1 {DEPTH_BITS{1'b0}};
     else if (fifo_pop)
       ptr_out <= #1 ptr_out == LAST_LINE ? 0 : ptr_out + 1'b1;

   always @(posedge clk)
     if (fifo_push)
       fifo[ptr_in] <= #1 din;

   
   always @(/*AUTOSENSE*/fifo_push or ptr_in)
     begin
    fullness_in = {DEPTH{1'b0}};
    fullness_in[ptr_in] = fifo_push;
     end
   
   always @(/*AUTOSENSE*/fifo_pop or ptr_out)
     begin
    fullness_out = {DEPTH{1'b0}};
    fullness_out[ptr_out] = fifo_pop;
     end
   
   always @(posedge clk or posedge reset)
     if (reset)
       fullness <= #1 {DEPTH{1'b0}};
     else if (fifo_push | fifo_pop)
       fullness <= #1 (fullness & (~fullness_out)) | fullness_in;


   assign next       = |fullness;
   assign fifo_empty = ~next;
   assign empty      = fifo_empty & dout_empty;
   assign full       = SINGLE ? !dout_empty : &fullness;

   
   
   
endmodule




/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: prgen_joint_stall.v
//---------------------------------------------------------



module prgen_joint_stall(clk,reset,joint_req_out,rd_transfer,rd_transfer_size,ch_fifo_rd,data_fullness_pre,HOLD,joint_fifo_rd_valid,rd_transfer_size_joint,rd_transfer_full,joint_stall);

   parameter                  SIZE_BITS   = 1;
      
   input               clk;
   input               reset;

   input               joint_req_out;
   input               rd_transfer;
   input [SIZE_BITS-1:0]      rd_transfer_size;
   input               ch_fifo_rd;
   input [2:0]               data_fullness_pre;
   input               HOLD;
   
   output               joint_fifo_rd_valid;
   output [SIZE_BITS-1:0]     rd_transfer_size_joint;
   output               rd_transfer_full;
   output               joint_stall;
     
   


   wire               rd_transfer_joint;
   wire               joint_fifo_rd;
   wire               joint_fifo_rd_valid;
   wire [2:0]               count_ch_fifo_pre;
   reg [2:0]               count_ch_fifo;
   wire               joint_stall_pre;
   reg                   joint_stall_reg;
   wire               joint_not_ready_pre;
   wire               joint_not_ready;
   wire [SIZE_BITS-1:0]       rd_transfer_size_joint;
   wire               rd_transfer_full;
   reg [2:0]               joint_rd_stall_num;
   wire               joint_rd_stall;
   

   
   
   assign               rd_transfer_joint   = joint_req_out & rd_transfer;
   
   prgen_delay #(2) delay_joint_fifo_rd (.clk(clk), .reset(reset), .din(rd_transfer_joint), .dout(joint_fifo_rd));
      
   assign               count_ch_fifo_pre   = count_ch_fifo + rd_transfer_joint - ch_fifo_rd;

   //count fullness of channel's fifo
   always @(posedge clk or posedge reset)
     if (reset)
       count_ch_fifo <= #1 3'd0;
     else if (joint_req_out & (rd_transfer_joint | ch_fifo_rd))
       count_ch_fifo <= #1 count_ch_fifo_pre;

   //prevent read channel to overflow the channel's fifo
   assign               joint_stall_pre     = joint_req_out & ((count_ch_fifo_pre > 'd2) | ((count_ch_fifo_pre == 'd2) & (data_fullness_pre > 'd1)) | HOLD);

   //prevent write channel to overflow the wr data fifo
   assign               joint_not_ready_pre = joint_req_out & (data_fullness_pre > 'd1) & (~(rd_transfer_joint & joint_stall_pre));

   
   always @(posedge clk or posedge reset)
     if (reset)
       joint_stall_reg <= #1 1'b0;
     else if (joint_stall_pre)
       joint_stall_reg <= #1 1'b1;
     else if (count_ch_fifo_pre == 'd0)
       joint_stall_reg <= #1 1'b0;

   assign               joint_stall = joint_stall_reg | (joint_req_out & HOLD);
      
   prgen_delay #(1) delay_joint_not_ready (.clk(clk), .reset(reset), .din(joint_not_ready_pre), .dout(joint_not_ready));

   
   prgen_fifo #(SIZE_BITS, 2)
   rd_transfer_fifo(
            .clk(clk),
            .reset(reset),
            .push(rd_transfer_joint),
            .pop(joint_fifo_rd_valid),
            .din(rd_transfer_size),
            .dout(rd_transfer_size_joint),
            .empty(),
            .full(rd_transfer_full)
            );

   prgen_stall #(3) stall_joint_fifo_rd (.clk(clk), .reset(reset), .din(joint_fifo_rd), .stall(joint_not_ready), .dout(joint_fifo_rd_valid));
   
   
endmodule


   





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: prgen_min2.v
//---------------------------------------------------------



module prgen_min2(a,b,min);

   parameter             WIDTH = 8;
   
   input [WIDTH-1:0]      a;
   input [WIDTH-1:0]      b;

   output [WIDTH-1:0]      min;

   
   assign          min = a < b ? a : b;   
   
endmodule


   

/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: prgen_min3.v
//---------------------------------------------------------



module prgen_min3(clk,reset,a,b,c,min);

   parameter             WIDTH = 8;

   input          clk;
   input          reset;
   input [WIDTH-1:0]      a;
   input [WIDTH-1:0]      b;
   input [WIDTH-1:0]      c;

   output [WIDTH-1:0]      min;

   wire [WIDTH-1:0]      min_ab_pre;
   reg [WIDTH-1:0]      min_ab;
   reg [WIDTH-1:0]      min_c;
     

   prgen_min2 #(WIDTH) min2_ab(
                 .a(a),
                 .b(b),
                 .min(min_ab_pre)
                 );
   
   prgen_min2 #(WIDTH) min2_abc(
                  .a(min_ab),
                  .b(min_c),
                  .min(min)
                  );

   always @(posedge clk or posedge reset)
     if (reset)
       begin
      min_ab <= #1 {WIDTH{1'b0}};
      min_c  <= #1 {WIDTH{1'b0}};
       end
     else
       begin
      min_ab <= #1 min_ab_pre;
      min_c  <= #1 c;
       end
   
endmodule


   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: prgen_mux.v
//---------------------------------------------------------


  

module prgen_mux8(sel,ch_x,x);

   parameter                  WIDTH      = 8;
   
   
   input [3-1:0]     sel;
   input [8*WIDTH-1:0]     ch_x;
   output [WIDTH-1:0]           x;

   
   reg [WIDTH-1:0]              x;
   

   always @(/*AUTOSENSE*/ch_x or sel)
     begin
    case (sel)                                  
      3'd0 :x = ch_x[WIDTH-1+WIDTH*0:WIDTH*0];
      3'd1 :x = ch_x[WIDTH-1+WIDTH*1:WIDTH*1];
      3'd2 :x = ch_x[WIDTH-1+WIDTH*2:WIDTH*2];
      3'd3 :x = ch_x[WIDTH-1+WIDTH*3:WIDTH*3];
      3'd4 :x = ch_x[WIDTH-1+WIDTH*4:WIDTH*4];
      3'd5 :x = ch_x[WIDTH-1+WIDTH*5:WIDTH*5];
      3'd6 :x = ch_x[WIDTH-1+WIDTH*6:WIDTH*6];
      3'd7 :x = ch_x[WIDTH-1+WIDTH*7:WIDTH*7];
      
      default :                                 
        x = ch_x[WIDTH-1:0];      
    endcase                                     
     end

   
endmodule
   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:52 2011
//--
//-- Source file: prgen_or.v
//---------------------------------------------------------


  
module prgen_or8(ch_x,x);

   parameter                  WIDTH      = 8;
   
   
   input [8*WIDTH-1:0]     ch_x;
   output [WIDTH-1:0]           x;
   

   assign x = 
        ch_x[WIDTH-1+WIDTH*0:WIDTH*0] |
        ch_x[WIDTH-1+WIDTH*1:WIDTH*1] |
        ch_x[WIDTH-1+WIDTH*2:WIDTH*2] |
        ch_x[WIDTH-1+WIDTH*3:WIDTH*3] |
        ch_x[WIDTH-1+WIDTH*4:WIDTH*4] |
        ch_x[WIDTH-1+WIDTH*5:WIDTH*5] |
        ch_x[WIDTH-1+WIDTH*6:WIDTH*6] |
        ch_x[WIDTH-1+WIDTH*7:WIDTH*7] ;
   
endmodule
   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:53 2011
//--
//-- Source file: prgen_rawstat.v
//---------------------------------------------------------


  
module  prgen_rawstat (clk,reset,clear,write,pwdata,int_bus,rawstat);

   parameter           SIZE = 32;
   
   input            clk;
   input            reset;
   
   input            clear;
   input            write;
   input [SIZE-1:0]    pwdata;
   input [SIZE-1:0]    int_bus;
   
   output [SIZE-1:0]   rawstat;
   
   
   
   reg [SIZE-1:0]      rawstat;
   wire [SIZE-1:0]     write_bus;
   wire [SIZE-1:0]     clear_bus;
   
   
   assign            write_bus = {SIZE{write}} & pwdata;
   assign            clear_bus = {SIZE{clear}} & pwdata;
   
   
   always @(posedge clk or posedge reset)
     if (reset) 
       rawstat <= #1 {SIZE{1'b0}};
     else 
       rawstat <= #1 (rawstat | int_bus | write_bus) & (~clear_bus);
   
endmodule
   


/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:50 2011
//--
//-- Source file: prgen_scatter.v
//---------------------------------------------------------



module prgen_scatter8_1(ch_x,x);

   parameter                  CH_NUM     = 0;
   
   
   input [8*1-1:0]    ch_x;
   output [8-1:0]         x;


   assign               x = {
                  ch_x[CH_NUM+7],
                  ch_x[CH_NUM+6],
                  ch_x[CH_NUM+5],
                  ch_x[CH_NUM+4],
                  ch_x[CH_NUM+3],
                  ch_x[CH_NUM+2],
                  ch_x[CH_NUM+1],
                  ch_x[CH_NUM+0]};

   
endmodule
   

/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:51 2011
//--
//-- Source file: prgen_stall.v
//---------------------------------------------------------



module prgen_stall(clk,reset,din,stall,dout);

   parameter                  DEPTH   = 1;
      
   input               clk;
   input               reset;
   
   input               din;
   input               stall;
   output               dout;


   
   reg [DEPTH-1:0]           count;
   wire               pend;
   
   
   always @(posedge clk or posedge reset)
     if (reset)
       count <= #1 {DEPTH{1'b0}};
     else if (pend & (~stall))
       count <= #1 count - 1'b1;
     else if (din & stall)
       count <= #1 count + 1'b1;

   assign               pend = (|count);
   assign               dout = (din | pend) & (~stall);


   
   
   
endmodule


   





/////////////////////////////////////////////////////////////////////
////                                                             ////
////  Author: Eyal Hochberg                                      ////
////          eyal@provartec.com                                 ////
////                                                             ////
////  Downloaded from: http://www.opencores.org                  ////
/////////////////////////////////////////////////////////////////////
////                                                             ////
//// Copyright (C) 2010 Provartec LTD                            ////
//// www.provartec.com                                           ////
//// info@provartec.com                                          ////
////                                                             ////
//// This source file may be used and distributed without        ////
//// restriction provided that this copyright statement is not   ////
//// removed from the file and that any derivative work contains ////
//// the original copyright notice and the associated disclaimer.////
////                                                             ////
//// This source file is free software; you can redistribute it  ////
//// and/or modify it under the terms of the GNU Lesser General  ////
//// Public License as published by the Free Software Foundation.////
////                                                             ////
//// This source is distributed in the hope that it will be      ////
//// useful, but WITHOUT ANY WARRANTY; without even the implied  ////
//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR     ////
//// PURPOSE.  See the GNU Lesser General Public License for more////
//// details. http://www.gnu.org/licenses/lgpl.html              ////
////                                                             ////
/////////////////////////////////////////////////////////////////////
//---------------------------------------------------------
//-- File generated by RobustVerilog parser
//-- Version: 1.0
//-- Invoked Fri Mar 25 23:34:54 2011
//--
//-- Source file: prgen_swap32.v
//---------------------------------------------------------


  
module  prgen_swap32 (end_swap,data_in,data_out,bsel_in,bsel_out);
   
   input [1:0]            end_swap;
   input [31:0]        data_in;
   output [31:0]       data_out;
   input [3:0]            bsel_in;
   output [3:0]        bsel_out;

   
   reg [31:0]            data_out;
   reg [3:0]            bsel_out;


   
   always @(/*AUTOSENSE*/data_in or end_swap)
     begin
    case (end_swap[1:0])
      2'b00   : data_out = data_in;
      2'b01   : data_out = {data_in[23:16], data_in[31:24], data_in[7:0], data_in[15:8]};
      2'b10   : data_out = {data_in[7:0], data_in[15:8], data_in[23:16], data_in[31:24]};
      2'b11   : data_out = {data_in[7:0], data_in[15:8], data_in[23:16], data_in[31:24]};
    endcase
     end
   
   always @(/*AUTOSENSE*/bsel_in or end_swap)
     begin
    case (end_swap[1:0])
      2'b00   : bsel_out = bsel_in;
      2'b01   : bsel_out = {bsel_in[2], bsel_in[3], bsel_in[0], bsel_in[1]};
      2'b10   : bsel_out = {bsel_in[0], bsel_in[1], bsel_in[2], bsel_in[3]};
      2'b11   : bsel_out = {bsel_in[0], bsel_in[1], bsel_in[2], bsel_in[3]};
    endcase
     end
   
   
endmodule
