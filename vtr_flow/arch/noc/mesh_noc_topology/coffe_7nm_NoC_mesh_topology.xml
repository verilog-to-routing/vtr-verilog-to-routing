<architecture>
  <models>
    <model name="single_port_ram">
      <input_ports>
        <port name="we" clock="clk" combinational_sink_ports="out"/>
        <!-- control -->
        <port name="addr" clock="clk" combinational_sink_ports="out"/>
        <!-- address lines -->
        <port name="data" clock="clk" combinational_sink_ports="out"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="clk" is_clock="1"/>
        <!-- memories are often clocked -->
      </input_ports>
      <output_ports>
        <port name="out" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
      </output_ports>
    </model>
    <model name="dual_port_ram">
      <input_ports>
        <port name="we1" clock="clk" combinational_sink_ports="out1"/>
        <!-- write enable -->
        <port name="we2" clock="clk" combinational_sink_ports="out2"/>
        <!-- write enable -->
        <port name="addr1" clock="clk" combinational_sink_ports="out1"/>
        <!-- address lines -->
        <port name="addr2" clock="clk" combinational_sink_ports="out2"/>
        <!-- address lines -->
        <port name="data1" clock="clk" combinational_sink_ports="out1"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="data2" clock="clk" combinational_sink_ports="out2"/>
        <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
        <port name="clk" is_clock="1"/>
        <!-- memories are often clocked -->
      </input_ports>
      <output_ports>
        <port name="out1" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
        <port name="out2" clock="clk"/>
        <!-- output can be broken down into smaller bit widths minimum size 1 -->
      </output_ports>
    </model>
    <!-- Used inside DSPs. 
         Fixed point multiplication.
         ODIN infers these when * sign appears in RTL. -->
    <model name="multiply">
      <input_ports>
        <port name="a" combinational_sink_ports="out"/>
        <port name="b" combinational_sink_ports="out"/>
      </input_ports>
      <output_ports>
        <port name="out"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="int_sop_2">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="by" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    
    <model name="mult_add_int_18x19">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result scanout chainout"/>
        <port name="scanin" clock="clk" combinational_sink_ports="result scanout chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
        <port name="scanout"/>
      </output_ports>
    </model>
    <!--A mode in DSP slice-->
    <model name="int_sop_4">
      <input_ports>
        <port name="clk" is_clock="1"/>  
        <port name="reset" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ax" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="ay" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="bx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="by" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="cy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dx" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="dy" clock="clk" combinational_sink_ports="result chainout"/>
        <port name="chainin" clock="clk" combinational_sink_ports="result chainout"/>
      </input_ports>
      <output_ports>
        <port name="result" clock="clk"/>
        <port name="chainout"/>
      </output_ports>
    </model>
    <!-- NoC router adapter primitives-->
    <model name="noc_router_adapter_block">
      <input_ports>
        <!-- Master Interface-->
        <port name="master_tready" clock="clk"/>
        <!-- Slave Interface-->
        <port name="slave_tvalid" clock="clk"/>
        <port name="slave_tdata" clock="clk"/>
        <port name="slave_tstrb" clock="clk"/>
        <port name="slave_tkeep" clock="clk"/>
        <port name="slave_tid" clock="clk"/>
        <port name="slave_tdest" clock="clk"/>
        <port name="slave_tuser" clock="clk"/>
        <port name="slave_tlast" clock="clk"/>
        <!-- clk signal-->
        <port name="clk" is_clock="1"/>
        <!-- reset signal-->
        <port name="reset" clock="clk"/>
      </input_ports>
      <output_ports>
        <!-- Master Interface-->
        <port name="master_tvalid" clock="clk"/>
        <port name="master_tdata" clock="clk"/>
        <port name="master_tstrb" clock="clk"/>
        <port name="master_tkeep" clock="clk"/>
        <port name="master_tid" clock="clk"/>
        <port name="master_tdest" clock="clk"/>
        <port name="master_tuser" clock="clk"/>
        <port name="master_tlast" clock="clk"/>
        <!-- Slave Interface-->
        <port name="slave_tready" clock="clk"/>
      </output_ports>
    </model>
  </models>
    <!-- Fixed point MAC inside DSP slices -->
  <tiles>
    <tile name="io" area="0">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.clock io.inpad</loc>
          <loc side="top">io.outpad io.clock io.inpad</loc>
          <loc side="right">io.outpad io.clock io.inpad</loc>
          <loc side="bottom">io.outpad io.clock io.inpad</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb" height="1" width="1" area="27905">
      <sub_tile name="clb">
        <equivalent_sites>
          <site pb_type="clb" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="I1" num_pins="10" equivalent="full"/>
        <input name="I2" num_pins="10" equivalent="full"/>
        <input name="I3" num_pins="10" equivalent="full"/>
        <input name="I4" num_pins="10" equivalent="full"/>
        <output name="O1" num_pins="2" equivalent="full"/>
        <output name="O2" num_pins="2" equivalent="full"/>
        <output name="O3" num_pins="2" equivalent="full"/>
        <output name="O4" num_pins="2" equivalent="full"/>
        <output name="O5" num_pins="2" equivalent="full"/>
        <output name="O6" num_pins="2" equivalent="full"/>
        <output name="O7" num_pins="2" equivalent="full"/>
        <output name="O8" num_pins="2" equivalent="full"/>
        <output name="O9" num_pins="2" equivalent="full"/>
        <output name="O10" num_pins="2" equivalent="full"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.2" out_type="frac" out_val="0.025"/>
        <!-- Two sided connectivity CLB architecture--> 
        <pinlocations pattern="custom">
          <loc side="right">clb.I1 clb.I3 clb.clk clb.O1 clb.O2 clb.O3 clb.O4 clb.O5</loc>
          <loc side="bottom">clb.I2 clb.I4 clb.clk clb.O6 clb.O7 clb.O8 clb.O9 clb.O10</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="dsp_top" height="1" width="1" area="253779">
      <sub_tile name="dsp_top">
        <equivalent_sites>
          <site pb_type="dsp_top" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="reset" num_pins="1" is_non_clock_global="true"/>
        <input name="dsp_I1" num_pins="37" />
        <input name="dsp_I2" num_pins="37" />
        <input name="chainin" num_pins="64"/>
        <input name="scanin" num_pins="27"/>
        <output name="result" num_pins="74"/>
        <output name="chainout" num_pins="64"/>
        <output name="scanout" num_pins="27"/>
        <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <!-- clock pins and chain ports do not connect to local routing -->
          <fc_override port_name="clk" fc_type="frac" fc_val="0"/>
          <fc_override port_name="chainin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="chainout" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanin" fc_type="frac" fc_val="0"/>
          <fc_override port_name="scanout" fc_type="frac" fc_val="0"/>
        </fc>
        <pinlocations pattern="custom">
            <loc side="left">dsp_top.dsp_I1 dsp_top.reset dsp_top.result[73:37]</loc>
            <loc side="right">dsp_top.dsp_I2 dsp_top.clk dsp_top.result[36:0]</loc>
            <loc side="top">dsp_top.chainin dsp_top.scanin</loc>
            <loc side="bottom">dsp_top.chainout dsp_top.scanout</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="memory" height="1" width="1" area="137668">
      <sub_tile name="memory">
        <equivalent_sites>
          <site pb_type="memory" pin_mapping="direct"/>
        </equivalent_sites>
      <input name="addr1" num_pins="11"/>
      <input name="addr2" num_pins="11"/>
      <input name="data" num_pins="40"/>
      <input name="we1" num_pins="1"/>
      <input name="we2" num_pins="1"/>
      <output name="out" num_pins="40"/>
      <clock name="clk" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <fc_override fc_type="frac" fc_val="0" port_name="clk"/>
        </fc>  
        <pinlocations pattern="custom">
          <loc side="top"> memory.addr1[0] memory.addr1[8] memory.addr2[5] memory.data[2] memory.data[10] memory.data[18] memory.data[26] memory.data[34] memory.clk memory.addr1[1] memory.addr1[9] memory.addr2[6] memory.data[3] memory.data[11] memory.data[19] memory.data[27] memory.data[35] memory.out[0] memory.out[8] memory.out[16] memory.out[24] memory.out[32] memory.out[1] memory.out[9] memory.out[17] memory.out[25] memory.out[33]</loc>
          <loc side="right"> memory.addr1[2] memory.addr1[10] memory.addr2[7] memory.data[4] memory.data[12] memory.data[20] memory.data[28] memory.data[36] memory.addr1[3] memory.addr2[0] memory.addr2[8] memory.data[5] memory.data[13] memory.data[21] memory.data[29] memory.data[37] memory.out[2] memory.out[10] memory.out[18] memory.out[26] memory.out[34] memory.out[3] memory.out[11] memory.out[19] memory.out[27] memory.out[35]</loc>
          <loc side="bottom"> memory.addr1[4] memory.addr2[1] memory.addr2[9] memory.data[6] memory.data[14] memory.data[22] memory.data[30] memory.data[38] memory.addr1[5] memory.addr2[2] memory.addr2[10] memory.data[7] memory.data[15] memory.data[23] memory.data[31] memory.data[39] memory.out[4] memory.out[12] memory.out[20] memory.out[28] memory.out[36] memory.out[5] memory.out[13] memory.out[21] memory.out[29] memory.out[37]</loc>
          <loc side="left" > memory.addr1[6] memory.addr2[3] memory.data[0] memory.data[8] memory.data[16] memory.data[24] memory.data[32] memory.we1 memory.addr1[7] memory.addr2[4] memory.data[1] memory.data[9] memory.data[17] memory.data[25] memory.data[33] memory.we2 memory.out[6] memory.out[14] memory.out[22] memory.out[30] memory.out[38] memory.out[7] memory.out[15] memory.out[23] memory.out[31] memory.out[39]</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="noc_router_adapter" width="1" height="13" area="0">
      <sub_tile name="noc_router_adapter">
        <!-- We need to have a sub tile definition for each physical tile-->
        <equivalent_sites>
          <site pb_type="noc_router_adapter" pin_mapping="direct"/>
        </equivalent_sites>
        <!-- Pin sizes can change, if they do then it should be updated here as well.-->
        <!-- Master Interface-->
        <input name="master_tready" num_pins="1"/>
        <!-- Slave Interface-->
        <input name="slave_tvalid" num_pins="1"/>
        <input name="slave_tdata" num_pins="32"/>
        <input name="slave_tstrb" num_pins="4"/>
        <input name="slave_tkeep" num_pins="4"/>
        <input name="slave_tid" num_pins="8"/>
        <input name="slave_tdest" num_pins="8"/>
        <input name="slave_tuser" num_pins="8"/>
        <input name="slave_tlast" num_pins="1"/>
        <!-- clk signal-->
        <clock name="clk" num_pins="1"/>
        <!-- reset signal-->
        <input name="reset" num_pins="1"/>
        <!-- Master Interface-->
        <output name="master_tvalid" num_pins="1"/>
        <output name="master_tdata" num_pins="32"/>
        <output name="master_tstrb" num_pins="4"/>
        <output name="master_tkeep" num_pins="4"/>
        <output name="master_tid" num_pins="8"/>
        <output name="master_tdest" num_pins="8"/>
        <output name="master_tuser" num_pins="8"/>
        <output name="master_tlast" num_pins="1"/>
        <!-- Slave Interface-->
        <output name="slave_tready" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
        <pinlocations pattern="spread"/>
      </sub_tile>
    </tile>
    <tile name="tsv_hole" height="2" width="2" area="137668">
      <sub_tile name="tsv_hole">
        <equivalent_sites>
          <site pb_type="tsv_hole"/>
        </equivalent_sites>
        <input name="in" num_pins="1"/>
        <output name="out" num_pins="1"/>
        <fc in_type="abs" in_val="0" out_type="abs" out_val="0"/>
      </sub_tile>
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->
  <layout>
    <!-- Physical descriptions begin -->
    <fixed_layout name="coffe_7nm" width="328" height="288">
        <perimeter type="io" priority="101"/>
      
        <corners type="EMPTY" priority="102"/>

        <fill type="clb" priority="10"/>

        <col type="memory" startx="11" starty="1" repeatx="41" priority="20"/>
        <col type="memory" startx="25" starty="1" repeatx="41" priority="20"/>
        <col type="memory" startx="37" starty="1" repeatx="41" priority="20"/>

        <col type="dsp_top" startx="18" starty="1" repeatx="41" priority="20"/>
        <col type="dsp_top" startx="31" starty="1" repeatx="41" priority="20"/>

        <region type="noc_router_adapter" startx="25" starty="11" incrx="41" incry="36" priority="30"/>
        
    </fixed_layout>
  </layout>
  <device>
    <sizing R_minW_nmos="13090" R_minW_pmos="19086.83"/>
    <area grid_logic_tile_area="0"/>
    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="custom"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>
  <switchlist>
    <switch type="mux" name="L4_driver" R="0.0" Cin="0.0" Cout="0.0" Tdel="9.877e-11" mux_trans_size="2.6482996805637553" buf_size="18.744014602932605"/>
    <!-- Delay of L16 driver is scaled from L4 by a factor of 1.5x (based on numbers from the Titan Stratix IV architecture file)
   Area numbers will not be totally accurate because of the same buf_size -->
    <switch type="mux" name="L16_driver" R="0.0" Cin="0.0" Cout="0.0" Tdel="2.016e-10" mux_trans_size="3.1851297470059468" buf_size="39.327334265524485"/> 
    <switch type="mux" name="ipin_cblock" R="0.0" Cout="0.0" Cin="0.0" Tdel="5.636e-11" mux_trans_size="2.008" buf_size="9.624436045683868"/>
  </switchlist>
  <segmentlist>
    <segment name="L4" freq="280" length="4" type="unidir" Rmetal="0.0" Cmetal="0.0">
      <mux name="L4_driver"/>
      <sb type="pattern">1 1 1 1 1</sb>
      <cb type="pattern">1 1 1 1</cb>
    </segment>
    <segment name="L16" freq="40" length="16" type="unidir" Rmetal="0.0" Cmetal="0.0">
      <mux name="L16_driver"/>
      <!-- Vias from the top of the metal stack (global layers, where the long wires are 
           implemented) down to the middle/bottom of the metal stack (semi-global layers, 
           where the short wires are implemented) are expensive and restrictive.
           As a result Startix IV only places long wire switch blocks every 4 LABs -->
      <sb type="pattern">1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1</sb>
      <!-- For the same reasons, long wires do not connect to block pins in Stratix IV -->
      <cb type="pattern">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</cb>
    </segment>
  </segmentlist>
  <directlist>
    <!-- Direct connect from one DSP to the DSP directly below it -->
    <direct name="dsp_out_chain" from_pin="dsp_top.chainout" from_side="bottom" to_pin="dsp_top.chainin" to_side="top" x_offset="0" y_offset="-4" z_offset="0"/>
    <direct name="dsp_in_chain" from_pin="dsp_top.scanout" from_side="bottom" to_pin="dsp_top.scanin" to_side="top" x_offset="0" y_offset="-4" z_offset="0"/>
  </directlist>

  <complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- Not sure of the area of an I/O (varies widely), and it's not relevant to the design of the FPGA core, so we're setting it to 0. -->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <clock name="clock" num_pins="1"/>
      <!-- IOs can operate as either inputs or outputs.
       Delays below come from Ian Kuon. They are small, so they should be interpreted as
       the delays to and from registers in the I/O (and generally I/Os are registered 
       today and that is when you timing analyze them.
       -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <delay_constant max="4.243e-11" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <delay_constant max="1.394e-11" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
      <!-- Place I/Os on the sides of the FPGA -->
    </pb_type>
    <!-- Define I/O pads ends -->
    <!-- Define general purpose logic block (CLB) begin -->
    <pb_type name="clb">
      <input name="I1" num_pins="10" equivalent="full"/>
      <input name="I2" num_pins="10" equivalent="full"/>
      <input name="I3" num_pins="10" equivalent="full"/>
      <input name="I4" num_pins="10" equivalent="full"/>
      <output name="O1" num_pins="2" equivalent="full"/>
      <output name="O2" num_pins="2" equivalent="full"/>
      <output name="O3" num_pins="2" equivalent="full"/>
      <output name="O4" num_pins="2" equivalent="full"/>
      <output name="O5" num_pins="2" equivalent="full"/>
      <output name="O6" num_pins="2" equivalent="full"/>
      <output name="O7" num_pins="2" equivalent="full"/>
      <output name="O8" num_pins="2" equivalent="full"/>
      <output name="O9" num_pins="2" equivalent="full"/>
      <output name="O10" num_pins="2" equivalent="full"/>
      <clock name="clk" num_pins="1"/>  <!-- Basic logic element definition -->
      <pb_type name="fle" num_pb="10">
        <input name="in_A" num_pins="1"/>
        <input name="in_B" num_pins="1"/>
        <input name="in_C" num_pins="1"/>
        <input name="in_D" num_pins="1"/>
        <input name="in_E" num_pins="1"/>
        <input name="in_F" num_pins="1"/>
        <output name="out_local" num_pins="2"/>
        <output name="out_routing" num_pins="2"/>
        <clock name="clk" num_pins="1"/> 
        <mode name="n1_lut6">
          <pb_type name="ble6" num_pb="1">
            <input name="in_A" num_pins="1"/>
            <input name="in_B" num_pins="1"/>
            <input name="in_C" num_pins="1"/>
            <input name="in_D" num_pins="1"/>
            <input name="in_E" num_pins="1"/>
            <input name="in_F" num_pins="1"/>
            <output name="out_local" num_pins="1"/>
            <output name="out_routing" num_pins="2"/>
            <clock name="clk" num_pins="1"/> 
            <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
              <input name="in" num_pins="6" port_class="lut_in"/>
              <output name="out" num_pins="1" port_class="lut_out"/>
              <!-- We define the LUT delays on the LUT pins instead of through the LUT -->
              <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                 0
                 0
                 0
                 0
                 0
                 0
              </delay_matrix>
            </pb_type>
            <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
              <input name="D" num_pins="1" port_class="D"/>
              <output name="Q" num_pins="1" port_class="Q"/>
              <clock name="clk" num_pins="1" port_class="clock"/>
              <T_setup value="1.891e-11" port="ff.D" clock="clk"/>
              <T_clock_to_Q max="6.032e-11" port="ff.Q" clock="clk"/>
            </pb_type>
            <interconnect>
              <direct name="direct0" input="ble6.in_A" output="lut6.in[0:0]">
                <delay_constant max="1.1287999999999999e-10" in_port="ble6.in_A" out_port="lut6.in[0:0]" />
              </direct>
              <direct name="direct1" input="ble6.in_B" output="lut6.in[1:1]">
                <delay_constant max="1.1072500000000001e-10" in_port="ble6.in_B" out_port="lut6.in[1:1]" />
              </direct>
              <direct name="direct3" input="ble6.in_D" output="lut6.in[3:3]">
                <delay_constant max="8.1212e-11" in_port="ble6.in_D" out_port="lut6.in[3:3]" />
              </direct>
              <direct name="direct4" input="ble6.in_E" output="lut6.in[4:4]">
                <delay_constant max="7.961e-11" in_port="ble6.in_E" out_port="lut6.in[4:4]" />
              </direct>
              <direct name="direct5" input="ble6.in_F" output="lut6.in[5:5]">
                <delay_constant max="4.9300999999999996e-11" in_port="ble6.in_F" out_port="lut6.in[5:5]" />
              </direct>
              <!--Clock -->
              <direct name="direct6" input="ble6.clk" output="ff.clk"/>
              <!-- Register feedback mux -->   
              <mux name="mux1" input="ble6.in_C ff.Q" output="lut6.in[2:2]">
                <delay_constant max="1.1347e-10" in_port="ble6.in_C" out_port="lut6.in[2:2]" />
                <delay_constant max="1.1347e-10" in_port="ff.Q" out_port="lut6.in[2:2]" />  
              </mux>
              <!-- FF input selection mux -->
              <mux name="2" input="lut6.out ble6.in_C" output="ff.D">
                <delay_constant max="1.74588e-11" in_port="lut6.out" out_port="ff.D" />
                <delay_constant max="1.74588e-11" in_port="ble6.in_C" out_port="ff.D" />
              </mux>
              <!-- BLE output (local) -->
              <mux name="mux3" input="ff.Q lut6.out" output="ble6.out_local">
                <delay_constant max="1.346e-10" in_port="ff.Q" out_port="ble6.out_local" />
                <delay_constant max="1.346e-10" in_port="lut6.out" out_port="ble6.out_local" />
              </mux>
              <!-- BLE output (routing 1) --> 
              <mux name="mux4" input="ff.Q lut6.out" output="ble6.out_routing[0:0]">
                <delay_constant max="3.771e-11" in_port="ff.Q" out_port="ble6.out_routing[0:0]" />
                <delay_constant max="3.771e-11" in_port="lut6.out" out_port="ble6.out_routing[0:0]" />
              </mux>
              <!-- BLE output (routing 2) --> 
              <mux name="mux5" input="ff.Q lut6.out" output="ble6.out_routing[1:1]">
                <delay_constant max="3.771e-11" in_port="ff.Q" out_port="ble6.out_routing[1:1]" />
                <delay_constant max="3.771e-11" in_port="lut6.out" out_port="ble6.out_routing[1:1]" />
              </mux>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in_A" output="ble6.in_A"/>
            <direct name="direct2" input="fle.in_B" output="ble6.in_B"/>
            <direct name="direct3" input="fle.in_C" output="ble6.in_C"/>
            <direct name="direct4" input="fle.in_D" output="ble6.in_D"/>
            <direct name="direct5" input="fle.in_E" output="ble6.in_E"/>
            <direct name="direct6" input="fle.in_F" output="ble6.in_F"/>
            <direct name="direct7" input="ble6.out_local" output="fle.out_local[0:0]"/>
            <direct name="direct8" input="ble6.out_routing" output="fle.out_routing"/>
            <direct name="direct9" input="fle.clk" output="ble6.clk"/>
          </interconnect>
        </mode>  
        <mode name="n2_lut5">
          <pb_type name="lut5inter" num_pb="1">
            <input name="in_A" num_pins="1"/>
            <input name="in_B" num_pins="1"/>
            <input name="in_C" num_pins="1"/>
            <input name="in_D" num_pins="1"/>
            <input name="in_E" num_pins="1"/>
            <output name="out_local" num_pins="2"/>
            <output name="out_routing" num_pins="2"/>
            <clock name="clk" num_pins="1"/> 
            <pb_type name="ble5" num_pb="2">
              <input name="in_A" num_pins="1"/>
              <input name="in_B" num_pins="1"/>
              <input name="in_C" num_pins="1"/>
              <input name="in_D" num_pins="1"/>
              <input name="in_E" num_pins="1"/>
              <output name="out_local" num_pins="1"/>
              <output name="out_routing" num_pins="1"/>
              <clock name="clk" num_pins="1"/> 
              <pb_type name="lut5" blif_model=".names" num_pb="1" class="lut">
                <input name="in" num_pins="5" port_class="lut_in"/>
                <output name="out" num_pins="1" port_class="lut_out"/>
                <!-- We define the LUT delays on the LUT pins instead of through the LUT -->
                <delay_matrix type="max" in_port="lut5.in" out_port="lut5.out">
                   0
                   0
                   0
                   0
                   0
                </delay_matrix>
              </pb_type>
              <pb_type name="ff" blif_model=".latch" num_pb="1" class="flipflop">
                <input name="D" num_pins="1" port_class="D"/>
                <output name="Q" num_pins="1" port_class="Q"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="1.891e-11" port="ff.D" clock="clk"/>
                <T_clock_to_Q max="6.032e-11" port="ff.Q" clock="clk"/>
              </pb_type>
              <interconnect>
                <direct name="direct0" input="ble5.in_A" output="lut5.in[0:0]">
                  <delay_constant max="1.1287999999999999e-10" in_port="ble5.in_A" out_port="lut5.in[0:0]" />
                </direct>
                <direct name="direct1" input="ble5.in_B" output="lut5.in[1:1]">
                  <delay_constant max="1.1072500000000001e-10" in_port="ble5.in_B" out_port="lut5.in[1:1]" />
                </direct>
                <direct name="direct3" input="ble5.in_D" output="lut5.in[3:3]">
                  <delay_constant max="8.1212e-11" in_port="ble5.in_D" out_port="lut5.in[3:3]" />
                </direct>
                <direct name="direct4" input="ble5.in_E" output="lut5.in[4:4]">
                  <delay_constant max="7.961e-11" in_port="ble5.in_E" out_port="lut5.in[4:4]" />
                </direct>
                  <!--Clock -->
                <direct name="direct5" input="ble5.clk" output="ff.clk"/>
                <!-- Register feedback mux -->   
                <mux name="mux1" input="ble5.in_C ff.Q" output="lut5.in[2:2]">
                  <delay_constant max="1.1347e-10" in_port="ble5.in_C" out_port="lut5.in[2:2]" />
                  <delay_constant max="1.1347e-10" in_port="ff.Q" out_port="lut5.in[2:2]" />  
                </mux>
                <!-- FF input selection mux -->
                <mux name="2" input="lut5.out ble5.in_C" output="ff.D">
                  <delay_constant max="1.74588e-11" in_port="lut5.out" out_port="ff.D" />
                  <delay_constant max="1.74588e-11" in_port="ble5.in_C" out_port="ff.D" />
                </mux>
                <!-- BLE output (local) -->
                <mux name="mux3" input="ff.Q lut5.out" output="ble5.out_local">
                  <delay_constant max="1.346e-10" in_port="ff.Q" out_port="ble5.out_local" />
                  <delay_constant max="1.346e-10" in_port="lut5.out" out_port="ble5.out_local" />
                </mux>
                <!-- BLE output (routing 1) --> 
                <mux name="mux4" input="ff.Q lut5.out" output="ble5.out_routing[0:0]">
                  <delay_constant max="3.771e-11" in_port="ff.Q" out_port="ble5.out_routing[0:0]" />
                  <delay_constant max="3.771e-11" in_port="lut5.out" out_port="ble5.out_routing[0:0]" />
                </mux>
              </interconnect>
            </pb_type>
            <interconnect>
              <direct name="direct1" input="lut5inter.in_A" output="ble5[0:0].in_A"/>
              <direct name="direct2" input="lut5inter.in_B" output="ble5[0:0].in_B"/>
              <direct name="direct3" input="lut5inter.in_C" output="ble5[0:0].in_C"/>
              <direct name="direct4" input="lut5inter.in_D" output="ble5[0:0].in_D"/>
              <direct name="direct5" input="lut5inter.in_E" output="ble5[0:0].in_E"/>
              <direct name="direct6" input="lut5inter.in_A" output="ble5[1:1].in_A"/>
              <direct name="direct7" input="lut5inter.in_B" output="ble5[1:1].in_B"/>
              <direct name="direct8" input="lut5inter.in_C" output="ble5[1:1].in_C"/>
              <direct name="direct9" input="lut5inter.in_D" output="ble5[1:1].in_D"/>
              <direct name="direct10" input="lut5inter.in_E" output="ble5[1:1].in_E"/>
              <direct name="direct11" input="ble5[1:0].out_local" output="lut5inter.out_local"/>
              <direct name="direct12" input="ble5[1:0].out_routing" output="lut5inter.out_routing"/>
              <complete name="complete1" input="lut5inter.clk" output="ble5[1:0].clk"/> 
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="direct1" input="fle.in_A" output="lut5inter.in_A"/>
            <direct name="direct2" input="fle.in_B" output="lut5inter.in_B"/>
            <direct name="direct3" input="fle.in_C" output="lut5inter.in_C"/>
            <direct name="direct4" input="fle.in_D" output="lut5inter.in_D"/>
            <direct name="direct5" input="fle.in_E" output="lut5inter.in_E"/>
            <direct name="direct7" input="lut5inter.out_local" output="fle.out_local"/>
            <direct name="direct8" input="lut5inter.out_routing" output="fle.out_routing"/>
            <direct name="direct9" input="fle.clk" output="lut5inter.clk"/>
          </interconnect>
        </mode> 
        </pb_type>
        <interconnect>
        <!-- 50% sparsely populated local routing -->
        <complete name="lutA" input="clb.I4 clb.I3 fle[1:0].out_local fle[3:2].out_local fle[8:8].out_local" output="fle[9:0].in_A">
          <delay_constant max="2.842e-11" in_port="clb.I4" out_port="fle.in_A" />
          <delay_constant max="2.842e-11" in_port="clb.I3" out_port="fle.in_A" />
          </complete>
        <complete name="lutB" input="clb.I3 clb.I2 fle[3:2].out_local fle[5:4].out_local fle[9:9].out_local" output="fle[9:0].in_B">
          <delay_constant max="2.842e-11" in_port="clb.I3" out_port="fle.in_B" />
          <delay_constant max="2.842e-11" in_port="clb.I2" out_port="fle.in_B" />
          </complete>
        <complete name="lutC" input="clb.I2 clb.I1 fle[5:4].out_local fle[7:6].out_local fle[8:8].out_local" output="fle[9:0].in_C">
          <delay_constant max="2.842e-11" in_port="clb.I2" out_port="fle.in_C" />
          <delay_constant max="2.842e-11" in_port="clb.I1" out_port="fle.in_C" />
          </complete>
        <complete name="lutD" input="clb.I4 clb.I2 fle[1:0].out_local fle[5:4].out_local fle[9:9].out_local" output="fle[9:0].in_D">
          <delay_constant max="2.842e-11" in_port="clb.I4" out_port="fle.in_D" />
          <delay_constant max="2.842e-11" in_port="clb.I2" out_port="fle.in_D" />
          </complete>
        <complete name="lutE" input="clb.I3 clb.I1 fle[3:2].out_local fle[7:6].out_local fle[8:8].out_local" output="fle[9:0].in_E">
          <delay_constant max="2.842e-11" in_port="clb.I3" out_port="fle.in_E" />
          <delay_constant max="2.842e-11" in_port="clb.I1" out_port="fle.in_E" />
          </complete>
        <complete name="lutF" input="clb.I4 clb.I1 fle[1:0].out_local fle[7:6].out_local fle[9:9].out_local" output="fle[9:0].in_F">
          <delay_constant max="2.842e-11" in_port="clb.I4" out_port="fle.in_F" />
          <delay_constant max="2.842e-11" in_port="clb.I1" out_port="fle.in_F" />
          </complete>
          <complete name="clks" input="clb.clk" output="fle[9:0].clk">
          </complete>
          <!-- Direct connections to CLB outputs -->
          <direct name="clbouts1" input="fle[0:0].out_routing" output="clb.O1"/>
          <direct name="clbouts2" input="fle[1:1].out_routing" output="clb.O2"/>
          <direct name="clbouts3" input="fle[2:2].out_routing" output="clb.O3"/>
          <direct name="clbouts4" input="fle[3:3].out_routing" output="clb.O4"/>
          <direct name="clbouts5" input="fle[4:4].out_routing" output="clb.O5"/>
          <direct name="clbouts6" input="fle[5:5].out_routing" output="clb.O6"/>
          <direct name="clbouts7" input="fle[6:6].out_routing" output="clb.O7"/>
          <direct name="clbouts8" input="fle[7:7].out_routing" output="clb.O8"/>
          <direct name="clbouts9" input="fle[8:8].out_routing" output="clb.O9"/>
          <direct name="clbouts10" input="fle[9:9].out_routing" output="clb.O10"/>
        </interconnect>
      </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->

    <!-- Define DSP slice begin -->
    <pb_type name="dsp_top">
      <input name="reset" num_pins="1" is_non_clock_global="true"/>
      <input name="dsp_I1" num_pins="37" />
      <input name="dsp_I2" num_pins="37" />
      <input name="chainin" num_pins="64"/>
      <input name="scanin" num_pins="27"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <clock name="clk" num_pins="1"/>

    <pb_type name="dsp" num_pb="1">
      <input name="reset" num_pins="1"/>
      <input name="dsp_I1" num_pins="37"/>
      <input name="dsp_I2" num_pins="37"/>
      <input name="chainin" num_pins="64"/>
      <input name="scanin" num_pins="27"/>
      <output name="result" num_pins="74"/>
      <output name="chainout" num_pins="64"/>
      <output name="scanout" num_pins="27"/>
      <clock name="clk" num_pins="1"/>

      <pb_type name="dsp_pb" num_pb="1">
        <input name="reset" num_pins="1"/>
        <input name="datain" num_pins="74"/>
        <input name="chainin" num_pins="64"/>
        <input name="scanin" num_pins="27"/>
        <output name="result" num_pins="74"/>
        <output name="chainout" num_pins="64"/>
        <output name="scanout" num_pins="27"/>
        <clock name="clk" num_pins="1"/>

        <!-- fixed-point multiplier mode (1 27x27 multiplier) result = ax*ay -->
        <mode name="one_mult_27x27">
          <pb_type name="one_mult_27x27" num_pb="1">
            <input name="a" num_pins="27"/>
            <input name="b" num_pins="27"/>
            <output name="out" num_pins="54"/>
            <pb_type name="mult_27x27" blif_model=".subckt multiply" num_pb="1">
              <input name="a" num_pins="27"/>
              <input name="b" num_pins="27"/>
              <output name="out" num_pins="54"/>
              <delay_constant max="1.667e-9" in_port="mult_27x27.a" out_port="mult_27x27.out"/>
              <delay_constant max="1.667e-9" in_port="mult_27x27.b" out_port="mult_27x27.out"/>
            </pb_type>
            <interconnect>
              <direct name="a2a" input="one_mult_27x27.a" output="mult_27x27.a">
              </direct>
              <direct name="b2b" input="one_mult_27x27.b" output="mult_27x27.b">
              </direct>
              <direct name="out2out" input="mult_27x27.out" output="one_mult_27x27.out">
              </direct>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="datain2a" input="dsp_pb.datain[26:0]" output="one_mult_27x27.a">
            </direct>
            <direct name="datain2b" input="dsp_pb.datain[53:27]" output="one_mult_27x27.b">
            </direct>
            <direct name="out2dataout" input="one_mult_27x27.out" output="dsp_pb.result[53:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier mode (2 18x19 multipliers) result[some:bits] = ax*ay, result[other:bits] = bx*by -->
        <mode name="two_mult_18x19">
          <pb_type name="two_mult_18x19" num_pb="2">
            <input name="a" num_pins="18"/>
            <input name="b" num_pins="19"/>
            <output name="out" num_pins="37"/>
            <pb_type name="mult_18x19" blif_model=".subckt multiply" num_pb="1">
              <input name="a" num_pins="18"/>
              <input name="b" num_pins="19"/>
              <output name="out" num_pins="37"/>
              <delay_constant max="1.667e-9" in_port="mult_18x19.a" out_port="mult_18x19.out"/>
              <delay_constant max="1.667e-9" in_port="mult_18x19.b" out_port="mult_18x19.out"/>
            </pb_type>
            <interconnect>
              <direct name="a2a" input="two_mult_18x19.a" output="mult_18x19.a">
                 </direct>
              <direct name="b2b" input="two_mult_18x19.b" output="mult_18x19.b">
                 </direct>
              <direct name="out2out" input="mult_18x19.out" output="two_mult_18x19.out">
                 </direct>
            </interconnect>
          </pb_type>
          <interconnect>
            <direct name="datain2a1" input="dsp_pb.datain[17:0]" output="two_mult_18x19[0].a">
            </direct>
            <direct name="datain2b1" input="dsp_pb.datain[36:18]" output="two_mult_18x19[0].b">
            </direct>
            <direct name="datain2a2" input="dsp_pb.datain[54:37]" output="two_mult_18x19[1].a">
            </direct>
            <direct name="datain2b2" input="dsp_pb.datain[73:55]" output="two_mult_18x19[1].b">
            </direct>
            <direct name="out2result" input="two_mult_18x19.out" output="dsp_pb.result[73:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier-add-sum mode result = (bx * by) + (ax * ay) + chainin. chainout = result -->
        <mode name="sop_2_mode">
          <pb_type name="sop_2" num_pb="1" blif_model=".subckt int_sop_2">
            <input name="reset" num_pins="1"/>
            <input name="ax" num_pins="18"/>
            <input name="ay" num_pins="19"/>
            <input name="bx" num_pins="18"/>
            <input name="by" num_pins="19"/>
            <input name="chainin" num_pins="37"/>
            <output name="result" num_pins="37"/>
            <output name="chainout" num_pins="37"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="1.667e-9" in_port="sop_2.reset" out_port="sop_2.result"/>
            <delay_constant max="1.667e-9" in_port="sop_2.ax" out_port="sop_2.result"/>
            <delay_constant max="1.667e-9" in_port="sop_2.ay" out_port="sop_2.result"/>
            <delay_constant max="1.667e-9" in_port="sop_2.bx" out_port="sop_2.result"/>
            <delay_constant max="1.667e-9" in_port="sop_2.by" out_port="sop_2.result"/>
            <delay_constant max="1.667e-9" in_port="sop_2.chainin" out_port="sop_2.result"/>

            <delay_constant max="1.667e-9" in_port="sop_2.reset" out_port="sop_2.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_2.ax" out_port="sop_2.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_2.ay" out_port="sop_2.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_2.bx" out_port="sop_2.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_2.by" out_port="sop_2.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_2.chainin" out_port="sop_2.chainout"/>

            <T_setup value="1.891e-11" port="sop_2.ax" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.ay" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.bx" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.by" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.chainin" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.reset" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_2.result" clock="clk"/>

            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.ax" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.ay" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.bx" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.by" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.chainin" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.reset" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_2.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="sop_2.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="sop_2.reset">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[17:0]" output="sop_2.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[36:18]" output="sop_2.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[54:37]" output="sop_2.bx">
            </direct>
            <direct name="datain2by" input="dsp_pb.datain[73:55]" output="sop_2.by">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[36:0]" output="sop_2.chainin">
            </direct>
            <direct name="dataout2result" input="sop_2.result" output="dsp_pb.result[36:0]">
            </direct>
            <direct name="chainout" input="sop_2.chainout" output="dsp_pb.chainout[36:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point multiplier-add-sum mode result = (ax * ay) + bx + chainin. chainout = result. with scanin-scanout support -->
        <mode name="mult_add_mode_18_19_36">
          <pb_type name="mult_add" num_pb="1" blif_model=".subckt mult_add_int_18x19">
            <input name="reset" num_pins="1"/>
            <input name="ax" num_pins="18"/>
            <input name="ay" num_pins="19"/>
            <input name="bx" num_pins="36"/>
            <input name="chainin" num_pins="64"/>
            <input name="scanin" num_pins="19"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <output name="scanout" num_pins="19"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="1.667e-9" in_port="mult_add.reset" out_port="mult_add.result"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ax" out_port="mult_add.result"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ay" out_port="mult_add.result"/>
            <delay_constant max="1.667e-9" in_port="mult_add.bx" out_port="mult_add.result"/>
            <delay_constant max="1.667e-9" in_port="mult_add.chainin" out_port="mult_add.result"/>
            <delay_constant max="1.667e-9" in_port="mult_add.scanin" out_port="mult_add.result"/>

            <delay_constant max="1.667e-9" in_port="mult_add.reset" out_port="mult_add.chainout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ax" out_port="mult_add.chainout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ay" out_port="mult_add.chainout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.bx" out_port="mult_add.chainout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.chainin" out_port="mult_add.chainout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.scanin" out_port="mult_add.chainout"/>

            <delay_constant max="1.667e-9" in_port="mult_add.reset" out_port="mult_add.scanout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ax" out_port="mult_add.scanout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.ay" out_port="mult_add.scanout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.bx" out_port="mult_add.scanout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.chainin" out_port="mult_add.scanout"/>
            <delay_constant max="1.667e-9" in_port="mult_add.scanin" out_port="mult_add.scanout"/>

            <T_setup value="1.891e-11" port="mult_add.ax" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.ay" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.bx" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.chainin" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.scanin" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.reset" clock="clk"/>
            <T_setup value="1.891e-11" port="mult_add.result" clock="clk"/>

            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.ax" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.ay" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.bx" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.chainin" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.scanin" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.reset" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="mult_add.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="mult_add.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="mult_add.reset">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[17:0]" output="mult_add.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[36:18]" output="mult_add.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[72:37]" output="mult_add.bx">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="mult_add.chainin">
            </direct>
            <direct name="scanin"   input="dsp_pb.scanin[18:0]" output="mult_add.scanin">
            </direct>
            <direct name="dataout2result" input="mult_add.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="mult_add.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
            <direct name="scanout" input="mult_add.scanout" output="dsp_pb.scanout[18:0]">
            </direct>
          </interconnect>
        </mode>

        <!-- fixed-point sum-of-4 mode result = (dx * dy) + (cx * cy) + (bx * by) + (ax * ay) + chainin. chainout = result -->
        <mode name="sop_4_mode">
          <pb_type name="sop_4" num_pb="1" blif_model=".subckt int_sop_4">
            <input name="reset" num_pins="1"/>
            <input name="ax" num_pins="9"/>
            <input name="ay" num_pins="9"/>
            <input name="bx" num_pins="9"/>
            <input name="by" num_pins="9"/>
            <input name="cx" num_pins="9"/>
            <input name="cy" num_pins="9"/>
            <input name="dx" num_pins="9"/>
            <input name="dy" num_pins="9"/>
            <input name="chainin" num_pins="64"/>
            <output name="result" num_pins="64"/>
            <output name="chainout" num_pins="64"/>
            <clock name="clk" num_pins="1"/>

            <delay_constant max="1.667e-9" in_port="sop_4.reset" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.ax" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.ay" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.bx" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.by" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.cx" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.cy" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.dx" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.dy" out_port="sop_4.result"/>
            <delay_constant max="1.667e-9" in_port="sop_4.chainin" out_port="sop_4.result"/>

            <delay_constant max="1.667e-9" in_port="sop_4.reset" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.ax" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.ay" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.bx" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.by" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.cx" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.cy" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.dx" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.dy" out_port="sop_4.chainout"/>
            <delay_constant max="1.667e-9" in_port="sop_4.chainin" out_port="sop_4.chainout"/>

            <T_setup value="1.891e-11" port="sop_4.ax" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.ay" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.bx" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.by" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.cx" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.cy" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.dx" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.dy" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.chainin" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.reset" clock="clk"/>
            <T_setup value="1.891e-11" port="sop_4.result" clock="clk"/>

            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.ax" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.ay" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.bx" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.by" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.cx" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.cy" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.dx" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.dy" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.chainin" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.reset" clock="clk"/>
            <T_clock_to_Q max="6.032e-11" min="6.032e-11" port="sop_4.result" clock="clk"/>
          </pb_type>
          <interconnect>
            <direct name="clk" input="dsp_pb.clk" output="sop_4.clk">
            </direct>
            <direct name="reset" input="dsp_pb.reset" output="sop_4.reset">
            </direct>
            <direct name="datain2ax" input="dsp_pb.datain[8:0]" output="sop_4.ax">
            </direct>
            <direct name="datain2ay" input="dsp_pb.datain[17:9]" output="sop_4.ay">
            </direct>
            <direct name="datain2bx" input="dsp_pb.datain[26:18]" output="sop_4.bx">
            </direct>
            <direct name="datain2by" input="dsp_pb.datain[35:27]" output="sop_4.by">
            </direct>
            <direct name="datain2cx" input="dsp_pb.datain[44:36]" output="sop_4.cx">
            </direct>
            <direct name="datain2cy" input="dsp_pb.datain[53:45]" output="sop_4.cy">
            </direct>
            <direct name="datain2dx" input="dsp_pb.datain[62:54]" output="sop_4.dx">
            </direct>
            <direct name="datain2dy" input="dsp_pb.datain[71:63]" output="sop_4.dy">
            </direct>
            <direct name="chainin"   input="dsp_pb.chainin[63:0]" output="sop_4.chainin">
            </direct>
            <direct name="dataout2result" input="sop_4.result" output="dsp_pb.result[63:0]">
            </direct>
            <direct name="chainout" input="sop_4.chainout" output="dsp_pb.chainout[63:0]">
            </direct>
          </interconnect>
        </mode>
      </pb_type>

      <interconnect>
        <direct name="datain1" input="dsp.dsp_I1" output ="dsp_pb.datain[36:0]"/>
        <direct name="datain2" input="dsp.dsp_I2" output ="dsp_pb.datain[73:37]"/>
        <direct name="reset" input="dsp.reset" output="dsp_pb.reset"></direct>
        <direct name="chainin" input="dsp.chainin"    output="dsp_pb.chainin"></direct>
        <direct name="chainout" input="dsp_pb.chainout" output="dsp.chainout"></direct>
        <direct name="scanin" input="dsp.scanin"    output="dsp_pb.scanin"></direct>
        <direct name="scanout" input="dsp_pb.scanout" output="dsp.scanout"></direct>
        <direct name="result" input="dsp_pb.result" output="dsp.result"></direct>
        <direct name="clk" input="dsp.clk" output="dsp_pb.clk"></direct>
      </interconnect>  
    </pb_type>

      
    <interconnect>
      <!--50% sparse crossbar means 50% of the lines can reach an actual input of the dsp 
      We do this by splitting inputs into two buckets and having two full crossbars-->
      <!--
     <complete name="first_half" input="dsp_top.dsp_I1" output="dsp.dsp_I1">
          <delay_constant max="333e-12" in_port="dsp_top.dsp_I1" out_port="dsp.dsp_I1"/>
     </complete>

      <complete name="second_half" input="dsp_top.dsp_I2" output="dsp.dsp_I2">
          <delay_constant max="333e-12" in_port="dsp_top.dsp_I2" out_port="dsp.dsp_I2"/>
      </complete>
      -->
      <direct name="datain1" input="dsp_top.dsp_I1" output ="dsp.dsp_I1"/>
      <direct name="datain2" input="dsp_top.dsp_I2" output ="dsp.dsp_I2"/>

      <direct name="reset" input="dsp_top.reset" output="dsp.reset"></direct>
      <direct name="chainin" input="dsp_top.chainin" output="dsp.chainin">
          <delay_constant max="1179e-12" in_port="dsp_top.chainin" out_port="dsp.chainin"/>
      </direct>
      <direct name="chainout" input="dsp.chainout" output="dsp_top.chainout">
          <delay_constant max="1179e-12" in_port="dsp.chainout" out_port="dsp_top.chainout"/>
      </direct>
      <direct name="scanin" input="dsp_top.scanin" output="dsp.scanin">
          <delay_constant max="1179e-12" in_port="dsp_top.scanin" out_port="dsp.scanin"/>
      </direct>
      <direct name="scanout" input="dsp.scanout" output="dsp_top.scanout">
          <delay_constant max="1179e-12" in_port="dsp.scanout" out_port="dsp_top.scanout"/>
      </direct>
      <direct name="result" input="dsp.result" output="dsp_top.result"></direct>
      <direct name="clk" input="dsp_top.clk" output="dsp.clk"></direct>
    </interconnect>
  </pb_type>
    <!-- Define DSP slice end -->


    <!-- Define fracturable memory begin -->
    <!-- 
    RAM blocks always have registered inputs. The input FFs appear before the address decoder & wordline driver,
    and after the local input crossbar & level shifter.
    RAM blocks optionally have registered outputs. The output FFs (if present) appear after the output crossbar.
    If BRAM doesn't have registered outputs, then T_clk_to_q is the whole delay of the read/write operation.
    If BRAM does have registered output, then T_clk_to_q is just the FF clk_to_q and then delay_constant
    can be used to specify the whole delay of the read/write operation.

    This RAM block has registered outputs.

    The area and delay values of this RAM block were obtained (indirectly) from COFFE simulations.
    COFFE only support widths and depths that are powers of 2. For M20K (20 Kilobit BRAM), we need
    the width to be 40 bits and depth to be 512 (for the logically widest mode: 512x40). We can't
    simulate these dimensions directly in COFFE. So, we simulated and obtained the results for M32K
    (32 Kilobits BRAM) and (16 Kilobits BRAM). Then we interpolated the results.
    For delay, a linear interpolation was used, based on the size of the Memory (16K->20K->32K).
    For area, the value was calculated using two interpolations: (1) port based (change in number of 
    ports in going from 16K->20K->32K) and (2) number of bits based (change in number of bits in
    going from 16K->20K->32K). The interpolation that resulted in the larger area was picked.
    

    Here are the equations used to calculate the delays based on COFFE results:
    T_setup (inputs) = T_level_shifter + T_register_micro_setup = 32.3ps + 18.91ps = 51.21ps
    T_clk_to_q (inputs) = T_register_micro_clk_to_q = 60.32ps
    T_setup (outputs) = T_register_micro_setup = 18.91ps 
    T_clk_to_q (outputs) = T_register_micro_clk_to_q = 60.32ps

    (Register setup and clk_to_q timings are actually from the FF used in the logic cluster.)

    T_read = T1 + T2 + T3
    = max (Row decoder, Pre-charge time) + (Wordline driver + Bit line delay) + (Sense amp + Output crossbar)

    * Bit line delay is included in self.RAM.samp.delay time in COFFE. The Sense amp delay is actually
    self.RAM.samp_part2.delay

    T_write = T1 + T2 + T3
    = max (Row decoder, Pre-charge time) + (Wordline driver) + (Write driver)

    delay_constant values model the internal limits of a block (the combinatorial delay).
    delay_constant = max (T_read, T_write) 

    Overall internal delay of the RAM is T_clk_to_q (inputs) + delay_constant + T_setup (outputs)
    -->
    <pb_type name="memory">
      <input name="addr1" num_pins="11"/>
      <input name="addr2" num_pins="11"/>
      <input name="data" num_pins="40"/>
      <input name="we1" num_pins="1"/>
      <input name="we2" num_pins="1"/>
      <output name="out" num_pins="40"/>
      <clock name="clk" num_pins="1"/>
      <!-- Specify single port mode first -->
      <mode name="mem_512x40_sp">
        <pb_type name="mem_512x40_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="9" port_class="address"/>
          <input name="data" num_pins="40" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="40" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="-3.5e-11" port="mem_512x40_sp.addr" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_512x40_sp.data" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_512x40_sp.we" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_512x40_sp.out" clock="clk"/>

          <T_hold value="7.4e-11" port="mem_512x40_sp.addr" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_512x40_sp.data" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_512x40_sp.we" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_512x40_sp.out" clock="clk"/>

          <T_clock_to_Q max="3.7e-10" port="mem_512x40_sp.addr" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_512x40_sp.data" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_512x40_sp.we" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_512x40_sp.out" clock="clk"/>

          <delay_constant max="0" in_port="mem_512x40_sp.addr" out_port="mem_512x40_sp.out"/>
          <delay_constant max="0" in_port="mem_512x40_sp.data" out_port="mem_512x40_sp.out"/>
          <delay_constant max="0" in_port="mem_512x40_sp.we"   out_port="mem_512x40_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[8:0]" output="mem_512x40_sp.addr">
          </direct>
          <direct name="data1" input="memory.data" output="mem_512x40_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_512x40_sp.we">
          </direct>
          <direct name="dataout1" input="mem_512x40_sp.out" output="memory.out">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_512x40_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_1024x20_sp">
        <pb_type name="mem_1024x20_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="10" port_class="address"/>
          <input name="data" num_pins="20" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="20" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="-3.5e-11" port="mem_1024x20_sp.addr" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_1024x20_sp.data" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_1024x20_sp.we" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_1024x20_sp.out" clock="clk"/>

          <T_hold value="7.4e-11" port="mem_1024x20_sp.addr" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_1024x20_sp.data" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_1024x20_sp.we" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_1024x20_sp.out" clock="clk"/>

          <T_clock_to_Q max="3.7e-10" port="mem_1024x20_sp.addr" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_1024x20_sp.data" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_1024x20_sp.we" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_1024x20_sp.out" clock="clk"/>

          <delay_constant max="0" in_port="mem_1024x20_sp.addr" out_port="mem_1024x20_sp.out"/>
          <delay_constant max="0" in_port="mem_1024x20_sp.data" out_port="mem_1024x20_sp.out"/>
          <delay_constant max="0" in_port="mem_1024x20_sp.we"   out_port="mem_1024x20_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x20_sp.addr">
          </direct>
          <direct name="data1" input="memory.data[19:0]" output="mem_1024x20_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_1024x20_sp.we">
          </direct>
          <direct name="dataout1" input="mem_1024x20_sp.out" output="memory.out[19:0]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_1024x20_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_2048x10_sp">
        <pb_type name="mem_2048x10_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
          <input name="addr" num_pins="11" port_class="address"/>
          <input name="data" num_pins="10" port_class="data_in"/>
          <input name="we" num_pins="1" port_class="write_en"/>
          <output name="out" num_pins="10" port_class="data_out"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="-3.5e-11" port="mem_2048x10_sp.addr" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_2048x10_sp.data" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_2048x10_sp.we" clock="clk"/>
          <T_setup value="-3.5e-11" port="mem_2048x10_sp.out" clock="clk"/>

          <T_hold value="7.4e-11" port="mem_2048x10_sp.addr" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_2048x10_sp.data" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_2048x10_sp.we" clock="clk"/>
          <T_hold value="7.4e-11" port="mem_2048x10_sp.out" clock="clk"/>

          <T_clock_to_Q max="3.7e-10" port="mem_2048x10_sp.addr" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_2048x10_sp.data" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_2048x10_sp.we" clock="clk"/>
          <T_clock_to_Q max="3.7e-10" port="mem_2048x10_sp.out" clock="clk"/>

          <delay_constant max="0" in_port="mem_2048x10_sp.addr" out_port="mem_2048x10_sp.out"/>
          <delay_constant max="0" in_port="mem_2048x10_sp.data" out_port="mem_2048x10_sp.out"/>
          <delay_constant max="0" in_port="mem_2048x10_sp.we"   out_port="mem_2048x10_sp.out"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x10_sp.addr">
          </direct>
          <direct name="data1" input="memory.data[9:0]" output="mem_2048x10_sp.data">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_2048x10_sp.we">
          </direct>
          <direct name="dataout1" input="mem_2048x10_sp.out" output="memory.out[9:0]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_2048x10_sp.clk">
          </direct>
        </interconnect>
      </mode>

      <!-- Specify true dual port mode next -->
      <mode name="mem_1024x20_dp">
        <pb_type name="mem_1024x20_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
          <input name="addr1" num_pins="10" port_class="address1"/>
          <input name="addr2" num_pins="10" port_class="address2"/>
          <input name="data1" num_pins="20" port_class="data_in1"/>
          <input name="data2" num_pins="20" port_class="data_in2"/>
          <input name="we1" num_pins="1" port_class="write_en1"/>
          <input name="we2" num_pins="1" port_class="write_en2"/>
          <output name="out1" num_pins="20" port_class="data_out1"/>
          <output name="out2" num_pins="20" port_class="data_out2"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="-2.6e-11" port="mem_1024x20_dp.addr1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.data1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.we1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.addr2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.data2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.we2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.out1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_1024x20_dp.out2" clock="clk"/>

          <T_hold value="1.13e-10" port="mem_1024x20_dp.addr1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.data1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.we1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.addr2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.data2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.we2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.out1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_1024x20_dp.out2" clock="clk"/>

          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.addr1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.data1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.we1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.addr2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.data2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.we2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.out1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_1024x20_dp.out2" clock="clk"/>

          <delay_constant max="0" in_port="mem_1024x20_dp.addr1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="0" in_port="mem_1024x20_dp.data1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="0" in_port="mem_1024x20_dp.we1" out_port="mem_1024x20_dp.out1"/>
          <delay_constant max="0" in_port="mem_1024x20_dp.addr2" out_port="mem_1024x20_dp.out2"/>
          <delay_constant max="0" in_port="mem_1024x20_dp.data2" out_port="mem_1024x20_dp.out2"/>
          <delay_constant max="0" in_port="mem_1024x20_dp.we2" out_port="mem_1024x20_dp.out2"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x20_dp.addr1">
          </direct>
          <direct name="address2" input="memory.addr2[9:0]" output="mem_1024x20_dp.addr2">
          </direct>
          <direct name="data1" input="memory.data[19:0]" output="mem_1024x20_dp.data1">
          </direct>
          <direct name="data2" input="memory.data[39:20]" output="mem_1024x20_dp.data2">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_1024x20_dp.we1">
          </direct>
          <direct name="writeen2" input="memory.we2" output="mem_1024x20_dp.we2">
          </direct>
          <direct name="dataout1" input="mem_1024x20_dp.out1" output="memory.out[19:0]">
          </direct>
          <direct name="dataout2" input="mem_1024x20_dp.out2" output="memory.out[39:20]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_1024x20_dp.clk">
          </direct>
        </interconnect>
      </mode>

      <mode name="mem_2048x10_dp">
        <pb_type name="mem_2048x10_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
          <input name="addr1" num_pins="11" port_class="address1"/>
          <input name="addr2" num_pins="11" port_class="address2"/>
          <input name="data1" num_pins="10" port_class="data_in1"/>
          <input name="data2" num_pins="10" port_class="data_in2"/>
          <input name="we1" num_pins="1" port_class="write_en1"/>
          <input name="we2" num_pins="1" port_class="write_en2"/>
          <output name="out1" num_pins="10" port_class="data_out1"/>
          <output name="out2" num_pins="10" port_class="data_out2"/>
          <clock name="clk" num_pins="1" port_class="clock"/>

          <T_setup value="-2.6e-11" port="mem_2048x10_dp.addr1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.data1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.we1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.addr2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.data2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.we2" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.out1" clock="clk"/>
          <T_setup value="-2.6e-11" port="mem_2048x10_dp.out2" clock="clk"/>

          <T_hold value="1.13e-10" port="mem_2048x10_dp.addr1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.data1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.we1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.addr2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.data2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.we2" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.out1" clock="clk"/>
          <T_hold value="1.13e-10" port="mem_2048x10_dp.out2" clock="clk"/>

          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.addr1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.data1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.we1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.addr2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.data2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.we2" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.out1" clock="clk"/>
          <T_clock_to_Q max="3.57e-10" port="mem_2048x10_dp.out2" clock="clk"/>

          <delay_constant max="0" in_port="mem_2048x10_dp.addr1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="0" in_port="mem_2048x10_dp.data1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="0" in_port="mem_2048x10_dp.we1" out_port="mem_2048x10_dp.out1"/>
          <delay_constant max="0" in_port="mem_2048x10_dp.addr2" out_port="mem_2048x10_dp.out2"/>
          <delay_constant max="0" in_port="mem_2048x10_dp.data2" out_port="mem_2048x10_dp.out2"/>
          <delay_constant max="0" in_port="mem_2048x10_dp.we2" out_port="mem_2048x10_dp.out2"/>

        </pb_type>
        <interconnect>
          <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x10_dp.addr1">
          </direct>
          <direct name="address2" input="memory.addr2[10:0]" output="mem_2048x10_dp.addr2">
          </direct>
          <direct name="data1" input="memory.data[9:0]" output="mem_2048x10_dp.data1">
          </direct>
          <direct name="data2" input="memory.data[19:10]" output="mem_2048x10_dp.data2">
          </direct>
          <direct name="writeen1" input="memory.we1" output="mem_2048x10_dp.we1">
          </direct>
          <direct name="writeen2" input="memory.we2" output="mem_2048x10_dp.we2">
          </direct>
          <direct name="dataout1" input="mem_2048x10_dp.out1" output="memory.out[9:0]">
          </direct>
          <direct name="dataout2" input="mem_2048x10_dp.out2" output="memory.out[19:10]">
          </direct>
          <direct name="clk" input="memory.clk" output="mem_2048x10_dp.clk">
          </direct>
        </interconnect>
      </mode>
    </pb_type>
    <!-- Define fracturable memory end -->

    <!-- Define NoC router below-->
    <!-- The initial definition of this NoC router is a block that has internal registering of the the input and output signals
          and then a bit of combination delay is added within the block. Did not include power values either. -->
    <pb_type name="noc_router_adapter">
    <!-- Pin sizes can change, if they do then it should be updated here as well.-->
      <!-- Master Interface-->
      <input name="master_tready" num_pins="1"/>
      <!-- Slave Interface-->
      <input name="slave_tvalid" num_pins="1"/>
      <input name="slave_tdata" num_pins="32"/>
      <input name="slave_tstrb" num_pins="4"/>
      <input name="slave_tkeep" num_pins="4"/>
      <input name="slave_tid" num_pins="8"/>
      <input name="slave_tdest" num_pins="8"/>
      <input name="slave_tuser" num_pins="8"/>
      <input name="slave_tlast" num_pins="1"/>
      <!-- clk signal-->
      <clock name="clk" num_pins="1"/>
      <!-- reset signal-->
      <input name="reset" num_pins="1"/>
      <!-- Master Interface-->
      <output name="master_tvalid" num_pins="1"/>
      <output name="master_tdata" num_pins="32"/>
      <output name="master_tstrb" num_pins="4"/>
      <output name="master_tkeep" num_pins="4"/>
      <output name="master_tid" num_pins="8"/>
      <output name="master_tdest" num_pins="8"/>
      <output name="master_tuser" num_pins="8"/>
      <output name="master_tlast" num_pins="1"/>
      <!-- Slave Interface-->
      <output name="slave_tready" num_pins="1"/>
      <!-- There is only a single mode right now -->
      <mode name="noc_router_adapter_basic">
        <pb_type name="noc_router_adapter_basic" blif_model=".subckt noc_router_adapter_block" num_pb="1">
          <!-- Pin sizes can change, if they do then it should be updated here as well.-->
      <!-- Master Interface-->
      <input name="master_tready" num_pins="1"/>
      <!-- Slave Interface-->
      <input name="slave_tvalid" num_pins="1"/>
      <input name="slave_tdata" num_pins="32"/>
      <input name="slave_tstrb" num_pins="4"/>
      <input name="slave_tkeep" num_pins="4"/>
      <input name="slave_tid" num_pins="8"/>
      <input name="slave_tdest" num_pins="8"/>
      <input name="slave_tuser" num_pins="8"/>
      <input name="slave_tlast" num_pins="1"/>
      <!-- clk signal-->
      <clock name="clk" num_pins="1"/>
      <!-- reset signal-->
      <input name="reset" num_pins="1"/>
      <!-- Master Interface-->
      <output name="master_tvalid" num_pins="1"/>
      <output name="master_tdata" num_pins="32"/>
      <output name="master_tstrb" num_pins="4"/>
      <output name="master_tkeep" num_pins="4"/>
      <output name="master_tid" num_pins="8"/>
      <output name="master_tdest" num_pins="8"/>
      <output name="master_tuser" num_pins="8"/>
      <output name="master_tlast" num_pins="1"/>
      <!-- Slave Interface-->
      <output name="slave_tready" num_pins="1"/>
          <!-- Defining some timing constrains of the router (for now we are going to mimic the dffeas block) -->
      <T_setup value="66e-12" port="noc_router_adapter_basic.reset" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.master_tready" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tvalid" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tdata" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tstrb" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tkeep" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tid" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tdest" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tuser" clock="clk"/>
          <T_setup value="66e-12" port="noc_router_adapter_basic.slave_tlast" clock="clk"/>
          
          <T_hold value="37e-12" port="noc_router_adapter_basic.reset" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.master_tready" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tvalid" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tdata" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tstrb" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tkeep" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tid" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tdest" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tuser" clock="clk"/>
          <T_hold value="37e-12" port="noc_router_adapter_basic.slave_tlast" clock="clk"/>
          
          
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.slave_tready" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tvalid" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tdata" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tstrb" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tkeep" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tid" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tdest" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tuser" clock="clk"/>
          <T_clock_to_Q max="42e-12" min="37e-12" port="noc_router_adapter_basic.master_tlast" clock="clk"/>
        </pb_type>
        <interconnect>
          <!-- Not adding any wire delay for now-->
          <direct name="master_reset_connection" input="noc_router_adapter.reset" output="noc_router_adapter_basic.reset">
          </direct>
          <direct name="master_tready_connection" input="noc_router_adapter.master_tready" output="noc_router_adapter_basic.master_tready">
          </direct>
          <direct name="slave_tvalid_connection" input="noc_router_adapter.slave_tvalid" output="noc_router_adapter_basic.slave_tvalid">
          </direct>
          <direct name="slave_tdata_connection" input="noc_router_adapter.slave_tdata" output="noc_router_adapter_basic.slave_tdata">
          </direct>
          <direct name="slave_tstrb_connection" input="noc_router_adapter.slave_tstrb" output="noc_router_adapter_basic.slave_tstrb">
          </direct>
          <direct name="slave_tkeep_connection" input="noc_router_adapter.slave_tkeep" output="noc_router_adapter_basic.slave_tkeep">
          </direct>
          <direct name="slave_tid_connection" input="noc_router_adapter.slave_tid" output="noc_router_adapter_basic.slave_tid">
          </direct>
          <direct name="slave_tdest_connection" input="noc_router_adapter.slave_tdest" output="noc_router_adapter_basic.slave_tdest">
          </direct>
          <direct name="slave_tuser_connection" input="noc_router_adapter.slave_tuser" output="noc_router_adapter_basic.slave_tuser">
          </direct>
          <direct name="slave_tlast_connection" input="noc_router_adapter.slave_tlast" output="noc_router_adapter_basic.slave_tlast">
          </direct>
          
          
          <direct name="slave_tready_connection" input="noc_router_adapter_basic.slave_tready" output="noc_router_adapter.slave_tready">
          </direct>
          <direct name="master_tvalid_connection" input="noc_router_adapter_basic.master_tvalid" output="noc_router_adapter.master_tvalid">
          </direct>
      <direct name="master_tdata_connection" input="noc_router_adapter_basic.master_tdata" output="noc_router_adapter.master_tdata">
          </direct>
          <direct name="master_tstrb_connection" input="noc_router_adapter_basic.master_tstrb" output="noc_router_adapter.master_tstrb">
          </direct>
          <direct name="master_tkeep_connection" input="noc_router_adapter_basic.master_tkeep" output="noc_router_adapter.master_tkeep">
          </direct>
          <direct name="master_tid_connection" input="noc_router_adapter_basic.master_tid" output="noc_router_adapter.master_tid">
          </direct>
          <direct name="master_tdest_connection" input="noc_router_adapter_basic.master_tdest" output="noc_router_adapter.master_tdest">
          </direct>
          <direct name="master_tuser_connection" input="noc_router_adapter_basic.master_tuser" output="noc_router_adapter.master_tuser">
          </direct>
          <direct name="master_tlast_connection" input="noc_router_adapter_basic.master_tlast" output="noc_router_adapter.master_tlast">
          </direct>
          <direct name="clock_connection" input="noc_router_adapter.clk" output="noc_router_adapter_basic.clk">
          </direct>  
        </interconnect>
      </mode>
    </pb_type>
    <!-- Define NoC router end -->

    <pb_type name="tsv_hole">
      <input name="I" num_pins="1"/>
      <output name="O" num_pins="1"/>
      <interconnect/>
    </pb_type>

  </complexblocklist>

  <switchblocklist>
    <!-- Stratix IV uses a uni-directional routing architecture with a Driver Input Mux (DIM) size of 12 (i.e.
           each wire can be driven by one of 12 block/outputs or wires) for the L4s.
           
           In the Stratix IV architecture the long wires (L16 here) are accessible only from the short wires, 
           and are not connected to the block pins (i.e. connection blocks). Furthermore, they only connect 
           to switch blocks every 4 LABs (to avoid expensive deep via stacks).
           We approximate the L16 DIM size as 40:1 (in reality it is a pair of 20:1 (?) muxes with a 2:1 swap mux
           in front, which has nearly the same connectivity as a full 40:1).

           L4 wires
           ================
           At a channel width of 300 there are 260 L4/L4prime wires. At an effective Fc_out of 0.075 
           and 40 LAB outputs this yeilds:

                40 * 2 = 80 outputs per channel  [2 LABs per-channel]

                80 * 0.075 = 6 outputs drive each L4 wire [output connection block]

           This leaves:

                12 - 6 = 6 inputs to the DIMs from other routing wires [switch block]

           Since L4s connect at every switch block, there are:

                260 L16 wires per channel + direction which can drive wires at a particular switchblock
                (via switchpoints 0, 1, 2, 3)

           And for each direction (260 wires) only:

               260 / 4 = 65 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there are 32 L4s starting, and 32 L4s ending; + 1 wire for the 65th)

           Which we allocate as follows:

                L4
                =====
                straight-through connection: 2 (from L4 or L16)
                clock-wise turn            : 2 (from L4 or L16)
                counter-clock-wise turn    : 2 (from L4 or L16)

           L16 wires
           =========
           At a channel width of 300 there are 40 L16 wires (20 in each direction), which do not connect to the input/output connection blocks.
           This leaves 40 inputs to the DIM to select from routing wires (long wires use larger DIMs to improve reachability,
           the area cost is relatively small since they are so rare).

           Since L16s only connect at every 4th switch block there are:

                40 / 4 = 10 L16 wires per channel (5 in each direction) which can drive wires at a particular switchblock
                (via switchpoints 0, 4, 8, 12)

           And for each direction (20 wires) only:

               40 / 16 = 2.25 => 2 wires starting/ending per channel + direction at each switch block
               (i.e. from each direction, north/south/east/west, there is one L16 starting, and one L16 ending)
           
           We assign the 40 DIM inputs as follows:

                L16
                =====
                straight-through connection:  3 (from L16)
                straight-through connection: 11 (from L4)
                clock-wise turn            :  3 (from L16)
                clock-wise turn            : 10 (from L4)
                counter clock-wise turn    :  3 (from L16)
                counter clock-wise turn    : 10 (from L4)

           Switch pattern
           ==============
           This switch block is based on the Wilton switch block (see Page 103 of Steve Wilton's PhD Thesis 
           "Architecture and Algorithms for Field-Programmable Gate Arrays with Embedded Memory", 1997):

                left-to-top: W - t
                top-to-right: t + 1
                right-to-bottom: 2*W - 2 - t
                bottom-to-left: t + 1
                left-to-right: t
                top-to-bottom: t

           Since Wilton assumed bidirection routing (while we use unidirectional routing),
           we mirror the clock-wise turns to match the conter-clock-wise specification.
           -->
    <switchblock name="wilton_turn_clockwise_core" type="unidir">
      <switchblock_location type="CORE"/>
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="tl" formula="W-t"/>
        <!-- top to left -->
        <func type="rt" formula="t+1"/>
        <!-- right to top -->
        <func type="br" formula="2*W-2-t"/>
        <!-- bottom to right -->
        <func type="lb" formula="t+1"/>
        <!-- left to bottom -->
      </switchfuncs>
      <!-- L16 drivers -->
      <wireconn num_conns="3*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="10*to" from_type="L4" from_switchpoint="0" to_type="L16" to_switchpoint="0"/>
      <!-- L4 drivers 

               Driving from L16 (few) to L4 (many) preferr driving from end-point of L16, although since there are many they will
               all be multiply connected.
               
               Driving from L4 (many) to L4 (many) shuffle the switchpoints so the L4's are driven from a variety of switchpoints.
               Since the actual number L4s starting/ending are equal, using 'fixed' from_order would mean only switchpoint 0 -> 0
               connections. A 'shuffled' order will mix-up the from switchpoints for more diversity.
               -->
      <wireconn num_conns="2*to" from_order="shuffled">
        <from type="L16" switchpoint="0,12,8,4"/>
        <from type="L4" switchpoint="0,1,2,3"/>
        <to type="L4" switchpoint="0"/>
      </wireconn>
    </switchblock>
    <switchblock name="wilton_turn_counter_clockwise_core" type="unidir">
      <switchblock_location type="CORE"/>
      <switchfuncs>
        <!-- Counter-clock-wise turns -->
        <func type="lt" formula="W-t"/>
        <!-- left to top -->
        <func type="tr" formula="t+1"/>
        <!-- top to right -->
        <func type="rb" formula="2*W-2-t"/>
        <!-- right to bottom -->
        <func type="bl" formula="t+1"/>
        <!-- bottom to left -->
      </switchfuncs>
      <!-- L16 drivers -->
      <wireconn num_conns="3*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="10*to" from_type="L4" from_switchpoint="0" to_type="L16" to_switchpoint="0"/>
      <!-- L4 drivers 

               Driving from L16 (few) to L4 (many) preferr driving from end-point of L16, although since there are many they will
               all be multiply connected.
               
               Driving from L4 (many) to L4 (many) shuffle the switchpoints so the L4's are driven from a variety of switchpoints.
               Since the actual number L4s starting/ending are equal, using 'fixed' from_order would mean only switchpoint 0 -> 0
               connections. A 'shuffled' order will mix-up the from switchpoints for more diversity.

               Note that a different from_switchpoints ordering is used to ensure a different shuffling occurs compared to 
               wilton_turn_clockwise_core.
               -->
      <wireconn num_conns="2*to" from_order="shuffled">
        <from type="L16" switchpoint="0,12,8,4"/>
        <from type="L4" switchpoint="0,1,2,3"/>
        <to type="L4" switchpoint="0"/>
      </wireconn>
    </switchblock>
    <switchblock name="wilton_straight" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <!-- Straight -->
        <func type="lr" formula="t"/>
        <!-- left to right -->
        <func type="tb" formula="t"/>
        <!-- top to bottom -->
        <func type="rl" formula="t"/>
        <!-- right to left -->
        <func type="bt" formula="t"/>
        <!-- bottom to top -->
      </switchfuncs>
      <!-- L16 Drivers 
                Note that we order the switchpoints in order of preference, since VPR currently
                iterates through the source sets in order, such that we connect first to wires
                ending at the switchblock (switchpoint 0), and then fallback to switchpoints
                in decreasing distance from the drive point (if we have more to's than from's
                it then wraps around).

                Note also that we multiply the number of expected connections by 'to', since while usually
                there is only one 'to' wire, ocasionally there may be more, and we want to ensure they all
                get the same number of connections.

                For L16->L16:
                  We allow any valid switchpoint to be used as the 'from' point.
                  Allow 'low' switchpoints like '4' may seem counter-intuitive (i.e. why not use a cheaper L4)
                  this makes it easier to bypass once on the L16 network (e.g. to get around congestion).
           -->
      <wireconn num_conns="3*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="11*to" from_type="L4" from_switchpoint="0,3,2,1" to_type="L16" to_switchpoint="0"/>
      <!-- L4 Drivers -->
      <wireconn num_conns="2*to" from_order="shuffled">
        <from type="L16" switchpoint="0,12,8,4"/>
        <from type="L4" switchpoint="0"/>
        <to type="L4" switchpoint="0"/>
      </wireconn>
      <!--<wireconn num_conns="1*to" from_type="L4" from_switchpoint="0" to_type="L4" to_switchpoint="0"/>-->
      <!--<wireconn num_conns="1*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L4" to_switchpoint="0"/>-->
    </switchblock>
    <switchblock name="wilton_straight_corner" type="unidir">
      <!-- Same as wilton straight, but turning around a corner -->
      <switchblock_location type="CORNER"/>
      <switchfuncs>
        <!-- Counter-clock-wise turns -->
        <func type="lt" formula="t"/>
        <!-- left to top -->
        <func type="tr" formula="t"/>
        <!-- top to right -->
        <func type="rb" formula="t"/>
        <!-- right to bottom -->
        <func type="bl" formula="t"/>
        <!-- bottom to left -->
        <!-- Clock-wise turns -->
        <func type="tl" formula="t"/>
        <!-- top to left -->
        <func type="rt" formula="t"/>
        <!-- right to top -->
        <func type="br" formula="t"/>
        <!-- bottom to right -->
        <func type="lb" formula="t"/>
        <!-- left to bottom -->
      </switchfuncs>
      <!-- L16 Drivers -->
      <wireconn num_conns="3*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="11*to" from_type="L4" from_switchpoint="0,3,2,1" to_type="L16" to_switchpoint="0"/>
      <!-- L4 Drivers -->
      <wireconn num_conns="2*to" from_order="shuffled">
        <from type="L16" switchpoint="0,12,8,4"/>
        <from type="L4" switchpoint="0"/>
        <to type="L4" switchpoint="0"/>
      </wireconn>
      <!--<wireconn num_conns="1*to" from_type="L4" from_switchpoint="0" to_type="L4" to_switchpoint="0"/>-->
      <!--<wireconn num_conns="1*to" from_type="L16" from_switchpoint="0,12,8,4" to_type="L4" to_switchpoint="0"/>-->
    </switchblock>
    <switchblock name="wilton_turn_fringe" type="unidir">
      <!-- Non-corner perimeter SBs -->
      <switchblock_location type="FRINGE"/>
      <switchfuncs>
        <!-- Counter-clock-wise turns -->
        <func type="lt" formula="W-t"/>
        <!-- left to top -->
        <func type="tr" formula="t+1"/>
        <!-- top to right -->
        <func type="rb" formula="2*W-2-t"/>
        <!-- right to bottom -->
        <func type="bl" formula="t+1"/>
        <!-- bottom to left -->
        <!-- Clock-wise turns -->
        <func type="tl" formula="W-t"/>
        <!-- top to left -->
        <func type="rt" formula="t+1"/>
        <!-- right to top -->
        <func type="br" formula="2*W-2-t"/>
        <!-- bottom to right -->
        <func type="lb" formula="t+1"/>
        <!-- left to bottom -->
      </switchfuncs>
      <!-- We use 'max' style connections here to ensure there are no dangling wires, otherwise like core turns -->
      <!-- L16 drivers -->
      <wireconn num_conns="3*max(from,to)" from_type="L16" from_switchpoint="0,12,8,4" to_type="L16" to_switchpoint="0"/>
      <wireconn num_conns="21*max(from,to)" from_type="L4" from_switchpoint="0" to_type="L16" to_switchpoint="0"/>
      <!-- L4 drivers -->
      <wireconn num_conns="1*max(from,to)" from_type="L16" from_switchpoint="0,12,8,4" from_order="fixed" to_type="L4" to_switchpoint="0"/>
      <wireconn num_conns="1*max(from,to)" from_type="L4" from_switchpoint="0,1,2,3" from_order="shuffled" to_type="L4" to_switchpoint="0"/>
    </switchblock>
  </switchblocklist>

  <clocks>
    <clock buffer_size="auto" C_wire="2.5e-10"/>
  </clocks>

</architecture>


