<!-- ! this is the most up to date routing arch includes diagonals, a proper chanel width, proper fc
and fan out/in -->


<!--
  This architecture file is an approximation of the xilinx 7 series chip set. It's main purpose is to
verify VPR's ability to
  accommodate xilinx specific routing (i.e. differing wire lengths and frequencies in the
horizontal/vertical directions, differing chanel widths,
  and diagonal wire segments). Given that this architectures primary function is to test xilinx
specific routing, the architecture includes only
  a simplified version of the Xilinx CLB that excludes carry logic. f4pga/symbiflow's arch.timing.xml
and VTR's k6_N10_40nm.xml were pulled from to create
  this architecture description.

  - 40 nm technology
  - General purpose logic block excluding carry.
  - Routing architecture: fc_in = 0.15, Fc_out = 0.1
;
  Authors: Xan Johnson, Joshua Fife, Jeff Goeders
-->
<architecture>
  <!-- ODIN II specific config begins -->
  <!--
         Given that basic LUTs, I/Os, and flip-flops already have special structures in
     blif (.names, .input, .output, and .latch) that describe them and that this arch
     contains CLB logic blocks only, no special models are needed for this architecture.
    -->
  <models />
  <tiles>
    <tile name="io" area="0">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io" pin_mapping="direct" />
        </equivalent_sites>
        <input name="outpad" num_pins="1" />
        <output name="inpad" num_pins="1" />
        <clock name="clock" num_pins="1" />
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10" />
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb" area="53894">
      <sub_tile capacity="1" name="clb">
        <!-- Sub Tile Inputs -->
        <clock name="CLK" num_pins="1" />
        <input name="I" num_pins="56" equivalent="full" />
        <output name="O" num_pins="24" equivalent="instance" />

        <!-- ~1/5 wires connect to global routing for clb inputs. exactly 1/4 connect to global
        routing for outputs. -->
        <fc in_type="frac" in_val="0.20" out_type="frac" out_val="0.25">
          <fc_override port_name="cout" fc_type="frac" fc_val="0" />
          <!-- !! fc_in -->
          <!-- len4 wires only occur for outputs -->
          <fc_override port_name="clb.I" segment_name="len4_x" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="len4_stub" fc_type="frac" fc_val="0" />

          <!-- all len6 diagonals only occur for clb.O -->
          <fc_override port_name="clb.I" segment_name="1len4D_y" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="2len4D_y" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="3len4D_y" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="4len4D_y" fc_type="frac" fc_val="0" />

          <fc_override port_name="clb.I" segment_name="1len2D_x" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="2len2D_x" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="3len2D_x" fc_type="frac" fc_val="0" />
          <fc_override port_name="clb.I" segment_name="4len2D_x" fc_type="frac" fc_val="0" />

          <!-- CLB ports never connect to len18, len12, or cardinal len6 wires -->
          <fc_override segment_name="len6_y" fc_type="frac" fc_val="0" />
          <fc_override segment_name="len6_stub" fc_type="frac" fc_val="0" />

          <fc_override segment_name="len12_x" fc_type="frac" fc_val="0" />
          <fc_override segment_name="len12_y" fc_type="frac" fc_val="0" />

          <fc_override segment_name="len18_y" fc_type="frac" fc_val="0" />

        </fc>
        <equivalent_sites>
          <site pb_type="clb" pin_mapping="direct"></site>
        </equivalent_sites>
      </sub_tile>
      <switchblock_locations pattern="all" />
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->

  <!-- Physical descriptions begin -->
  <layout>
    <!-- <fixed_layout name="correct_xilinx" width="96" height="155"> -->
    <auto_layout aspect_ratio="1.0">
      <!--Perimeter
      of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100" />
      <corners type="EMPTY" priority="101" />
      <!--Fill
      with 'clb'-->
      <fill type="clb" priority="10" />
      <!-- </fixed_layout> -->
    </auto_layout>
  </layout>
  <device>
    <!-- The  values bellow (sizing and area) are pulled from the k6_N10_40nm arch. -->
    <sizing R_minW_nmos="8926" R_minW_pmos="16067" />
    <area grid_logic_tile_area="0" />

    <chan_width_distr>
      <x distr="uniform" peak="0.652632" />
      <y distr="uniform" peak="1.000000" />
    </chan_width_distr>
    <switch_block type="custom" />
    <connection_block input_switch_name="ipin_cblock" />
  </device>

  <switchlist>

    <!--the
    following muxes for unidirectional wires are pulled from k6_N10_40nm -->
    <switch type="short" name="electrical_short2" R="0" Cin="0" Tdel="0" />
    <switch type="mux" name="0" R="551" Cin=".77e-15" Cout="4e-15" Tdel="58e-12"
      mux_trans_size="2.630740" buf_size="27.645901" />
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="7.247000e-11"
      mux_trans_size="1.222260" buf_size="auto" />
  </switchlist>

  <segmentlist>
    <!---
    The following segment data is pulled from Table 1 of the NetCraker paper by Morten B. Petersen,
    Stefan Nikolić and Mirjana Stojilović: see https://dl.acm.org/doi/10.1145/3431920.3439285.
    Frequencies
    are calculated by dividing each wire segments count in the horizontal/vertical direction
    by the total width/hight of the architecture -->

    <!-- TODO: To more accurately approximate the seven series, support for both unidirectional and
    bidirectional segments within the same segmentlist is needed. For now we declare all segments as
    unidirectional -->

    <!-- TODO: For proper timing, Xilinx specific values for Rmetal and Cmetal are required.
    For now we approximate using the values given in the k6_N10_40nm arch -->

    <segment axis="x" name="len1_x" freq="0.112903" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="y" name="len1_y" freq="0.073684" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>

    <segment axis="y" name="stub" freq="0.088047" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="x" name="stub_dud" freq="0.000000" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>

    <segment axis="x" name="len2_x" freq="0.129031" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment axis="y" name="len2_y" freq="0.084210" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 1</cb>
    </segment>

    <segment axis="x" name="len4_x" freq="0.225807" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 1</cb>
    </segment>
    <segment axis="y" name="len4_y" freq="0" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 1</cb>
    </segment>


    <!-- 12.5% of horizontal len4 wires have the following unique sb pattern -->
    <segment axis="x" name="len4_stub" freq="0.032258" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1 1 0 1</sb>
      <cb type="pattern">1 1 0 1</cb>
    </segment>


    <!-- No length 6 horizontal chanels -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len6_x" freq="0.000000" length="6" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1 1 0 0 1 1</sb>
      <cb type="pattern">1 1 0 0 1 1</cb>
    </segment>
    <segment axis="y" name="len6_y" freq="0.189475" length="6" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0 0 1</cb>
    </segment>

    <!-- 25% of len6 vertical wires have a unique sb pattern -->
    <segment axis="y" name="len6_stub" freq="0.063158" length="6" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1 1 0 0 1 1</sb>
      <cb type="pattern">1 1 0 0 1 1</cb>
    </segment>

    <!-- TODO: In xilinx length 12 and 18 wires are bidirectional -->

    <segment axis="x" name="len12_x" freq="0.096774" length="12" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
    </segment>
    <segment axis="y" name="len12_y" freq="0.063158" length="12" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
    </segment>

    <!-- No length 18 horizontal chanel's -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len18_x" freq="0.000000" length="18" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</cb>
    </segment>

    <segment axis="y" name="len18_y" freq="0.094736" length="18" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1</cb>
    </segment>


    <!-- TODO: Support in VPR for diagonal wires is currently in the works.
  Until full support for this feature is implemented, this part of the
  Xilinx routing is excluded. -->

    <!-- all length 4 vertical wires are part of diagonal components. We split the vertical
    contribution of length 4 
  wires into four separate parts so that all intercardinal directions may be specified without
    conflict when SB unions occur. 
  The same thing is done to length 2 wires-->
    <segment axis="y" name="1len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
    </segment>
    <segment axis="y" name="2len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
    </segment>
    <segment axis="y" name="3len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
    </segment>
    <segment axis="y" name="4len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
    </segment>

    <!-- length 2 horizontal wires that contribute to diagonal interconnect -->
    <segment axis="x" name="1len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="2len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="3len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>
    <segment axis="x" name="4len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>

    <!-- L1->L1 diagonals -->
    <segment axis="y" name="len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="y" name="2len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="y" name="3len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="y" name="4len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>

    <segment axis="x" name="len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="x" name="2len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="x" name="3len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>
    <segment axis="x" name="4len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101"
      Cmetal="22.5e-15">
      <mux name="0" />
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
    </segment>

    <!--!!!
    BUG: If you misspell axsis nothing happens (no error)  -->

  </segmentlist>
  <complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- The structure of the IO from the k6_N10_40nm arch is
    used here to approximate the seven series IO. Timing values
    are changed to match the seven series.-->
    <pb_type name="io">
      <input name="outpad" num_pins="1" />
      <output name="inpad" num_pins="1" />
      <clock name="clock" num_pins="1" />
      <!-- IOs can operate as either inputs or outputs.
           Delays below are pulled from the IOBUF description
       in f4pga/symbiflow's arch.timing.xml
           -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1" />
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
            <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="inpad.inpad" out_port="io.inpad" />
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1" />
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
            <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="io.outpad" out_port="outpad.outpad" />
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven
      by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency,
            make it physically equivalent on all sides so that only one definition of I/Os is needed.
          -->
      <!-- Place I/Os on the sides of the FPGA -->
      <power method="ignore" />
    </pb_type>
    <!-- Define I/O pads ends -->

    <pb_type name="clb">
      <clock name="CLK" num_pins="1" />
      <!-- The pins of the luts are logicaly equivelent because any of the 4 luts may be used to
      perform the same
      logic functions. This is done for real arches such as coffe and stratix. -->
      <input name="I" num_pins="56" equivalent="full" />
      <output name="O" num_pins="24" equivalent="instance" /> <!-- note that there are 81 ports and
      81 internal cb connections.-->
      <pb_type name="slice" num_pb="2">
        <clock name="CLK" num_pins="1" />
        <input name="I" num_pins="28" />
        <output name="O" num_pins="12" />
        <pb_type name="fle" num_pb="4">
          <input name="in" num_pins="6" />
          <input name="inX" num_pins="1" />
          <output name="out" num_pins="1" />
          <output name="outMUX" num_pins="1" />
          <output name="outQ" num_pins="1" />
          <clock name="clk" num_pins="1" />
          <pb_type name="ALUT" num_pb="1">
            <input name="A" num_pins="6" />
            <output name="O5" num_pins="1" />
            <output name="O6" num_pins="1" />
            <mode name="n2_lut5">
              <pb_type name="lut5_mode" num_pb="1">
                <input name="in" num_pins="5" />
                <output name="out" num_pins="1" />
                <pb_type name="lut5" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="5" port_class="lut_in" />
                  <output name="out" num_pins="1" port_class="lut_out" />
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are
                  pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="max">
                    1.5200000000000002e-10
                    1.5200000000000002e-10
                    1.5e-10
                    1.5e-10
                    1.18e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="min">
                    4.4e-11
                    4.4e-11
                    4.2000000000000004e-11
                    4.6e-11
                    4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut5_mode.in" output="lut5.in" />
                  <direct name="direct2" input="lut5.out" output="lut5_mode.out" />
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A[4:0]" output="lut5_mode.in" />
                <direct name="direct3" input="lut5_mode.out" output="ALUT.O5" />
              </interconnect>
            </mode>
            <mode name="n1_lut6">
              <pb_type name="lut6_mode" num_pb="1">
                <input name="in" num_pins="6" />
                <output name="out" num_pins="1" />
                <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="6" port_class="lut_in" />
                  <output name="out" num_pins="1" port_class="lut_out" />
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are
                  pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="max">
                    1.6200000000000002e-10
                    1.6200000000000002e-10
                    1.6e-10
                    1.6e-10
                    1.6e-10
                    1.28e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="min">
                    4.4e-11
                    4.4e-11
                    4.2000000000000004e-11
                    4.6e-11
                    4.5e-11
                    4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut6_mode.in" output="lut6.in" />
                  <direct name="direct2" input="lut6.out" output="lut6_mode.out" />
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A" output="lut6_mode.in" />
                <direct name="direct2" input="lut6_mode.out" output="ALUT.O6" />
              </interconnect>
            </mode>
          </pb_type>

          <pb_type blif_model=".latch" name="FDSE" num_pb="2" class="flipflop">
            <clock name="clk" num_pins="1" port_class="clock" />
            <input name="D" num_pins="1" port_class="D" />
            <output name="Q" num_pins="1" port_class="Q" />
            <T_setup clock="clk" port="FDSE.D" value="-4.6e-11" />
            <T_hold clock="clk" port="FDSE.D" value="1.81e-10" />
            <T_clock_to_Q clock="clk" max="3.03e-10" port="FDSE.Q" min="9.900000000000001e-11" />
          </pb_type>
          <!-- The following interconnect matches that of the seven series.
          Delays are pulled from the f4pga/symbiflow arch -->
          <interconnect>
            <mux name="AOUTMUX" input="ALUT.O5 ALUT.O6 FDSE[0].Q" output="fle.outMUX">
              <delay_constant in_port="FDSE[0].Q" max="1.73e-10" out_port="fle.outMUX" />
              <delay_constant in_port="ALUT[0].O6" max="2.05e-10" out_port="fle.outMUX" />
              <delay_constant in_port="ALUT[0].O5" max="2.0300000000000002e-10"
                out_port="fle.outMUX" />
            </mux>
            <mux name="FFMUX" input="ALUT.O5 fle.inX" output="FDSE[0].D">
              <delay_constant in_port="fle.inX" max="2.0200000000000003e-10" out_port="FDSE[0].D" />
              <delay_constant in_port="ALUT.O5" max="1.07e-10" out_port="FDSE[0].D" />
            </mux>
            <mux name="A5FFMUX" input="ALUT.O5 ALUT.O6 fle.inX" output="FDSE[1].D">
              <delay_constant in_port="fle.inX" max="2.14e-10" out_port="FDSE[1].D" />
              <delay_constant in_port="ALUT.O5" max="9.6e-11" out_port="FDSE[1].D" />
              <delay_constant in_port="ALUT.O6" max="1.07e-10" out_port="FDSE[1].D" />
            </mux>
            <direct name="inputs" input="fle.in" output="ALUT.A" />
            <direct name="outA" input="ALUT.O6" output="fle.out" />
            <direct name="outQ" input="FDSE[1].Q" output="fle.outQ" />
            <complete name="clocks" input="fle.clk" output="FDSE[1:0].clk" />
          </interconnect>
        </pb_type>

        <interconnect>
          <complete input="slice.CLK" name="CK" output="fle.clk" />
          <direct name="dir1" input="fle[0].outMUX" output="slice.O[0]" />
          <direct name="dir2" input="fle[0].out" output="slice.O[1]" />
          <direct name="dir3" input="fle[0].outQ" output="slice.O[2]" />
          <direct name="dir4" input="fle[1].outMUX" output="slice.O[3]" />
          <direct name="dir5" input="fle[1].out" output="slice.O[4]" />
          <direct name="dir6" input="fle[1].outQ" output="slice.O[5]" />
          <direct name="dir7" input="fle[2].outMUX" output="slice.O[6]" />
          <direct name="dir8" input="fle[2].out" output="slice.O[7]" />
          <direct name="dir9" input="fle[2].outQ" output="slice.O[8]" />
          <direct name="dir10" input="fle[3].outMUX" output="slice.O[9]" />
          <direct name="dir11" input="fle[3].out" output="slice.O[10]" />
          <direct name="dir12" input="fle[3].outQ" output="slice.O[11]" />
          <direct name="inA" input="slice.I[5:0]" output="fle[0].in" />
          <direct name="inB" input="slice.I[12:7]" output="fle[1].in" />
          <direct name="inC" input="slice.I[19:14]" output="fle[2].in" />
          <direct name="inD" input="slice.I[26:21]" output="fle[3].in" />
        </interconnect>
      </pb_type>
      <!-- Partial Crossbar with each input to the slice connected to 3 outputs from the same slice.
      Values are taken from prjxray-db/artix7/tile_int_l -->
      <interconnect>
        <complete name="top_slice" input="clb.I" output="slice[0:1].I" /> <!-- this is needed to
        avoid errors-->
        <!-- the above is correct because:
        1) in xilinx one wire may connect to multiple lut inputs in either slice.
        2) Every slice input has access to the same wire types -->
        <direct name="top_slice_O" input="slice[0].O" output="clb.O[0:11]" />
        <direct name="bottom_slice_O" input="slice[1].O" output="clb.O[12:23]" />
        <complete name="CLK" input="clb.CLK" output="slice.CLK" />
        <complete name="cross0" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]"
          output="slice[1].I[2]" />
        <complete name="cross1" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]"
          output="slice[0].I[2]" />
        <complete name="cross2" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]"
          output="slice[0].I[1]" />
        <complete name="cross3" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]"
          output="slice[1].I[1]" />
        <complete name="cross4" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]"
          output="slice[0].I[5]" />
        <complete name="cross5" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]"
          output="slice[1].I[5]" />
        <complete name="cross6" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]"
          output="slice[1].I[0]" />
        <complete name="cross7" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]"
          output="slice[0].I[1]" />
        <complete name="cross8" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]"
          output="slice[0].I[4]" />
        <complete name="cross9" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]"
          output="slice[1].I[4]" />
        <complete name="cross10" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]"
          output="slice[1].I[3]" />
        <complete name="cross11" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]"
          output="slice[0].I[3]" />
        <complete name="cross12" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]"
          output="slice[0].I[12]" />
        <complete name="cross13" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]"
          output="slice[0].I[12]" />
        <complete name="cross14" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]"
          output="slice[1].I[7]" />
        <complete name="cross15" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]"
          output="slice[0].I[7]" />
        <complete name="cross16" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]"
          output="slice[1].I[9]" />
        <complete name="cross17" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]"
          output="slice[0].I[9]" />
        <complete name="cross18" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]"
          output="slice[0].I[8]" />
        <complete name="cross19" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]"
          output="slice[1].I[8]" />
        <complete name="cross20" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]"
          output="slice[1].I[15]" />
        <complete name="cross21" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]"
          output="slice[1].I[17]" />
        <complete name="cross22" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]"
          output="slice[0].I[16]" />
        <complete name="cross23" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]"
          output="slice[1].I[16]" />
        <complete name="cross24" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]"
          output="slice[0].I[11]" />
        <complete name="cross25" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]"
          output="slice[1].I[11]" />
        <complete name="cross26" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]"
          output="slice[1].I[10]" />
        <complete name="cross27" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]"
          output="slice[0].I[10]" />
        <complete name="cross28" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]"
          output="slice[0].I[17]" />
        <complete name="cross29" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]"
          output="slice[0].I[15]" />
        <complete name="cross30" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]"
          output="slice[1].I[18]" />
        <complete name="cross31" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]"
          output="slice[0].I[18]" />
        <complete name="cross32" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]"
          output="slice[0].I[14]" />
        <complete name="cross33" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]"
          output="slice[1].I[14]" />
        <complete name="cross34" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]"
          output="slice[1].I[19]" />
        <complete name="cross35" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]"
          output="slice[0].I[19]" />
        <complete name="cross36" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]"
          output="slice[1].I[22]" />
        <complete name="cross37" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]"
          output="slice[1].I[24]" />
        <complete name="cross38" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]"
          output="slice[0].I[23]" />
        <complete name="cross39" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]"
          output="slice[1].I[23]" />
        <complete name="cross40" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]"
          output="slice[0].I[21]" />
        <complete name="cross41" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]"
          output="slice[1].I[21]" />
        <complete name="cross42" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]"
          output="slice[1].I[26]" />
        <complete name="cross43" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]"
          output="slice[0].I[26]" />
        <complete name="cross44" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]"
          output="slice[0].I[24]" />
        <complete name="cross45" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]"
          output="slice[0].I[22]" />
        <complete name="cross46" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]"
          output="slice[1].I[25]" />
        <complete name="cross47" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]"
          output="slice[0].I[25]" />
      </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
  </complexblocklist>
  <!-- TODO: Custom SB's and independent wire distributions in the x/y direction are not fully
  supported yet. 
    After this full support becomes available, a better capture of the xilinx wire interconnect can be
  achieved.   -->


  <switchblocklist>
    <!-- custom SBs used to create diagonal wires -->
    <switchblock name="diagonal_cw_turns" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="tl" formula="W-t" />
        <!-- top to left -->
        <func type="rt" formula="t+1" />
        <!-- right to top -->
        <func type="br" formula="2*W-2-t" />
        <!-- bottom to right -->
        <func type="lb" formula="t+1" />
        <!-- left to bottom -->
      </switchfuncs>
      <wireconn num_conns="min(from,to)" from_type="1len4D_y" from_switchpoint="0"
        to_type="1len2D_x" to_switchpoint="0" switch_override="electrical_short2" /> <!-- technichly
      we could do diagonal wires by just creating a switch override in side wireconn -->
      <wireconn num_conns="min(from,to)" from_type="3len2D_x" from_switchpoint="0"
        to_type="3len4D_y" to_switchpoint="0" switch_override="electrical_short2" />

      <wireconn num_conns="min(from,to)" from_type="len1D_y" from_switchpoint="0" to_type="len1D_x"
        to_switchpoint="0" switch_override="electrical_short2" />
      <wireconn num_conns="min(from,to)" from_type="3len1D_x" from_switchpoint="0"
        to_type="3len1D_y" to_switchpoint="0" switch_override="electrical_short2" />
    </switchblock>

    <switchblock name="diagonal_ccw_turns" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <func type="lt" formula="W-t" />
        <func type="tr" formula="t+1" />
        <func type="rb" formula="2*W-2-t" />
        <func type="bl" formula="t+1" />
      </switchfuncs>
      <wireconn num_conns="min(from,to)" from_type="2len4D_y" from_switchpoint="0"
        to_type="2len2D_x" to_switchpoint="0" switch_override="electrical_short2" />
      <wireconn num_conns="min(from,to)" from_type="4len2D_x" from_switchpoint="0"
        to_type="4len4D_y" to_switchpoint="0" switch_override="electrical_short2" />
      <wireconn num_conns="min(from,to)" from_type="2len1D_y" from_switchpoint="0"
        to_type="2len1D_x" to_switchpoint="0" switch_override="electrical_short2" />
      <wireconn num_conns="min(from,to)" from_type="4len1D_x" from_switchpoint="0"
        to_type="4len1D_y" to_switchpoint="0" switch_override="electrical_short2" />
    </switchblock>
    <!-- End custom SBs used to create diagonal wires -->

    <!-- Normal interconnect (following wilton typology for now) -->
    <!-- <switchblock name="normal_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>

            <func type="rt" formula="W-t"/>

            <func type="rb" formula="t+1"/>

            <func type="lt" formula="2*W-2-t"/>
 
            <func type="lb" formula="t+1"/>
  
            <func type="lr" formula="t"/>
          
            <func type="rl" formula="t"/>
        
        </switchfuncs>
       !! what replaces dummy wire x: len1_x,len2_x,len4_x,len4_stub,len12_x 
         !! what replaces dummy wire y: len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y
        <wireconn num_conns="min(from,to)"
    from_type="1len2D_x,2len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,stub" from_switchpoint="0"
    to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y"
    to_switchpoint="0"/>
        <wireconn num_conns="min(from,to)" from_type="len4_x,len4_stub" from_switchpoint="0"
    to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y"
    to_switchpoint="0"/>

        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="1,2"
    to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y"
    to_switchpoint="0"/>
      </switchblock> -->


    <switchblock name="NE_SE_x" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="lt" formula="W-t" /> <!-- !!! need to change these EQs to match. -->
        <!-- top to left -->
        <func type="lb" formula="t+1" />
        <!-- right to top -->
        <func type="lr" formula="2*W-2-t" />
        <!-- bottom to right -->

      </switchfuncs>
      <!--  when you make multiple from sets you split all the connections in the to set up. Number
      of connections is NUMBER OF CONNECTIONS -->
      <!-- nw se are 2L4 and 3L2 -->
      <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/>  -->

      <!-- NE 2,6 from L -->
      <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we
      leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the
      same direction (I think that is ok though)-->
      <wireconn num_conns="to" from_type="len1D_x,1len2D_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="1len2D_x" from_switchpoint="0" to_type="len12_x"
        to_switchpoint="0" />

      <!-- SE 2,6 from L -->
      <wireconn num_conns="to" from_type="2len1D_x,2len2D_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len1D_y,1len4D_y,1len2D_x,len1D_y,len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="2len2D_x" from_switchpoint="0" to_type="len12_y"
        to_switchpoint="0" />

      <!-- EE4 and EE2 -->
      <wireconn num_conns="to" from_type="len4_x,len2_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,1len4D_y,2len4D_y,3len2D_x,2len1D_y,3len1D_x,4len2D_x,1len4D_y"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="len4_stub" from_switchpoint="0,1,2"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,1len4D_y,2len4D_y,3len2D_x,2len1D_y,3len1D_x,4len2D_x,1len4D_y,len12_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="len4_x" from_switchpoint="0" to_type="len12_x"
        to_switchpoint="0" />

      <!-- EL1 -->
      <wireconn num_conns="7*from" from_type="len1_x" from_switchpoint="0"
        to_type="len1_y,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_x"
        to_switchpoint="0" />
      <wireconn num_conns="2*from" from_type="len1_x" from_switchpoint="0" to_type="len1_x"
        to_switchpoint="0" />

      <!-- L12 -->
      <wireconn num_conns="14" from_type="len12_x" from_switchpoint="0"
        to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

    </switchblock>

    <switchblock name="NE_NW_y" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="bt" formula="W-t" /> <!-- !!! need to change these EQs to match. -->
        <!-- top to left -->
        <func type="bl" formula="t+1" />
        <!-- right to top -->
        <func type="br" formula="2*W-2-t" />
        <!-- bottom to right -->

      </switchfuncs>
      <!--  when you make multiple from sets you split all the connections in the to set up. Number
      of connections is NUMBER OF CONNECTIONS -->


      <!-- NE 2,6 from L -->
      <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we
      leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the
      same direction (I think that is ok though)-->
      <wireconn num_conns="to" from_type="len1D_y,1len4D_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="1len4D_y" from_switchpoint="0" to_type="len12_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="len1D_y" from_switchpoint="0" to_type="len12_x,len12_y"
        to_switchpoint="0" />

      <!-- NW 2,6 the fact this is bottom to garenties this is NW and not SE-->
      <wireconn num_conns="to" from_type="3len1D_y,3len4D_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />

      <!-- NN2 and 6 connection -->
      <wireconn num_conns="to" from_type="len2_y,len6_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,2len4D_y,4len1D_x,4len2D_x,2len1D_y,3len1D_x,3len2D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="len6_y" from_switchpoint="0" to_type="len18_y,len12_y"
        to_switchpoint="0" />

      <!-- NL1 -->
      <wireconn num_conns="7*from" from_type="len1_y" from_switchpoint="0"
        to_type="len1_x,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_y"
        to_switchpoint="0" />
      <wireconn num_conns="2*from" from_type="len1_y" from_switchpoint="0" to_type="len1_y"
        to_switchpoint="0" />

      <!-- L18 L12 -->
      <wireconn num_conns="13" from_type="len18_y" from_switchpoint="0"
        to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

      <wireconn num_conns="10" from_type="len12_y" from_switchpoint="0"
        to_type="len12_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

    </switchblock>

    <switchblock name="SW_SE_x" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="tb" formula="W-t" /> <!-- !!! need to change these EQs to match. -->
        <!-- top to left -->
        <func type="tl" formula="t+1" />
        <!-- right to top -->
        <func type="tr" formula="2*W-2-t" />
        <!-- bottom to right -->

      </switchfuncs>
      <!--  when you make multiple from sets you split all the connections in the to set up. Number
      of connections is NUMBER OF CONNECTIONS -->
      <!-- nw se are 2L4 and 3L2 -->
      <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/>  -->

      <!-- SW 2,6 from T -->
      <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we
      leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the
      same direction (I think that is ok though)-->
      <wireconn num_conns="to" from_type="4len1D_y,4len4D_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />

      <!-- SE 2,6 from T -->
      <wireconn num_conns="to" from_type="3len1D_y,3len4D_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len1D_y,1len4D_y,4len2D_x,len1D_y,4len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="3len4D_y,3len1D_y" from_switchpoint="0" to_type="len12_y"
        to_switchpoint="0" />


      <!-- South bound connections (from top only) -->
      <!-- SS2, SS6 -->
      <wireconn num_conns="to" from_type="len2_y,len6_y" from_switchpoint="0"
        to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len4D_y,2len1D_y,3len1D_x,1len4D_y,4len2D_x,len1D_y,4len1D_x,len12_x"
        to_switchpoint="0" /> <!-- len12 should only conn from ss6 not 2-->
      <!-- I think 28from is the best option -->
      <wireconn num_conns="2*from" from_type="len6_stub" from_switchpoint="0,1,2,5"
        to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len4D_y,2len1D_y,3len1D_x,1len4D_y,4len2D_x,len1D_y,4len1D_x,len12_x"
        to_switchpoint="0" />
      <!-- ^^ stright conns are ok in the middle because in xilinx these cons would happen anyway. -->

      <!-- S1 note that this is the most iregular  -->
      <wireconn num_conns="7*from" from_type="len1_y" from_switchpoint="0"
        to_type="len1_x,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_x"
        to_switchpoint="0" />
      <wireconn num_conns="2*from" from_type="len1_y" from_switchpoint="0" to_type="len1_y"
        to_switchpoint="0" />

      <!-- L18 and L12 -->
      <wireconn num_conns="10" from_type="len18_y" from_switchpoint="9"
        to_type="len12_x,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />
      <wireconn num_conns="13" from_type="len18_y" from_switchpoint="0"
        to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

      <wireconn num_conns="10" from_type="len12_y" from_switchpoint="0"
        to_type="len12_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

    </switchblock>

    <switchblock name="SW_NW_x" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- Clock-wise turns -->
        <func type="rl" formula="W-t" /> <!-- !!! need to change these EQs to match. -->
        <!-- top to left -->
        <func type="rt" formula="t+1" />
        <!-- right to top -->
        <func type="rb" formula="2*W-2-t" />
        <!-- bottom to right -->

      </switchfuncs>
      <!--  when you make multiple from sets you split all the connections in the to set up. Number
      of connections is NUMBER OF CONNECTIONS -->
      <!-- nw se are 2L4 and 3L2 -->
      <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2"
      to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,len1D_y"
      to_switchpoint="0"/>  -->

      <!-- SW 2,6 from T -->
      <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we
      leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the
      same direction (I think that is ok though)-->
      <wireconn num_conns="to" from_type="4len1D_x,4len2D_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="4len2D_x" from_switchpoint="0" to_type="len18_y,len12_y"
        to_switchpoint="0" />
      <wireconn num_conns="from" from_type="4len1D_x" from_switchpoint="0" to_type="len12_y"
        to_switchpoint="0" />

      <!-- NW 2,6 the fact this is bottom to garenties this is NW and not SE-->
      <wireconn num_conns="to" from_type="3len1D_x,3len2D_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="3len2D_x" from_switchpoint="0" to_type="len18_y,len12_y"
        to_switchpoint="0" />
      <wireconn num_conns="to" from_type="3len1D_x" from_switchpoint="0" to_type="len12_x,len12_y"
        to_switchpoint="0" />

      <!-- WW4 WW2 interconn -->
      <wireconn num_conns="to" from_type="len4_x,len2_x" from_switchpoint="0"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,1len4D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,len18_y,len12_y"
        to_switchpoint="0" /> <!-- watch out technichly len18 and 12 should only be connected to ww4
      not 2-->
      <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2"
        to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,1len4D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,len18_y,len12_y"
        to_switchpoint="0" />

      <!-- WL1 -->
      <wireconn num_conns="7*from" from_type="len1_x" from_switchpoint="0"
        to_type="len1_y,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_y"
        to_switchpoint="0" />
      <wireconn num_conns="2*from" from_type="len1_x" from_switchpoint="0" to_type="len1_x"
        to_switchpoint="0" />

      <!-- L12 -->
      <wireconn num_conns="14" from_type="len12_x" from_switchpoint="0"
        to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub"
        to_switchpoint="0" />

    </switchblock>

    <switchblock name="stubs" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- for diagonal 2L2 and L2 and L2 norm and L4 norm  -->
        <func type="rb" formula="W-t" />
        <func type="lt" formula="W-t" />
        <!-- for L1 -->
        <!-- <func type="lb" formula="W-t"/> -->
      </switchfuncs>
      <wireconn num_conns="min(to,from)" from_type="1len2D_x,2len2D_x,len2_x,len4_x"
        from_switchpoint="0" to_type="stub" to_switchpoint="0" switch_override="electrical_short2" />
      <wireconn num_conns="min(to,from)" from_type="len12_x,len2_x,len1_x" from_switchpoint="0"
        to_type="stub" to_switchpoint="0" />
    </switchblock>

    <switchblock name="stubs_L1" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <!-- for L1 -->
        <func type="lb" formula="W-t" />
      </switchfuncs>
      <wireconn num_conns="min(to,from)" from_type="len1_x" from_switchpoint="0" to_type="stub"
        to_switchpoint="0" switch_override="electrical_short2" />
    </switchblock>

    <switchblock name="from_stubs" type="unidir">
      <switchblock_location type="EVERYWHERE" />
      <switchfuncs>
        <func type="tr" formula="W-t" />

        <func type="tl" formula="t+1" />

        <func type="br" formula="2*W-2-t" />

        <func type="bl" formula="t+1" />

        <func type="tb" formula="t" />

        <func type="bt" formula="t" />
      </switchfuncs>
      <wireconn num_conns="3*from" from_type="stub" from_switchpoint="0"
        to_type="len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x"
        to_switchpoint="0" />
    </switchblock>

    <!-- In order to do a proper interconn and not have diagonals gain improper interconn, specify
    corner bot, left by only alowing for tr and lt cons
    for left fringe do rt,rb,tr,br only  -->

    <switchblock name="fringe" type="unidir">
      <switchblock_location type="PERIMETER" />
      <switchfuncs>
        <!-- Counter-clock-wise turns -->
        <func type="lt" formula="W-t" />
        <!-- left to top -->
        <func type="tr" formula="t+1" />
        <!-- top to right -->
        <func type="rb" formula="2*W-2-t" />
        <!-- right to bottom -->
        <func type="bl" formula="t+1" />
        <!-- bottom to left -->
        <!-- Clock-wise turns -->
        <func type="tl" formula="W-t" />
        <!-- top to left -->
        <func type="rt" formula="t+1" />
        <!-- right to top -->
        <func type="br" formula="2*W-2-t" />
        <!-- bottom to right -->
        <func type="lb" formula="t+1" />
        <!-- left to bottom -->
      </switchfuncs>
      <!-- <wireconn num_conns="max(from,to)"
      from_type="len1_y,len1D_y,2len1D_y,3len1D_y,4len1D_y,len2_y,len6_y,len6_stub,len12_y,len18_y,1len4D_y,2len4D_y,3len4D_y,4len4D_y,1len2D_x,2len2D_x,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,len1D_x,2len1D_x,3len1D_x,4len1D_x"
      from_switchpoint="0"
      to_type="len1_y,len1D_y,2len1D_y,3len1D_y,4len1D_y,len2_y,len6_y,len6_stub,len12_y,len18_y,1len4D_y,2len4D_y,3len4D_y,4len4D_y,1len2D_x,2len2D_x,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,len1D_x,2len1D_x,3len1D_x,4len1D_x"
      to_switchpoint="0"/> -->
      <!-- THe above is teribly messy but it gives us a good idea as to what a max will do. can
      confirm it does connect everything. -->
      <!-- This made things worse. chanel on svision3 is 222 was previusly 208 -->
    </switchblock>

  </switchblocklist>

  <power>
    <local_interconnect C_wire="2.5e-10" />
    <mux_transistor_size mux_transistor_size="3" />
    <FF_size FF_size="4" />
    <LUT_transistor_size LUT_transistor_size="4" />
  </power>
  <clocks>
    <clock buffer_size="auto" C_wire="2.5e-10" />
  </clocks>
</architecture>