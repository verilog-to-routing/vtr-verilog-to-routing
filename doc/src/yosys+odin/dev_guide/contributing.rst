Contributing
============

The Odin-II team welcomes outside help from anyone interested.
To fix issues or add a new feature submit a PR or WIP PR following the provided guidelines.
The instruction for Yosys+Odin-II contribution is similar to Odin-II.
For more information about how to contribute and make a WIP pull request please see the Odin-II `contribution documentation <https://docs.verilogtorouting.org/en/latest/odin/dev_guide/contributing/#contributing>`_.

Yosys+Odin-II's Flow
====================

Yosys+Odin-II functions via two CAD tools, Yosys and Odin-II, by executing a set of steps determined by the files and arguments passed in.
The figure below illustrates the synthesis flow of Odin-II, Yosys, and Yosys+Odin-II if a Verilog file is passed, with an optional FPGA Architecture Specification File.
The Yosys+Odin-II synthesis process includes: reading the HDL file and performing a coarse-grained synthesis by Yosys, elaborating the generated coarse-grained netlist by Odin-II, and ultimately performing partial technology mapping and unused logic removal with the FPGA architecture awareness again by Odin-II. 
The simulator is only activated if an input vector file is passed in which creates the output vector file.

Fine-grained BLIF files, usually generated by Odin-II, being passed in are only used for simulation; no partial mapping takes place.
However, the partial mapping can be performed on coarse-grained BLIF netlists, specified by the ``--coarsen`` command argument.
The flow is depicted in the figure below.

.. image:: ./YosysOdinFlow.png
    :width: 100%    
    :alt: The Odin-II and Yosys+Odin-II Synthesis Flow

    
**Figure 1** - The Odin-II and Yosys+Odin-II Synthesis Flow


.. code-block:: tcl

    yosys -import
    
    # the environment variable VTR_ROOT is set by Odin-II.
    # Feel free to specify file paths using "$env(VTR_ROOT)/ ..." 
    
    # Read VTR baseline library first
    read_verilog -nomem2reg $env(ODIN_TECHLIB)/../../vtr_flow/primitives.v
    setattr -mod -set keep_hierarchy 1 single_port_ram
    setattr -mod -set keep_hierarchy 1 dual_port_ram
    
    # Read the HDL file with pre-defined parer in the "run_yosys.sh" script
    if {$env(PARSER) == "surelog" } {
    	puts "Using Yosys read_uhdm command"
    	plugin -i systemverilog;
    	yosys -import
    	read_uhdm -debug $env(TCL_CIRCUIT);
    } elseif {$env(PARSER) == "yosys-plugin" } {
    	puts "Using Yosys read_systemverilog command"
    	plugin -i systemverilog;
    	yosys -import
    	read_systemverilog -debug $env(TCL_CIRCUIT)
    } elseif {$env(PARSER) == "yosys" } {
    	puts "Using Yosys read_verilog command"
    	read_verilog -sv -nomem2reg -nolatches $env(TCL_CIRCUIT);
    } else {
    	error "Invalid PARSER"
    }
    
    # Check that cells match libraries and find top module
    hierarchy -check -auto-top -purge_lib;
    
     
    # Translate processes to netlist components such as MUXs, FFs and latches
    # Transform the design into a new one with single top module
    proc; flatten; opt_expr; opt_clean;
    
    # Looking for combinatorial loops, wires with multiple drivers and used wires without any driver.
    # "-nodffe" to disable dff -> dffe conversion, and other transforms recognizing clock enable
    # "-nosdff" to disable dff -> sdff conversion, and other transforms recognizing sync resets
    check; opt -nodffe -nosdff;
    
    # Extraction and optimization of finite state machines
    fsm; opt;
    # To possibly reduce word sizes by Yosys
    wreduce;
    # To applies a collection of peephole optimizers to the current design.
    peepopt; opt_clean;
     
    # To merge shareable resources into a single resource. A SAT solver
    # is used to determine if two resources are share-able
    share; opt;
    
    # Use a readable name convention
    # [NOTE]: the 'autoname' process has a high memory footprint for giant netlists
    # we run it after basic optimization passes to reduce the overhead (see issue #2031)
    autoname;     
    
    # Looking for combinatorial loops, wires with multiple drivers and used wires without any driver.
    check;
    # resolve asynchronous dffs
    techmap -map $env(ODIN_TECHLIB)/adff2dff.v;
    techmap -map $env(ODIN_TECHLIB)/adffe2dff.v;
    
    # Yosys performs various optimizations on memories in the design. Then, it detects DFFs at
    # memory read ports and merges them into the memory port. I.e. it consumes an asynchronous
    # memory port and the flip-flops at its interface and yields a synchronous memory port.
    # Afterwards, Yosys detects cases where an asynchronous read port is only connected via a mux
    # tree to a write port with the same address. When such a connection is found, it is replaced
    # with a new condition on an enable signal, allowing for removal of the read port. Finally
    # Yosys collects memories, their port and create multiport memory cells.
    opt_mem; memory_dff; opt_clean; opt_mem_feedback; opt_clean; memory_collect;
    
    # convert mem block to bram/rom
    
    # [NOTE]: Yosys complains about expression width more than 24 bits.
    # E.g. [63:0] memory [18:0] ==>  ERROR: Expression width 33554432 exceeds implementation limit of 16777216!
    # mem will be handled using Odin-II
    # memory_bram -rules $env(ODIN_TECHLIB)/mem_rules.txt
    # techmap -map $env(ODIN_TECHLIB)/mem_map.v; 
    
    # Transforming all RTLIL components into LUTs except for memories, adders, subtractors, 
    # multipliers, DFFs with set (VCC) and clear (GND) signals, and DFFs with the set (VCC),
    # clear (GND), and enable signals The Odin-II partial mapper will perform the technology
    # mapping for the above-mentioned circuits
    
    # [NOTE]: the purpose of using this pass is to keep the connectivity of internal signals  
    #         in the coarse-grained BLIF file, as they were not properly connected in the 
    #         initial implementation of Yosys+Odin-II, which did not use this pass
    techmap */t:\$mem */t:\$memrd */t:\$add */t:\$sub */t:\$mul */t:\$dffsr */t:\$dffsre */t:\$sr */t:\$dlatch */t:\$adlatch %% %n;
    
    # Transform the design into a new one with single top module
    flatten;
    
    # To possibly reduce word sizes by Yosys and fine-graining the basic operations
    wreduce; simplemap */t:\$dffsr */t:\$dffsre */t:\$sr */t:\$dlatch */t:\$adlatch %% %n;
    # Turn all DFFs into simple latches
    dffunmap; opt -fast -noff;
    
    # Check the hierarchy for any unknown modules, and purge all modules (including blackboxes) that aren't used
    hierarchy -check -purge_lib;
    
    # "undirven" to ensure there is no wire without drive
    # "opt_muxtree" removes dead branches, "opt_expr" performs constant folding,
    # removes "undef" inputs from mux cells, and replaces muxes with buffers and inverters.
    # "-noff" a potential option to remove all sdff and etc. Only dff will remain
    opt -undriven -full; opt_muxtree; opt_expr -mux_undef -mux_bool -fine;;;
    # Make name convention more readable
    autoname;
    # Print statistics
    stat;
    
    write_blif -param -impltf $env(TCL_BLIF);
    
    
**Algorithm 1** - The Yosys+Odin-II Tcl Script File


Yosys Elaboration
-----------------

Yosys, as an open synthesis suite, reads the input digital circuits and creates the corresponding data structures, such as netlist and Abstract Syntax Tree (AST).
As shown in Algorithm 1, the Tcl script, including the step-by-step generic coarse-grained synthesis commands required to be run by Yosys, is available at ``$VTR_ROOT/ODIN_II/regression_test/tools/synth.tcl``.
Utilizing these commands for the Yosys API inside the Odin-II codebase, the Yosys synthesizer performs the elaboration of the input digital design.
The generic coarse-grained synthesis commands includes: 

1. Parsing the hardware description Verilog/SystemVerilog/UHDM files. The option ``-nomem2reg`` prevents Yosys from exploding implicit memories to an array of registers. The option ``-nolatches`` is used for both VTR primitives and input circuit design to avoid Yosys generating logic loops.
2. Checking that the design cells match the libraries and detecting the top module using ``hierarchy``.
3. Translating the processes to netlist components such as multiplexers, flip-flops, and latches, by the ``procs`` command.
4. The ``flatten`` command generates a netlist with only one module, representing the HDL circuit design's top module.
5. The ``check`` command looks for combinatorial loops, wires with multiple drivers and used wires without any driver.
6. Performing extraction and optimization of finite state machines by the ``fsm`` command.
7. The option ``wreduce`` performs possible word size reduction for operations to avoid propagating additional signals to the subsequent phases.
8. The command ``peephole`` applies a collection of peephole optimizers to the current design.
9. Using the ``share`` command, Yosys merges shareable resources into a single resource (A SAT solver is used to determine if two resources are share-able).

In the ``autoname`` passes, Yosys generates an easy-to-read names by transforming signal names into a shorter format.
This command removes some debugging information, such as the path to the source file, that Yosys inserts in names by default and generally gives easier-to-interpret names.

After performing basic synthesis steps, the ``techmap`` command with the input ``adff2dff`` transforms DFFs with asynchronous reset to the synchronous form using the design provided by Yosys.
The next command follows the same approach but with a modified version of the provided design file for DFFs with asynchronous reset and synchronous data enable signals.

Followed by the ``techmap`` command, Yosys performs various optimizations on memories in the design.
Using the ``memory_dff`` commands, Yosys detects DFFs at memory read ports and merges them into the memory port.
I.e. it consumes an asynchronous memory port and the flip-flops at its interface and yields a synchronous memory port.
Yosys then detects cases where an asynchronous read port is only connected via a mux tree to a write port with the same address.
When such a connection is found, it is replaced with a new condition on an enable signal, allowing for removal of the read port.
Finally Yosys collects memories, their port and create multiport memory cells.

Afterwards, Yosys transforms all RTLIL components into soft logic except for primary hard blocks and latches to postpone their technology mapping to the Odin-II partial mapping phase.
These components include memories, adders, subtractors, multipliers, DFFs with set (VCC) and clear (GND) signals, and DFFs with the set (VCC), clear (GND), and enable signals.
    
.. note::
	
    The purpose of using ``techmap`` pass is to keep the connectivity of internal signals in the coarse-grained BLIF file.
    In the initial implementation of Yosys+Odin-II, in which the Odin-II partial mapper received all components in coarse-grained format, some disconnectivity, resulting from an incomplete elaboration, existed in the BLIF file.
    This solution is proposed to technology-map all primary components and keep the connectivity of the submodules with the top-module in the Yosys output BLIF file.
    It worth noting that Odin-II still receives the memories and arithmetic operations in the coarse-grained format so that it partially-maps them with architecture awareness.

Then, we again flatten the design and the ``simplemap`` command is called to ensure about the connectivity of the technology-mapped components.
The given selection to the ``simplemap`` pass avoid mapping latches and DFFs with set/reset signals, as we want to postpone them for Odin-II partial mapping.
The ``dffunmap`` command turns all types of complex DFFs, such as DFFs with enable and reset signals, into simple latches if there exist any in the design. 

Ultimately, we check the hierarchy for any unknown modules, and purge all modules (including blackboxes) that aren't used.
The optimization pass is then called to make the netlist ready for output.
The option ``undriven`` ensures that all nets without a driver are removed, while the ``full`` optimization option is used to remove duplicated inputs in `AND`, `OR` and `MUX` gates.
The ``opt_muxtree`` removes dead branches, ``opt_expr`` performs possible constant folding, in addition to removing ``undef`` inputs from mux cells and transforming muxes into buffers and inverters.
Ultimately, we use the ``write_blif`` command to output the coarse-grained BLIF file.
The option ``param`` prints some additional information about logic cells into the BLIF file, and the ``impltf`` option conceals the definition of primary netlist ports, i.e., VCC, GND and PAD, in the output.

.. note::

	As earlier mentioned in :ref:`user_guide`, the Yosys BLIF output process, i.e., ``write_blif``, is handled by Yosys embedded API inside the Odin-II codebase. As a result, the last command is not required if a user would like to run the Yosys+Odin-II synthesizer using the Tcl script.


BLIF Reader and Building the Netlist
------------------------------------

In this step, Odin-II reads the Yosys generated coarse-grained BLIF file and creates the corresponding netlist data structure.
Previously, the simulation option was only available when a BLIF file was passed to Odin-II.
However, the option for performing the partial mapping phase on input BLIF files have become available with the Yosys+Odin-II integration.
Using the ``--elaborator yosys`` command argument, the Odin-II BLIF reader reads the Yosys generated coarse-grained BLIF file.
Additionally, if a coarse-grained BLIF file is already created, the user can perform Odin-II partial mapping on that using the ``-b design.blif --coarsen`` command arguments. 

.. note::

	The netlist can be viewed via graphviz using the command ``-G``. The file will appear in the main directory under ``net.dot``.

BLIF Elaboration
----------------

As depicted in Yosys+Odin-II synthesis flow, the difference between fine-grained and coarse-grained netlists is the BLIF elaboration and partial mapping phases in Odin-II technology mapping flow.
Technically, the infrastructure of Odin-II and Yosys differ from each other. 
As a result, the elaboration phase is performed on the input netlist when the input BLIF file is specified as a coarse-grained design to make it compatible with Odin-II partial mapper.
As an example, Yosys generates complex DFFs, such as DFF with synchronous enable and reset, while Odin-II partial mapper only recognizes the simple DFF represented by ``.latch`` in BLIF. 
Therefore, these complex modules are required to be transformed into simpler designs using standard logic cells.



Partial Technology Mapping
--------------------------

During the partial mapping, Odin-II maps the logic using an architecture.
If no architecture is passed in, Odin-II will create the soft logic and use LUTs for mapping.
However, if an architecture is passed, Odin-II will map accordingly to the available hard blocks and LUTs.
It uses a combination of soft logic and hard logic.

.. note::

	Please visit the Yosys's `Developers Guide <https://docs.verilogtorouting.org/en/latest/yosys/dev_guide/#working-with-complex-blocks-and-how-to-instantiate-them?>`_ for more information about how Yosys deals with the complex blocks defined in the VTR architecture file.

With the integration of Yosys+Odin-II, the Odin-II partial mapping features such as hard/soft logic trade-offs become available for a Yosys elaborated circuit.
For instance, using optimization command arguments, a user can force the partial mapper to infer at least a user-defined percentage of multipliers in soft logic.

Simulator
---------

The simulator of Odin-II takes an input vector file and creates an output vector file determined by the behaviour described in the Verilog file or BLIF file.
This section is comprehensivly decribed in the Yosys+Odin-II :ref:`user_guide` and the Odin-II `Simulation Arguments <https://docs.verilogtorouting.org/en/latest/odin/user_guide/#simulation-arguments>`_.