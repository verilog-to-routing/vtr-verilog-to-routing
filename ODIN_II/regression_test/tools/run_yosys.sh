#!/usr/bin/env bash
SHELL=$(type -P bash)

# GLOBAL PATH VARIABLES
THIS_SCRIPT_PATH=$(readlink -f "$0")
THIS_DIR=$(dirname "${THIS_SCRIPT_PATH}")
ODIN_DIR=$(readlink -f "${THIS_DIR}/../..")
VTR_DIR="${ODIN_DIR}/.."
REGRESSION_DIR="${ODIN_DIR}/regression_test"
REG_LIB="${REGRESSION_DIR}/.library"

##############################################
# grab the input args
INPUT="$*"

# disable stdin
exec 0<&-

source "${REG_LIB}/handle_exit.sh"
source "${REG_LIB}/helper.sh"

BENCHMARK_DIR="${REGRESSION_DIR}/benchmark"

VTR_REG_DIR="${VTR_DIR}/vtr_flow/tasks/regression_tests"

SUITE_DIR="${BENCHMARK_DIR}/suite/"
BLIF_SUITE_DIR="${SUITE_DIR}/yosys+odin"
RELAPATH_BLIF_SUITE_DIR=$(realapath_from "${BLIF_SUITE_DIR}" "${PWD}")

TASK_DIR="${BENCHMARK_DIR}/task"
BLIF_TASK_DIR="${TASK_DIR}/yosys+odin"
RELAPATH_BLIF_TASK_DIR=$(realapath_from "${BLIF_TASK_DIR}" "${ODIN_DIR}")


# COLORS
BLUE=$'\033[0;33m'
GREEN=$'\033[0;32m'
RED=$'\033[31;1m'
NC=$'\033[0m' # No Color

# defaults
_YOSYS_EXEC="${VTR_DIR}/libs/EXTERNAL/libyosys/yosys"
_TEST_INPUT_LIST=()
_VERILOG_INPUT_LIST=()
_REGENERATE_BLIF="off"
_SHOW_FAILURE="off"
_SHOW_LOG="off"
_OUTPUT_PATH=""
_CLEAN="off"

###############################################
# Time Helper Functions
function get_current_time() {
	date +%s%3N
}

# needs start time $1
function print_time_since() {
	BEGIN="$1"
	NOW=$(get_current_time)
	TIME_TO_RUN=$(( NOW - BEGIN ))

	Mili=$(( TIME_TO_RUN %1000 ))
	Sec=$(( ( TIME_TO_RUN /1000 ) %60 ))
	Min=$(( ( ( TIME_TO_RUN /1000 ) /60 ) %60 ))
	Hour=$(( ( ( TIME_TO_RUN /1000 ) /60 ) /60 ))

	echo "ran test in: $Hour:$Min:$Sec.$Mili"
}

# print the status of the testbench
function print_test_stat() {
    STAT="$1"
    START_TIME="$2"

    if [ _${STAT} == "_E" ]; then
        echo "[${BLUE}EXIST${NC}] . . . . . . . . . . . . . . . . . . ${OUTPUT_REALPATH}"
    elif [ _${STAT} == "_C" ]; then
        echo "[${GREEN}CREATED${NC}] . . . . . . . . . . . . . . . . . ${OUTPUT_REALPATH} - [${GREEN}$(print_time_since "${START_TIME}")${NC}]"
    elif [ _${STAT} == "_F" ]; then
        echo "[${RED}FAILED${NC}]${RED}  . . . . . . . . . . . . . . . . . ${NC}${OUTPUT_REALPATH}"
    fi
}

#initialization
function init() {
    export ODIN_TECHLIB="${ODIN_DIR}/techlib"
    export BLIF_PATH="${REGRESSION_DIR}/benchmark/_BLIF"
    export PRIMITIVES="${VTR_DIR}/vtr_flow/primitives.v"
}

# run yosys
function run_yosys() {
    TCL_FILE="$1"
    START=$(get_current_time)

    LOG_FILE="${OUTPUT_BLIF_PATH}/failures/${TCL_BLIF_NAME%.*}.log"
    LOG_PATH="${OUTPUT_BLIF_PATH}/logs/${TCL_BLIF_NAME%.*}.log"

    ${_YOSYS_EXEC} -c ${TCL_FILE} > ${LOG_FILE} 2>&1 #/dev/null 2>&1

    if [ -f "${OUTPUT_BLIF_PATH}/${TCL_BLIF_NAME}"  ]; then
        print_test_stat "C" "${START}"
        if [ _${_SHOW_LOG} == "_on" ]; then
            mv ${LOG_FILE} ${LOG_PATH}
        elif [ _${_SHOW_LOG} == "_off" ]; then
            rm ${LOG_FILE}
        fi
    else
        print_test_stat "F" "${START}"
        if [ _${_SHOW_FAILURE} == "_on" ]; then
            cat ${LOG_FILE}
        fi
    fi
}

# Help Print helper
function _prt_cur_arg() {
	arg="[ $1 ]"
	line="\t\t"
	printf "%s%s" "${arg}" "${line:${#arg}}"
}

#to print help of the current script
function help() {
    printf "Called program with $INPUT
        Usage: 
            $0 [ OPTIONS ] [ TEST / SUBTEST_LIST ... ]

        SUBTEST_LIST
            should be a path to a single test or list of the form < task_name >
            passing this in will limit a task to a subset of test
        
    FLAGS
		    --regenerate_blif               $(_prt_cur_arg ${_REGENERATE_BLIF}) regenerate the blifs of verilog files located in benchmark/_BLIF
	
    OPTIONS
            -h|--help                       $(_prt_cur_arg off) print this
            -o|--output                     Specify the output file
            -s|--show_failure               $(_prt_cur_arg ${_SHOW_FAILURE}) show failures in yosys blif generating process
            -l|--show_log                   $(_prt_cur_arg ${_SHOW_LOG}) show logs generated by Yosys
            -V|--verilog < test name >      A path to a single Verilog file
            -t|--test < test name >         A path to a single test file
            -T|--task                       Test name is either a absolute or relative path to 
                                            a directory containing a task.conf, task_list.conf 

        AVAILABLE_TASK:
    "

    printf "\n\t\t%s\n" "${RELAPATH_BLIF_SUITE_DIR}/"
    for bm in "${BLIF_SUITE_DIR}"/*; do printf "\t\t\t%s\n" "$(basename "${bm}")"; done

    printf "\n\t\t%s\n" "${RELAPATH_BLIF_TASK_DIR}/"
    for bm in "${BLIF_TASK_DIR}"/*; do printf "\t\t\t%s\n" "$(basename "${bm}")"; done
}

# to check whether failure and log path exist or not
# if yes clean the failure path from previous logs
function check() {
    FILE_PATH="$1"
    FILE_NAME="$2"

    if [ ! -d "${FILE_PATH}" ]; then
            mkdir -p ${FILE_PATH}
    else    
        if [ "_${_REGENERATE_BLIF}" == "_on" ]; then
            find "${FILE_PATH}" -name "${FILE_NAME}.blif" -delete
        fi
    fi

    FAILURE_PATH="${FILE_PATH}/failures"

    if [ ! -d "${FAILURE_PATH}" ]; then
        mkdir -p ${FAILURE_PATH}
    else    
        find "${FAILURE_PATH}" -name "${FILE_NAME}.log" -delete
    fi

    LOG_PATH="${FILE_PATH}/logs"

    if [ ! -d "${LOG_PATH}" ] && [ "_${_SHOW_LOG}" == "_on" ]; then
        mkdir -p ${LOG_PATH}
    elif [ "_${_SHOW_LOG}" == "_on" ]; then
        find "${LOG_PATH}" -name "${FILE_NAME}.log" -delete
    fi
}

# to parse shell arguments
function parse_args() {
	PARSE_SUBTEST="off"
	while [ "_$*" != "_" ]
	do 
		if [ ${PARSE_SUBTEST} == "on" ];
		then
		# parse subtest
			_SUBTEST_LIST+=( "$1" )
			shift
		else
		# parse [ OPTIONS / FLAGS ] 
			case $1 in 

			# Help Desk
				-h|--help)
					echo "Printing Help information"
					help
					_exit_with_code "0"

				
			## directory in benchmark
				;;-t|--test)
					# this is handled down stream
					if [ "_$2" == "_" ]
					then 
						echo "empty argument for $1"
						_exit_with_code "-1"
					fi
					# concat tests
					_TEST_INPUT_LIST+=( "$2" )
					shift

                ;;-V|--verilog)
					# this is handled down stream
					if [ "_$2" == "_" ]
					then 
						echo "empty argument for $1"
						_exit_with_code "-1"
					fi
					# concat tests
					_VERILOG_INPUT_LIST+=( "$2" )
					shift

                ;;--regenerate_blif)
                        _REGENERATE_BLIF="on"
                        echo "regenerating blifs of benchmark/_BLIF"
                
                ;;-s|--show_failure)
                        _SHOW_FAILURE="on"
                        echo "show yosys log if a benchmark fails"
                
                ;;-l|--show_log)
                        _SHOW_LOG="on"
                        echo "show yosys log for a given benchmark"

                ;;-o|--output)
					# this is handled down stream
					if [ "_$2" == "_" ]
					then 
						echo "empty argument for $1"
						_exit_with_code "-1"
					fi
					# concat tests
					_OUTPUT_PATH=( "$2" )
					shift

                ;;--clean)
                        _CLEAN="on"
                        echo "clean up yosys generated BLIFs directory if exist"

			esac

			# keep the subtest in case we caught the end of options and flags
			[ ${PARSE_SUBTEST} != "on" ] && shift
		fi
	done
}

function format_line() {
	echo "$@" \
		| cut -d '#' -f 1	`# trim the # signs` \
		| sed 's/\s+/ /g'	`# trim duplicate whitespace` \
		| sed 's/\s*$//g'	`# trim the tail end whitespace` \
		| sed 's/^\s*//g'	`# trim the front white space`
}

task_name_list=()

function populate_arg_from_file() {

	_circuits_dir=""
	_circuit_list_add=()

    export TASK_PATH=$(dirname "${1}")
    export TASK_DIR=( $(basename "${TASK_PATH}") )

	if [ "_$1" == "_" ] || [ ! -f "$1" ]
	then
		echo "Config file $1 does not exist"
	else
		OLD_IFS=${IFS}
		while IFS="" read -r current_line || [ -n "${current_line}" ]
		do
			formatted_line=$(format_line "${current_line}")

			_key="$(echo "${formatted_line}" | cut -d '=' -f1 )"
			_value="$(echo "${formatted_line}" | cut -d '=' -f2 )"

			if [ "_${_key}" != "_" ] && [ "_${_value}" == "_" ] 
			then
				echo "Specifying empty value for ${_key}, skipping assignment"
			elif [ "_${_key}" == "_" ] && [ "_${_value}" != "_" ] 
			then
				echo "Specifying empty key for value: ${_value}, skipping assignment"
			elif [ "_${_key}" != "_" ] && [ "_${_value}" != "_" ] 
			then
				case _${_key} in

					_circuits_dir)
						if [ ! -d "${_value}" ]
						then
							_value=${THIS_DIR}/${_value}
						fi
						_circuits_dir="${_value}"

					;;_circuit_list_add)
						# glob the value
						_circuit_list_add+=( "${_circuits_dir}"/${_value} )		

                    ;;_archs_dir)
					;;_arch_list_add)
					;;_script_synthesis_params)
                    ;;_script_techmap_params)
					;;_script_simulation_params)
					;;_simulation_parse_file)
					;;_techmap_parse_file)
                    ;;_synthesis_parse_file)
					;;_synthesis_params)
                    ;;_techmap_params)
					;;_simulation_params)
					;;_regression_params)

					;;_)
						echo "skip" > /dev/null

					;;*)
						echo "Unsupported value: ${_key} ${_value}, skipping"

				esac
			fi
		done < "$1"
		IFS=${OLD_IFS}
	fi

	
	for circuit_list_item in "${_circuit_list_add[@]}"
	do
		if [ ! -f "${circuit_list_item}" ]
		then
			echo "file ${circuit_list_item} not found, skipping"
		else
			_circuit_list+=( "${circuit_list_item}" )
		fi
	done

	if [ "_${#_circuit_list[*]}" == "_" ]
	then
		echo "Passed a config file with no circuit to test"
		_exit_with_code "-1"
	fi
}

function run_single_hdl() {
    for circuit in "${_VERILOG_INPUT_LIST[@]}"
    do
        # validate input file
        if ["${circuit: -3}" != ".sv" and "${circuit: -2}" != ".v" ]; then
            echo "Invalid input Verilog file (${circuit})"
            _exit_with_code "-1"
        fi

        # run yosys for the current circuit
        CIRCUIT_FILE=$(basename "${circuit}")
        CIRCUIT_NAME="${CIRCUIT_FILE%.*}"
        
        export TCL_CIRCUIT="${circuit}"
        if [ _"${_OUTPUT_PATH}" == "_" ]; then
            export OUTPUT_BLIF_PATH="${ODIN_DIR}/yosys"
            export TCL_BLIF_NAME="${CIRCUIT_NAME}.blif"
            OUTPUT_REALPATH="${OUTPUT_BLIF_PATH}/${TCL_BLIF_NAME}"
        else
            export TCL_BLIF_NAME=$(basename "${_OUTPUT_PATH}")
            export OUTPUT_BLIF_PATH="${_OUTPUT_PATH%/*}"
            OUTPUT_REALPATH="${_OUTPUT_PATH}"
        fi

        export TCL_BLIF=${OUTPUT_REALPATH}
        # to check the required path and files
        check "${OUTPUT_BLIF_PATH}" "${TCL_BLIF_NAME%.*}"

        if [ -f "${OUTPUT_BLIF_PATH}/${TCL_BLIF_NAME}" ]; then
            print_test_stat "E"
            continue
        fi
        
        run_yosys "${THIS_DIR}/synth.tcl"
    done

    unset _VERILOG_INPUT_LIST
}

function run_task() {
    directory="$1"
    if [ "_${_CLEAN}" == "_on" ]; then
        BLIFs_DIR=${ODIN_DIR}/${directory/task\/}
        if [ -d "${BLIFs_DIR}" ]; then
            find "${BLIFs_DIR}" -name "*.blif" -delete
        fi
    fi

    populate_arg_from_file "${directory}/task.conf"
   
    for circuit in "${_circuit_list[@]}"
	do
        CIRCUIT_DIR=${circuit/regression_test\/benchmark\/_VERILOG\/}
        CIRCUIT_FILE=$(basename "${circuit}")
                            
        RELAPATH_TASK_DIR=$(realpath --relative-to="${BLIF_TASK_DIR}" "${TASK_PATH}")
        export OUTPUT_BLIF_PATH="${BLIF_PATH}/${RELAPATH_TASK_DIR}"

        # run yosys for the current circuit
        CIRCUIT_NAME="${CIRCUIT_FILE%.*}"

        # to check the required path and files
        check "${OUTPUT_BLIF_PATH}" "${CIRCUIT_NAME}"

        export TCL_CIRCUIT="${circuit}"
        export TCL_BLIF_NAME="${CIRCUIT_NAME}.blif"
        OUTPUT_REALPATH="_BLIF/${TASK_DIR}/${TCL_BLIF_NAME}"

        if [ -f "${OUTPUT_BLIF_PATH}/${TCL_BLIF_NAME}" ]; then
            print_test_stat "E"
            continue
        fi

        export TCL_BLIF="${OUTPUT_BLIF_PATH}/${TCL_BLIF_NAME}"
        run_yosys "${THIS_DIR}/synth.tcl"
    done

    unset _circuit_list
}

task_list=()

function run_suite() {
	current_test_list=( "${_TEST_INPUT_LIST[@]}" )
	while [ "_${current_test_list[*]}" != "_" ]
	do
		current_input="${current_test_list[0]}"
		current_test_list=( "${current_test_list[@]:1}" )

		# try globbing
        current_input_list=( ${current_input} )
        if [ ! -d "${current_input_list[0]}" ]
        then
            # try globbing with absolute
            current_input_list=( "${THIS_DIR}/"${current_input} )
        fi
        # bash expand when possible
        for possible_test in "${current_input_list[@]}"
        do
            if [ ! -d "${possible_test}" ]
            then
                echo "no such Directory for task: ${possible_test}"
            else
                if [ -f "${possible_test}/task_list.conf" ]
                then
                    mapfile -t test_list <"${possible_test}/task_list.conf"
                    current_test_list+=( "${test_list[@]}" )
                    _TEST_INPUT_LIST+=( "${test_list[@]}" )
                elif [ -f "${possible_test}/task.conf" ]
                then
                    task_list+=( "${possible_test}" )
                else
                    echo "Invalid Directory for task: ${possible_test}"
                fi
            fi
        done
				
	done

	TEST_COUNT="0"
	for (( i = 0; i < ${#task_list[@]}; i++ ));
	do
        echo ""
        echo "Task: $(basename ${task_list[$i]})"
        run_task "${task_list[$i]}"
		TEST_COUNT=$(( TEST_COUNT + 1 ))
	done

	if [ "_${TEST_COUNT}" == "_0" ];
	then
		echo "No test is passed in must pass a test directory containing either a task_list.conf or a task.conf, see --help"
		_exit_with_code "-1"
	fi
}

function run() {
    # run single verilog file
    if [ ${#_VERILOG_INPUT_LIST[@]} -gt 0 ]; then
        run_single_hdl
    elif [ ${#_TEST_INPUT_LIST[@]} -gt 0 ]; then
        run_suite
    else 
        echo "No test is passed it must pass a verilog file or test directory containing either a task_list.conf or a task.conf, see --help"
		_exit_with_code "-1"
    fi
}

##############################################################################################
######################################### START HERE #########################################
##############################################################################################

init

parse_args "$@"

run
